[
    {
        "original": "R = 3\r\nC = 3\r\ndef min_cost(cost, m, n): \r\n\ttc = [[0 for x in range(C)] for x in range(R)] \r\n\ttc[0][0] = cost[0][0] \r\n\tfor i in range(1, m+1): \r\n\t\ttc[i][0] = tc[i-1][0] + cost[i][0] \r\n\tfor j in range(1, n+1): \r\n\t\ttc[0][j] = tc[0][j-1] + cost[0][j] \r\n\tfor i in range(1, m+1): \r\n\t\tfor j in range(1, n+1): \r\n\t\t\ttc[i][j] = min(tc[i-1][j-1], tc[i-1][j], tc[i][j-1]) + cost[i][j] \r\n\treturn tc[m][n]",
        "sampled": "def min_cost(cost, m, n):\n    # Initialize the[][] with infinity\n    = [[float('inf')] * (n+1) for _ in range(m+1)]\n    # Initialize the_path[][] with -1\n    for i in range(m+1):\n        for j in range(n+1):\n            if i == 0 and j == 0:\n               _path[i][j] = 0\n            else:\n               _path[i][j] = -1\n    # Initialize the_path[][] with -1\n    for i in"
    },
    {
        "original": "def similar_elements(test_tup1, test_tup2):\r\n  res = tuple(set(test_tup1) & set(test_tup2))\r\n  return (res) ",
        "sampled": " */\n        def similar_elements(lst1, lst2):\n            # create a set of elements from both lists\n            set1 = set(lst1)\n            set2 = set(lst2)\n            # find the common elements\n            common_elements = set1.intersection(set2)\n            # return the common elements as a tuple\n            return tuple(common_elements)\n        # test cases\n        assert similar_elements((3, 4, 5, 6), (5, 7, 4, 10)) == (4, 5)\n        assert similar_elements((1, 2"
    },
    {
        "original": "import math\r\ndef is_not_prime(n):\r\n    result = False\r\n    for i in range(2,int(math.sqrt(n)) + 1):\r\n        if n % i == 0:\r\n            result = True\r\n    return result",
        "sampled": "def is_not_prime(num):\n    if num < 2:\n        return False\n    for i in range(2, num):\n        if num % i == 0:\n            return True\n    return False\n# Test cases\nassert is_not_prime(2) == False\nassert is_not_prime(10) == True\nassert is_not_prime(35) == True"
    },
    {
        "original": "import heapq as hq\r\ndef heap_queue_largest(nums,n):\r\n  largest_nums = hq.nlargest(n, nums)\r\n  return largest_nums",
        "sampled": "def heap_queue_largest(numbers, k):\n    heap = []\n    for num in numbers:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heap\n# Test cases\nassert heap_queue_largest( [25, 35, 22, 85, 14, 65, 75, 22, 58],3)==[85, 75, 65] \nassert heap_queue_largest("
    },
    {
        "original": "def count_ways(n): \r\n\tA = [0] * (n + 1) \r\n\tB = [0] * (n + 1) \r\n\tA[0] = 1\r\n\tA[1] = 0\r\n\tB[0] = 0\r\n\tB[1] = 1\r\n\tfor i in range(2, n+1): \r\n\t\tA[i] = A[i - 2] + 2 * B[i - 1] \r\n\t\tB[i] = A[i - 1] + B[i - 2] \r\n\treturn A[n] ",
        "sampled": "def count_ways(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 3\n    else:\n        return count_ways(n-1) + count_ways(n-2) + count_ways(n-3)\n# Test cases\nassert count_ways(2) == 3\nassert count_ways(8) == 153\nassert count_ways(12) == 2131"
    },
    {
        "original": "def is_Power_Of_Two (x): \r\n    return x and (not(x & (x - 1))) \r\ndef differ_At_One_Bit_Pos(a,b): \r\n    return is_Power_Of_Two(a ^ b)",
        "sampled": ""
    },
    {
        "original": "import re\r\ndef find_char_long(text):\r\n  return (re.findall(r\"\\b\\w{4,}\\b\", text))",
        "sampled": "def find_char_long(string):\n    import re\n    return re.findall(r'\\b\\w{4,}\\b', string)\n# Test cases\nassert find_char_long('Please move back to stream') == ['Please','move', 'back','stream']\nassert find_char_long('Jing Eco and Tech') == ['Jing', 'Tech']\nassert find_char_long('Jhingai wulu road Zone 3') == ['Jhingai', 'wulu', 'road', 'Zone']"
    },
    {
        "original": "def square_nums(nums):\r\n square_nums = list(map(lambda x: x ** 2, nums))\r\n return square_nums",
        "sampled": "def square_nums(lst):\n    return list(map(lambda x: x**2, lst))\n# Test cases\nassert square_nums([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\nassert square_nums([10,20,30])==([100,400,"
    },
    {
        "original": "def find_Rotations(str): \r\n    tmp = str + str\r\n    n = len(str) \r\n    for i in range(1,n + 1): \r\n        substring = tmp[i: i+n] \r\n        if (str == substring): \r\n            return i \r\n    return n ",
        "sampled": "def find_Rotations(s):\n    n = len(s)\n    if n <= 1:\n        return 0\n    min_rotations = n\n    for i in range(n):\n        for j in range(i+1, n):\n            if s[i] == s[j]:\n                min_rotations = min(min_rotations, find_Rotations(s[:i] + s[j+1:] + s[i+1:j]) + 1)\n    return min_rotations\n# Test cases\nassert find_Rotations(\"aaaa\") =="
    },
    {
        "original": "import heapq\r\ndef small_nnum(list1,n):\r\n  smallest=heapq.nsmallest(n,list1)\r\n  return smallest",
        "sampled": "def small_nnum(dataset, n):\n    \"\"\"\n    Returns the n smallest items from the dataset.\n    \"\"\"\n    # Sort the dataset in ascending order\n    sorted_dataset = sorted(dataset)\n    # Return the first n elements of the sorted dataset\n    return sorted_dataset[:n]\n# Test cases\nassert small_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2)==[10,20]\nassert"
    },
    {
        "original": "def remove_Occ(s,ch): \r\n    for i in range(len(s)): \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    for i in range(len(s) - 1,-1,-1):  \r\n        if (s[i] == ch): \r\n            s = s[0 : i] + s[i + 1:] \r\n            break\r\n    return s ",
        "sampled": "def remove_Occ(s, c):\n    return s[:s.find(c)] + s[s.find(c)+1:]\n# Test cases\nassert remove_Occ(\"hello\",\"l\") == \"heo\"\nassert remove_Occ(\"abcda\",\"a\") == \"bcd\"\nassert remove_Occ(\"PHP\",\"P\") == \"H\""
    },
    {
        "original": "def sort_matrix(M):\r\n    result = sorted(M, key=sum)\r\n    return result",
        "sampled": "def sort_matrix(matrix):\n    # create a list of tuples, where each tuple contains the sum of the row and the row itself\n    sums = [(sum(row), row) for row in matrix]\n    # sort the list of tuples by the first element (sum)\n    sums.sort()\n    # create a new matrix with the sorted rows\n    sorted_matrix = [row for sum, row in sums]\n    return sorted_matrix\n# Test cases\nassert sort_matrix([[1, 2, 3], [2, 4, 5], [1, 1, 1"
    },
    {
        "original": "from collections import Counter\r\ndef count_common(words):\r\n  word_counts = Counter(words)\r\n  top_four = word_counts.most_common(4)\r\n  return (top_four)\r\n",
        "sampled": "You can assume that the input dictionary will only contain strings."
    },
    {
        "original": "def find_Volume(l,b,h) : \r\n    return ((l * b * h) / 2) ",
        "sampled": "def find_Volume(base, height, length):\n   _base = base / 2\n   _height = height / 2\n   _length = length / 2\n   _volume = (base * height * length) / 6\n    return round(float(100 * (1 - (0.5 * (1 - (0.5 * (1 - (0.5 * (1 - (0.5 * (1 - (0.5 * (1 - (0.5 * (1 - (0.5 * (1 - (0.5 *"
    },
    {
        "original": "import re\r\ndef split_lowerstring(text):\r\n return (re.findall('[a-z][^a-z]*', text))",
        "sampled": "def split_lowerstring(s):\n    \"\"\"\n    Split a string at lowercase letters.\n    \"\"\"\n    return [s[i:j] for i, j in zip(range(len(s)), range(len(s))+1) if s[i:j].islower()]"
    },
    {
        "original": "import re\r\ndef text_lowercase_underscore(text):\r\n        patterns = '^[a-z]+_[a-z]+$'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')",
        "sampled": ""
    },
    {
        "original": "def square_perimeter(a):\r\n  perimeter=4*a\r\n  return perimeter",
        "sampled": "def square_perimeter(side):\n    \"\"\"\n    This function takes a side of a square as input and returns the perimeter of the square.\n    \"\"\"\n    return 4 * side\n# Test cases\nassert square_perimeter(10)==40\nassert square_perimeter(5)==20\nassert square_perimeter(4)==16"
    },
    {
        "original": "NO_OF_CHARS = 256\r\ndef str_to_list(string): \r\n\ttemp = [] \r\n\tfor x in string: \r\n\t\ttemp.append(x) \r\n\treturn temp \r\ndef lst_to_string(List): \r\n\treturn ''.join(List) \r\ndef get_char_count_array(string): \r\n\tcount = [0] * NO_OF_CHARS \r\n\tfor i in string: \r\n\t\tcount[ord(i)] += 1\r\n\treturn count \r\ndef remove_dirty_chars(string, second_string): \r\n\tcount = get_char_count_array(second_string) \r\n\tip_ind = 0\r\n\tres_ind = 0\r\n\ttemp = '' \r\n\tstr_list = str_to_list(string) \r\n\twhile ip_ind != len(str_list): \r\n\t\ttemp = str_list[ip_ind] \r\n\t\tif count[ord(temp)] == 0: \r\n\t\t\tstr_list[res_ind] = str_list[ip_ind] \r\n\t\t\tres_ind += 1\r\n\t\tip_ind+=1\r\n\treturn lst_to_string(str_list[0:res_ind]) ",
        "sampled": "Note: The input strings may contain uppercase and lowercase letters, digits, and spaces."
    },
    {
        "original": "def test_duplicate(arraynums):\r\n    nums_set = set(arraynums)    \r\n    return len(arraynums) != len(nums_set)     ",
        "sampled": "def test_duplicate(arr):\n    return any(arr.count(x) > 1 for x in arr)\n# Test cases\nassert test_duplicate(([1,2,3,4,5]))==False\nassert test_duplicate(([1,2,3,4, 4]))==True\nassert test_duplicate([1,1,2,2,3,3,4,4,5])==True"
    },
    {
        "original": "def is_woodall(x): \r\n\tif (x % 2 == 0): \r\n\t\treturn False\r\n\tif (x == 1): \r\n\t\treturn True\r\n\tx = x + 1 \r\n\tp = 0\r\n\twhile (x % 2 == 0): \r\n\t\tx = x/2\r\n\t\tp = p + 1\r\n\t\tif (p == x): \r\n\t\t\treturn True\r\n\treturn False",
        "sampled": "def is_woodall(num):\n    if num % 2 == 0:\n        return False\n    else:\n        return True\n# Test cases\nassert is_woodall(383) == True\nassert is_woodall(254) == False\nassert is_woodall(200) == False"
    },
    {
        "original": "def multiples_of_num(m,n): \r\n    multiples_of_num= list(range(n,(m+1)*n, n)) \r\n    return list(multiples_of_num)",
        "sampled": "def multiples_of_num(n,m):\n    \"\"\"\n    Returns a list of m multiples of n.\n    \"\"\"\n    return [i*n for i in range(1,m+1)]"
    },
    {
        "original": "def find_first_duplicate(nums):\r\n    num_set = set()\r\n    no_duplicate = -1\r\n\r\n    for i in range(len(nums)):\r\n\r\n        if nums[i] in num_set:\r\n            return nums[i]\r\n        else:\r\n            num_set.add(nums[i])\r\n\r\n    return no_duplicate",
        "sampled": "def find_first_duplicate(arr):\n    \"\"\"\n    This function takes an array of integers as input and returns the first duplicate element if it exists, otherwise it returns -1.\n    \"\"\"\n    # Create a dictionary to store the frequency of each element in the array\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    # Iterate through the dictionary and find the first element with a frequency greater than 1\n    for num in freq:\n        if freq[num] > 1:\n            return num"
    },
    {
        "original": "def maximum_Sum(list1): \r\n    maxi = -100000\r\n    for x in list1: \r\n        sum = 0 \r\n        for y in x: \r\n            sum+= y      \r\n        maxi = max(sum,maxi)     \r\n    return maxi ",
        "sampled": "def maximum_Sum(lst):\n    max_sum = float('-inf')\n    for i in range(len(lst)):\n        for j in range(len(lst[i])):\n            if lst[i][j] > max_sum:\n                max_sum = lst[i][j]\n    return max_sum\n# Test cases\nassert maximum_Sum([[1,2,3],[4,5,6],[10,11,12],[7,8,9]]) == 33\nassert maximum_Sum([[0,1,1],[1,1,2"
    },
    {
        "original": "def binary_to_decimal(binary): \r\n    binary1 = binary \r\n    decimal, i, n = 0, 0, 0\r\n    while(binary != 0): \r\n        dec = binary % 10\r\n        decimal = decimal + dec * pow(2, i) \r\n        binary = binary//10\r\n        i += 1\r\n    return (decimal)",
        "sampled": "def binary_to_decimal(binary):\n    decimal = 0\n    power = 0\n    while binary > 0:\n        remainder = binary % 10\n        decimal += remainder * (2 ** power)\n        binary //= 10\n        power += 1\n    return decimal"
    },
    {
        "original": "def find_Product(arr,n): \r\n    arr.sort() \r\n    prod = 1\r\n    for i in range(0,n,1): \r\n        if (arr[i - 1] != arr[i]): \r\n            prod = prod * arr[i] \r\n    return prod; ",
        "sampled": "def find_Product(arr, n):\n    # create a set to store unique elements\n    unique_set = set(arr)\n    # initialize the product to 1\n    product = 1\n    # iterate through the unique set\n    for num in unique_set:\n        # multiply the product by the number\n        product *= num\n    # return the product\n    return product\n# Test cases\nassert find_Product([1,1,2,3],4) == 6\nassert find_Product([1,2,3,1,1],5) == 6\nassert find_Product([1"
    },
    {
        "original": "def check_k_elements(test_list, K):\r\n  res = True\r\n  for tup in test_list:\r\n    for ele in tup:\r\n      if ele != K:\r\n        res = False\r\n  return (res) ",
        "sampled": " */\n        def check_k_elements(lst, k):\n            if len(lst) < k:\n                return False\n            for tup in lst:\n                if len(tup)!= k:\n                    return False\n            return True\n        # Test cases\n        assert check_k_elements([(4, 4), (4, 4, 4), (4, 4), (4, 4, 4, 4), (4, )], 4) == True\n        assert check_k_elements([(7, 7, 7), (7, 7)], 7) == True"
    },
    {
        "original": "import re  \r\ndef remove(list): \r\n    pattern = '[0-9]'\r\n    list = [re.sub(pattern, '', i) for i in list] \r\n    return list",
        "sampled": "def remove_digits(lst):\n    return [word.replace(str(digit), '') for word in lst for digit in word if digit.isdigit()]\ndef remove_digits_v2(lst):\n    return [word.replace(str(digit), '') for word in lst for digit in word if digit.isdigit()]\ndef remove_digits_v3(lst):\n    return [word.replace(str(digit), '') for word in lst if any(digit.isdigit() for digit in word)]\ndef remove_digits_v4(lst):\n    return [word.replace"
    },
    {
        "original": "def binomial_Coeff(n,k): \r\n    if k > n : \r\n       return 0\r\n    if k==0 or k ==n : \r\n        return 1 \r\n    return binomial_Coeff(n-1,k-1) + binomial_Coeff(n-1,k) ",
        "sampled": "def binomial_Coeff(n, k):\n    \"\"\"\n    This function returns the binomial coefficient of n and k.\n    \"\"\"\n    if k > n:\n        return 0\n    else:\n        return (n * (n - 1)) // (k * (k - 1))\n# Test cases\nassert binomial_Coeff(5,2) == 10\nassert binomial_Coeff(4,3) == 4\nassert binomial_Coeff(3,2) == 3"
    },
    {
        "original": "def get_Odd_Occurrence(arr,arr_size):   \r\n    for i in range(0,arr_size): \r\n        count = 0\r\n        for j in range(0,arr_size): \r\n            if arr[i] == arr[j]: \r\n                count+=1     \r\n        if (count % 2 != 0): \r\n            return arr[i]     \r\n    return -1",
        "sampled": "def get_Odd_Occurrence(arr, n):\n    count = 0\n    for i in arr:\n        if arr.count(i) % 2!= 0:\n            count += 1\n            if count == n:\n                return i\n    return None\n# Test cases\nassert get_Odd_Occurrence([1,2,3,1,2,3,1],7) == 1\nassert get_Odd_Occurrence([1,2,3,2,3,1,3],7) == 3\nassert get_Odd_Occurrence([2,3,5,"
    },
    {
        "original": "def check_Equality(s): \r\n    return (ord(s[0]) == ord(s[len(s) - 1])); \r\ndef count_Substring_With_Equal_Ends(s): \r\n    result = 0; \r\n    n = len(s); \r\n    for i in range(n): \r\n        for j in range(1,n-i+1):  \r\n            if (check_Equality(s[i:i+j])): \r\n                result+=1; \r\n    return result; ",
        "sampled": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n# Test cases\nassert count_Substring_With_Equal_Ends(\"abc\") == 3\nassert count_Substring_With_Equal_Ends(\"abcda\") == 6\nassert count_Substring_With_Equal_Ends(\"ab\") == 2"
    },
    {
        "original": "def func(nums, k):\r\n    import collections\r\n    d = collections.defaultdict(int)\r\n    for row in nums:\r\n        for i in row:\r\n            d[i] += 1\r\n    temp = []\r\n    import heapq\r\n    for key, v in d.items():\r\n        if len(temp) < k:\r\n            temp.append((v, key))\r\n            if len(temp) == k:\r\n                heapq.heapify(temp)\r\n        else:\r\n            if v > temp[0][0]:\r\n                heapq.heappop(temp)\r\n                heapq.heappush(temp, (v, key))\r\n    result = []\r\n    while temp:\r\n        v, key = heapq.heappop(temp)\r\n        result.append(key)\r\n    return result",
        "sampled": ", 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12]],0)==[]\ndef func(lists, k):\n    # create a min heap of size k\n    heap = []\n    for i in range(k):\n        heapq.heappush(heap, (-lists[0][i], i))\n    # iterate through the lists and update the heap\n    for i in range(1, len(lists)):\n        for j in range(k):\n            if lists["
    },
    {
        "original": "import math \r\ndef max_Prime_Factors (n): \r\n    maxPrime = -1 \r\n    while n%2 == 0: \r\n        maxPrime = 2\r\n        n >>= 1    \r\n    for i in range(3,int(math.sqrt(n))+1,2): \r\n        while n % i == 0: \r\n            maxPrime = i \r\n            n = n / i \r\n    if n > 2: \r\n        maxPrime = n  \r\n    return int(maxPrime)",
        "sampled": "def max_Prime_Factors(num):\n    \"\"\"\n    This function takes a number as input and returns the largest prime factor of the number.\n    \"\"\"\n    # Initialize variables\n    max_factor = 1\n    prime_factors = []\n    # Loop through each number from 2 to the square root of the input number\n    for i in range(2, int(num**0.5)+1):\n        # If the input number is divisible by the current number, divide it by the current number\n        while num % i == 0:\n            # If the current number is a prime number, add it to the"
    },
    {
        "original": "def decimal_To_Binary(N): \r\n    B_Number = 0\r\n    cnt = 0\r\n    while (N != 0): \r\n        rem = N % 2\r\n        c = pow(10,cnt)  \r\n        B_Number += rem*c  \r\n        N //= 2 \r\n        cnt += 1\r\n    return B_Number  ",
        "sampled": "def decimal_To_Binary(num):\n    binary_num = \"\"\n    while num > 0:\n        binary_num = str(num % 2) + binary_num\n        num //= 2\n    return binary_num\n# Test cases\nassert decimal_To_Binary(10) == 1010\nassert decimal_To_Binary(1) == 1\nassert decimal_To_Binary(20) == 10100"
    },
    {
        "original": "def find_missing(ar,N): \r\n    l = 0\r\n    r = N - 1\r\n    while (l <= r):  \r\n        mid = (l + r) / 2\r\n        mid= int (mid) \r\n        if (ar[mid] != mid + 1 and ar[mid - 1] == mid): \r\n            return (mid + 1)  \r\n        elif (ar[mid] != mid + 1): \r\n            r = mid - 1 \r\n        else: \r\n            l = mid + 1\r\n    return (-1) ",
        "sampled": "def find_missing(arr, n):\n    \"\"\"\n    Given a sorted array of integers, find the missing number in the array.\n    \"\"\"\n    # Initialize the sum of the array\n    sum_arr = sum(arr)\n    # Initialize the sum of the numbers from 1 to n\n    sum_rest = n * (n + 1) // 2\n    # Calculate the difference between the sum of the array and the sum of the rest\n    missing_num = sum_rest - sum_arr\n    return missing_num\n# Test cases\nassert find_missing([1,2,3,"
    },
    {
        "original": "def find_rect_num(n):\r\n  return n*(n + 1) ",
        "sampled": "def find_rect_num(n):\n    \"\"\"\n    Returns the n-th rectangular number.\n    \"\"\"\n    if n == 1:\n        return 1\n    else:\n        return 2 * find_rect_num(n-1) - find_rect_num(n-2)\n# Test cases\nassert find_rect_num(4) == 20\nassert find_rect_num(5) == 30\nassert find_rect_num(6) == 42"
    },
    {
        "original": "def find_Nth_Digit(p,q,N) :  \r\n    while (N > 0) : \r\n        N -= 1;  \r\n        p *= 10;  \r\n        res = p // q;  \r\n        p %= q;  \r\n    return res;  ",
        "sampled": "def find_Nth_Digit(num1, den1, num2, den2, N):\n    # Your code here\n    pass"
    },
    {
        "original": "def sort_mixed_list(mixed_list):\r\n    int_part = sorted([i for i in mixed_list if type(i) is int])\r\n    str_part = sorted([i for i in mixed_list if type(i) is str])\r\n    return int_part + str_part",
        "sampled": "def sort_mixed_list(lst):\n    # convert the list to a set to remove duplicates\n    lst = list(set(lst))\n    # sort the list using the sorted() function\n    lst.sort()\n    # convert the sorted list back to a set to remove duplicates\n    return list(set(lst))\n# Test cases\nassert sort_mixed_list([19,'red',12,'green','blue', 10,'white','green',1])==[1, 10, 12, 19, 'blue', 'green', 'green','red"
    },
    {
        "original": "def div_even_odd(list1):\r\n    first_even = next((el for el in list1 if el%2==0),-1)\r\n    first_odd = next((el for el in list1 if el%2!=0),-1)\r\n    return (first_even/first_odd)",
        "sampled": "Here's the function:\ndef div_even_odd(lst):\n    even_count = 0\n    odd_count = 0\n    for num in lst:\n        if num % 2 == 0:\n            even_count += 1\n        else:\n            odd_count += 1\n    if even_count == 0:\n        return odd_count\n    elif odd_count == 0:\n        return even_count\n    else:\n        return even_count / odd_count\n# Test cases\nassert div_even_odd([1,3,5,7,4,1"
    },
    {
        "original": "import heapq\r\nfrom collections import Counter\r\ndef rearange_string(S):\r\n    ctr = Counter(S)\r\n    heap = [(-value, key) for key, value in ctr.items()]\r\n    heapq.heapify(heap)\r\n    if (-heap[0][0]) * 2 > len(S) + 1: \r\n        return \"\"\r\n    ans = []\r\n    while len(heap) >= 2:\r\n        nct1, char1 = heapq.heappop(heap)\r\n        nct2, char2 = heapq.heappop(heap)\r\n        ans.extend([char1, char2])\r\n        if nct1 + 1: heapq.heappush(heap, (nct1 + 1, char1))\r\n        if nct2 + 1: heapq.heappush(heap, (nct2 + 1, char2))\r\n    return \"\".join(ans) + (heap[0][1] if heap else \"\")",
        "sampled": "def rearrange_string(s):\n    # create a dictionary to store the frequency of each character\n    freq = {}\n    for c in s:\n        if c in freq:\n            freq[c] += 1\n        else:\n            freq[c] = 1\n    # sort the characters by frequency\n    sorted_chars = sorted(freq.items(), key=lambda x: x[1], reverse=True)\n    # create a list to store the rearranged characters\n    rearranged_chars = []\n    # iterate over the sorted characters\n    for char, freq in sorted_chars:\n        # if the"
    },
    {
        "original": "from collections import Counter\r\nfrom itertools import chain\r\ndef freq_element(nums):\r\n  result = Counter(chain.from_iterable(nums))\r\n  return result",
        "sampled": "0],[40,50,60],[70,80,90]])==({15: 1, 20: 1, 30: 1, 40: 1, 50: 1, 60: 1, 70: 1, 80: 1, 90: 1})\nassert freq_element([[1,2,3],[4,5,6],[7,8,9]])==({1: 1, 2: 1, 3: 1, "
    },
    {
        "original": "def filter_evennumbers(nums):\r\n even_nums = list(filter(lambda x: x%2 == 0, nums))\r\n return even_nums",
        "sampled": "def filter_evennumbers(numbers):\n    return list(filter(lambda x: x % 2 == 0, numbers))\n# Test cases\nprint(filter_evennumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\nprint(filter_evennumbers([10,20,45,67,84,93]))\nprint(filter_evennumbers([5,7,9,8,6,4,3]))"
    },
    {
        "original": "def find_Sum(arr,n): \r\n    return sum([x for x in arr if arr.count(x) > 1])",
        "sampled": "def find_Sum(arr, n):\n    # Create a dictionary to store the frequency of each element in the array\n    freq = {}\n    for i in arr:\n        if i in freq:\n            freq[i] += 1\n        else:\n            freq[i] = 1\n    # Initialize the sum variable to 0\n    sum = 0\n    # Iterate through the dictionary and add the sum of repeated elements to the sum variable\n    for i in freq:\n        if freq[i] > 1:\n            sum += i * (freq[i] - 1)\n    return sum\n# Test"
    },
    {
        "original": "import re\r\ndef text_match(text):\r\n  patterns = '^[a-z]+_[a-z]+$'\r\n  if re.search(patterns,  text):\r\n    return ('Found a match!')\r\n  else:\r\n    return ('Not matched!')",
        "sampled": "def text_match(text):\n    pattern = r'([a-z])_([a-z])'\n    match = re.search(pattern, text)\n    if match:\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n# Test cases\nassert text_match(\"aab_cbbbc\") == 'Found a match!'\nassert text_match(\"aab_Abbbc\") == 'Not matched!'\nassert text_match(\"Aaab_abbbc\") == 'Not matched!'"
    },
    {
        "original": "import re\r\ndef text_match_string(text):\r\n        patterns = '^\\w+'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return 'Not matched!'",
        "sampled": "def text_match_string(text):\n    if text.startswith('python'):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n# Test cases\nassert text_match_string(\" python\")==('Found a match!')\nassert text_match_string(\"python\")==('Found a match!')\nassert text_match_string(\"  lang\")==('Not matched!')\nassert text_match_string(\" \")==('Not matched!')\nassert text_match_string(\" \")==('Not matched!')\nassert text_match_string(\" \")==('Not matched"
    },
    {
        "original": "def find_gcd(x, y): \r\n\twhile(y): \r\n\t\tx, y = y, x % y \r\n\treturn x \r\ndef get_gcd(l):\r\n  num1 = l[0]\r\n  num2 = l[1]\r\n  gcd = find_gcd(num1, num2)\r\n  for i in range(2, len(l)):\r\n    gcd = find_gcd(gcd, l[i])\r\n  return gcd",
        "sampled": "            The function should take an array of integers as input and return the greatest common divisor (gcd) of all the elements in the array.\n            The gcd of two numbers is the largest number that divides both of them without leaving a remainder. For example, the gcd of 12 and 18 is 6, since 12 divided by 6 leaves a remainder of 0, and 18 divided by 6 leaves a remainder of 0.\n            The function should work for any array of integers, including empty arrays.\n            Note: This function should be able to handle large arrays efficiently, as it should"
    },
    {
        "original": "def test_distinct(data):\r\n  if len(data) == len(set(data)):\r\n    return True\r\n  else:\r\n    return False;",
        "sampled": "def test_distinct(numbers):\n    \"\"\"\n    This function takes a list of numbers as input and returns True if all the numbers are different from each other,\n    and False otherwise.\n    \"\"\"\n    if len(numbers) == len(set(numbers)):\n        return True\n    else:\n        return False\n# Test cases\nassert test_distinct([1,5,7,9]) == True\nassert test_distinct([2,4,5,5,7,9]) == False\nassert test_distinct([1,2,3]) == True"
    },
    {
        "original": "def compute_Last_Digit(A,B): \r\n    variable = 1\r\n    if (A == B): \r\n        return 1\r\n    elif ((B - A) >= 5):  \r\n        return 0\r\n    else:   \r\n        for i in range(A + 1,B + 1): \r\n            variable = (variable * (i % 10)) % 10\r\n        return variable % 10",
        "sampled": "def compute_Last_Digit(a,b):\n    # Compute factorial of a\n    factorial_a = 1\n    for i in range(1,a+1):\n        factorial_a *= i\n    # Compute factorial of b\n    factorial_b = 1\n    for i in range(1,b+1):\n        factorial_b *= i\n    # Check if factorial of a divides factorial of b\n    if factorial_a % factorial_b == 0:\n        # Compute last digit of a\n        last_digit_a = a % 10"
    },
    {
        "original": "def odd_bit_set_number(n):\r\n    count = 0;res = 0;temp = n\r\n    while temp > 0:\r\n        if count % 2 == 0:\r\n            res |= (1 << count)\r\n        count += 1\r\n        temp >>= 1\r\n    return (n | res)",
        "sampled": "def odd_bit_set_number(num):\n    \"\"\"\n    This function takes an integer as input and returns the number with all odd bits set to 1.\n    \"\"\"\n    # Initialize a variable to store the result\n    result = 0\n    # Iterate through each bit in the binary representation of the input number\n    for bit in bin(num)[2:]:\n        # If the current bit is odd, set it to 1\n        if bit == '1':\n            result |= 1 << int(bit)\n    # Return the result\n    return result"
    },
    {
        "original": "def specified_element(nums, N):\r\n    result = [i[N] for i in nums]\r\n    return result\r\n    ",
        "sampled": ""
    },
    {
        "original": "def min_length_list(input_list):\r\n    min_length = min(len(x) for x in input_list )  \r\n    min_list = min(input_list, key = lambda i: len(i))\r\n    return(min_length, min_list)",
        "sampled": "def min_length_list(lst):\n    return min(len(x) for x in lst), min(lst, key=lambda x: len(x))\n# Test cases\nassert min_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(1, [0])\nassert min_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],[1]])==(1"
    },
    {
        "original": "def check_equilateral(x,y,z):\r\n  if x == y == z:\r\n\t   return True\r\n  else:\r\n     return False",
        "sampled": "def check_equilateral(a,b,c):\n    if a==b==c:\n        return True\n    else:\n        return False"
    },
    {
        "original": "def parallelogram_area(b,h):\r\n  area=b*h\r\n  return area",
        "sampled": "def parallelogram_area(base,height):\n    return base*height/2\n# Test cases\nassert parallelogram_area(10,20)==200\nassert parallelogram_area(15,20)==300\nassert parallelogram_area(8,9)==72"
    },
    {
        "original": "def check_Equality(str):\r\n  if (str[0] == str[-1]):  \r\n    return (\"Equal\") \r\n  else:  \r\n    return (\"Not Equal\") ",
        "sampled": "def check_Equality(s):\n    if s[0] == s[-1]:\n        return \"Equal\"\n    else:\n        return \"Not Equal\"\n# Test cases\nassert check_Equality(\"abcda\") == \"Equal\"\nassert check_Equality(\"ab\") == \"Not Equal\"\nassert check_Equality(\"mad\") == \"Not Equal\""
    },
    {
        "original": "def counting_sort(my_list):\r\n    max_value = 0\r\n    for i in range(len(my_list)):\r\n        if my_list[i] > max_value:\r\n            max_value = my_list[i]\r\n    buckets = [0] * (max_value + 1)\r\n    for i in my_list:\r\n        buckets[i] += 1\r\n    i = 0\r\n    for j in range(max_value + 1):\r\n         for a in range(buckets[j]):\r\n             my_list[i] = j\r\n             i += 1\r\n    return my_list",
        "sampled": "def counting_sort(arr):\n    # Find the maximum element in the array\n    max_element = max(arr)\n    # Create a dictionary to store the count of each element\n    count_dict = {}\n    for i in range(max_element + 1):\n        count_dict[i] = 0\n    # Count the occurrences of each element in the array\n    for i in arr:\n        count_dict[i] += 1\n    # Create a new array to store the sorted elements\n    sorted_arr = [0] * len(arr)\n    # Fill the new array with the sorted elements"
    },
    {
        "original": "import math\r\ndef tn_gp(a,n,r):\r\n  tn = a * (math.pow(r, n - 1))\r\n  return tn",
        "sampled": "def tn_gp(a, n, t):\n    \"\"\"\n    Returns the t-nth term of the geometric series a^n.\n    \"\"\"\n    return a**n / (1 - a) ** (t - 1)"
    },
    {
        "original": "def rev(num):    \r\n    rev_num = 0\r\n    while (num > 0):  \r\n        rev_num = (rev_num * 10 + num % 10) \r\n        num = num // 10  \r\n    return rev_num  \r\ndef check(n):    \r\n    return (2 * rev(n) == n + 1)  ",
        "sampled": ""
    },
    {
        "original": "def find_Max_Num(arr,n) : \r\n    arr.sort(reverse = True) \r\n    num = arr[0] \r\n    for i in range(1,n) : \r\n        num = num * 10 + arr[i] \r\n    return num ",
        "sampled": "def find_Max_Num(digits, k):\n    max_num = 0\n    for i in range(len(digits)):\n        for j in range(i+1, len(digits)+1):\n            if j-i <= k:\n                num = int(''.join(sorted(digits[i:j])))\n                if num > max_num:\n                    max_num = num\n    return max_num\n# Test cases\nassert find_Max_Num([1,2,3],3) == 321\nassert find_Max_Num([4,5,6,"
    },
    {
        "original": "def opposite_Signs(x,y): \r\n    return ((x ^ y) < 0); ",
        "sampled": ""
    },
    {
        "original": "def is_octagonal(n): \r\n\treturn 3 * n * n - 2 * n ",
        "sampled": "def is_octagonal(n):\n    \"\"\"\n    Returns True if the given number is an octagonal number, False otherwise.\n    \"\"\"\n    if n < 1:\n        return False\n    return (n * (n + 1)) ** 0.5 == int((n * (n + 1)) ** 0.5)\n# Test cases\nassert is_octagonal(5) == 65\nassert is_octagonal(10) == 280\nassert is_octagonal(15) == 645"
    },
    {
        "original": "def max_len_sub( arr, n): \r\n\tmls=[] \r\n\tmax = 0\r\n\tfor i in range(n): \r\n\t\tmls.append(1) \r\n\tfor i in range(n): \r\n\t\tfor j in range(i): \r\n\t\t\tif (abs(arr[i] - arr[j]) <= 1 and mls[i] < mls[j] + 1): \r\n\t\t\t\tmls[i] = mls[j] + 1\r\n\tfor i in range(n): \r\n\t\tif (max < mls[i]): \r\n\t\t\tmax = mls[i] \r\n\treturn max",
        "sampled": "def max_len_sub(arr, k):\n    if len(arr) < 2:\n        return 0\n    =_set =_len =_start =_end =_max =_min =_diff =_sum =_count =_start =_end =_sum = 0\n   _set = set()\n    =_start = 0\n   _end = 0\n   _sum = 0\n   _count = 0\n   _set.add(arr[0])"
    },
    {
        "original": "from collections import defaultdict\r\ndef count_Substrings(s,n):\r\n    count,sum = 0,0\r\n    mp = defaultdict(lambda : 0)\r\n    mp[0] += 1\r\n    for i in range(n):\r\n        sum += ord(s[i]) - ord('0')\r\n        count += mp[sum - (i + 1)]\r\n        mp[sum - (i + 1)] += 1\r\n    return count",
        "sampled": "def count_Substrings(s, k):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if sum(int(digit) for digit in s[i:j]) == j-i:\n                count += 1\n    return count\n# Test cases\nassert count_Substrings('112112',6) == 6\nassert count_Substrings('111',3) == 6\nassert count_Substrings('1101112',7"
    },
    {
        "original": "def smallest_num(xs):\n  return min(xs)\n",
        "sampled": ""
    },
    {
        "original": "def max_difference(test_list):\r\n  temp = [abs(b - a) for a, b in test_list]\r\n  res = max(temp)\r\n  return (res) ",
        "sampled": " */\n        def max_difference(lst):\n            lst.sort()\n            max_diff = 0\n            for i in range(len(lst) - 1):\n                max_diff = max(max_diff, lst[i+1] - lst[i])\n            return max_diff\n        assert max_difference([(3, 5), (1, 7), (10, 3), (1, 2)]) == 7\n        assert max_difference([(4, 6), (2, 17), (9, 13), (11, 12)])"
    },
    {
        "original": "def subject_marks(subjectmarks):\r\n#subject_marks = [('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])\r\n subjectmarks.sort(key = lambda x: x[1])\r\n return subjectmarks",
        "sampled": "def subject_marks(marks):\n    return sorted(marks, key=lambda x: x[1])\n# Test cases\nassert subject_marks([('English', 88), ('Science', 90), ('Maths', 97), ('Social sciences', 82)])==[('Social sciences', 82), ('English', 88), ('Science', 90), ('Maths', 97)]\nassert subject_marks([('Telugu',49),('Hindhi',54),('Social',33)])==([('"
    },
    {
        "original": "def recursive_list_sum(data_list):\r\n\ttotal = 0\r\n\tfor element in data_list:\r\n\t\tif type(element) == type([]):\r\n\t\t\ttotal = total + recursive_list_sum(element)\r\n\t\telse:\r\n\t\t\ttotal = total + element\r\n\treturn total",
        "sampled": "def recursive_list_sum(lst):\n    if isinstance(lst, list):\n        if not lst:\n            return 0\n        else:\n            return lst[0] + recursive_list_sum(lst[1:])\n    else:\n        return lst\n# Test cases\nassert recursive_list_sum(([1, 2, [3,4],[5,6]]))==21\nassert recursive_list_sum(([7, 10, [15,14],[19,41]]))==106\nassert recursive_list_sum(([10, 20"
    },
    {
        "original": "def pos_count(list):\r\n  pos_count= 0\r\n  for num in list: \r\n    if num >= 0: \r\n      pos_count += 1\r\n  return pos_count ",
        "sampled": "def pos_count(lst):\n    count = 0\n    for num in lst:\n        if num > 0:\n            count += 1\n    return count\n# Test cases\nassert pos_count([1,-2,3,-4]) == 2\nassert pos_count([3,4,5,-1]) == 3\nassert pos_count([1,2,3,4]) == 4"
    },
    {
        "original": "def bell_number(n):   \r\n    bell = [[0 for i in range(n+1)] for j in range(n+1)] \r\n    bell[0][0] = 1\r\n    for i in range(1, n+1): \r\n        bell[i][0] = bell[i-1][i-1]  \r\n        for j in range(1, i+1): \r\n            bell[i][j] = bell[i-1][j-1] + bell[i][j-1]   \r\n    return bell[n][0] ",
        "sampled": "def bell_number(n):\n    if n == 0:\n        return 1\n    elif n == 1:\n        return 1\n    else:\n        return (2*n-1)*bell_number(n-1)\n# Test cases\nassert bell_number(2)==2\nassert bell_number(10)==115975\nassert bell_number(56)==677568532064582432258148306837141974"
    },
    {
        "original": "def is_Monotonic(A): \r\n    return (all(A[i] <= A[i + 1] for i in range(len(A) - 1)) or\r\n            all(A[i] >= A[i + 1] for i in range(len(A) - 1))) ",
        "sampled": " */\n        def is_Monotonic(arr):\n            if len(arr) < 2:\n                return True\n            for i in range(1, len(arr)):\n                if arr[i] < arr[i-1]:\n                    return False\n            return True\n        # Test cases\n        assert is_Monotonic([6, 5, 4, 4]) == True\n        assert is_Monotonic([1, 2, 2, 3]) == True\n        assert is_Monotonic([1, 3, 2]) == False"
    },
    {
        "original": "def is_sublist(l, s):\r\n\tsub_set = False\r\n\tif s == []:\r\n\t\tsub_set = True\r\n\telif s == l:\r\n\t\tsub_set = True\r\n\telif len(s) > len(l):\r\n\t\tsub_set = False\r\n\telse:\r\n\t\tfor i in range(len(l)):\r\n\t\t\tif l[i] == s[0]:\r\n\t\t\t\tn = 1\r\n\t\t\t\twhile (n < len(s)) and (l[i+n] == s[n]):\r\n\t\t\t\t\tn += 1\t\t\t\t\r\n\t\t\t\tif n == len(s):\r\n\t\t\t\t\tsub_set = True\r\n\treturn sub_set",
        "sampled": "def is_sublist(lst, sublist):\n    \"\"\"\n    Returns True if the sublist is present in the list, False otherwise.\n    \"\"\"\n    if not sublist:\n        return True\n    if not lst:\n        return False\n    if lst[0] == sublist[0]:\n        return is_sublist(lst[1:], sublist[1:])\n    return False\n# Test cases\nassert is_sublist([2,4,3,5,7],[3,7])==False\nassert is_sublist([2,4,3,5,7],[4,3"
    },
    {
        "original": "def find_equal_tuple(Input, k):\r\n  flag = 1\r\n  for tuple in Input:\r\n    if len(tuple) != k:\r\n      flag = 0\r\n      break\r\n  return flag\r\ndef get_equal(Input, k):\r\n  if find_equal_tuple(Input, k) == 1:\r\n    return (\"All tuples have same length\")\r\n  else:\r\n    return (\"All tuples do not have same length\")",
        "sampled": "def get_equal(tuples, length):\n    if len(set(len(t) for t in tuples)) == 1:\n        return 'All tuples have same length'\n    else:\n        return 'All tuples do not have same length'\n# Test cases\nassert get_equal([(11, 22, 33), (44, 55, 66)], 3) == 'All tuples have same length'\nassert get_equal([(1, 2, 3), (4, 5, 6, 7)], 3) == '"
    },
    {
        "original": "def comb_sort(nums):\r\n    shrink_fact = 1.3\r\n    gaps = len(nums)\r\n    swapped = True\r\n    i = 0\r\n    while gaps > 1 or swapped:\r\n        gaps = int(float(gaps) / shrink_fact)\r\n        swapped = False\r\n        i = 0\r\n        while gaps + i < len(nums):\r\n            if nums[i] > nums[i+gaps]:\r\n                nums[i], nums[i+gaps] = nums[i+gaps], nums[i]\r\n                swapped = True\r\n            i += 1\r\n    return nums",
        "sampled": "def comb_sort(lst):\n    n = len(lst)\n    gap = n\n    swapped = True\n    while gap > 1 or swapped:\n        swapped = False\n        for i in range(n-gap):\n            if lst[i] > lst[i+gap]:\n                lst[i], lst[i+gap] = lst[i+gap], lst[i]\n                swapped = True\n        gap = int(gap/1.3)\n    return lst\n# Test cases\nassert comb_sort([5, 15, 37, 2"
    },
    {
        "original": "def dif_Square(n): \r\n    if (n % 4 != 2): \r\n        return True\r\n    return False",
        "sampled": "def dif_Square(num):\n    # Check if the number is divisible by 4\n    if num % 4!= 0:\n        return False\n    # Calculate the square of the number\n    square = num ** 2\n    # Check if the square is divisible by 4\n    if square % 4!= 0:\n        return False\n    # Calculate the difference between the square and the original number\n    diff = square - num\n    # Check if the difference is divisible by 4\n    if diff % 4!= 0:\n        return False\n    return True\n# Test cases\nassert dif_"
    },
    {
        "original": "import re\r\ndef multiple_split(text):\r\n  return (re.split('; |, |\\*|\\n',text))",
        "sampled": "def multiple_split(string, delimiters=None):\n    if delimiters is None:\n        delimiters = [' ', '\\n', '\\t', ',', ';', ':', '(', ')', '[', ']', '{', '}', '\"', \"'\"]\n    pattern = '|'.join(map(re.escape, delimiters))\n    return re.split(pattern, string)\n# Test cases\nassert multiple_split('Forces of the \\ndarkness*are coming into the play.') == ['Forces of the ', 'darkness', 'are coming into the play.']\nassert multiple"
    },
    {
        "original": "def is_samepatterns(colors, patterns):    \r\n    if len(colors) != len(patterns):\r\n        return False    \r\n    sdict = {}\r\n    pset = set()\r\n    sset = set()    \r\n    for i in range(len(patterns)):\r\n        pset.add(patterns[i])\r\n        sset.add(colors[i])\r\n        if patterns[i] not in sdict.keys():\r\n            sdict[patterns[i]] = []\r\n\r\n        keys = sdict[patterns[i]]\r\n        keys.append(colors[i])\r\n        sdict[patterns[i]] = keys\r\n\r\n    if len(pset) != len(sset):\r\n        return False   \r\n\r\n    for values in sdict.values():\r\n\r\n        for i in range(len(values) - 1):\r\n            if values[i] != values[i+1]:\r\n                return False\r\n\r\n    return True",
        "sampled": "            The function should take two arguments: patterns and sequence. The patterns array contains the colors of the tiles, and the sequence array contains the colors of the tiles in the correct order. The function should return True if the sequence follows the patterns, and False otherwise.\n            The function should work for anyiles arrangement, including green green.\n            The function should be case-insensitive, and should ignore green green green green green"
    },
    {
        "original": "def find_tuples(test_list, K):\r\n  res = [sub for sub in test_list if all(ele % K == 0 for ele in sub)]\r\n  return (str(res)) ",
        "sampled": " */\n        def find_tuples(lst, k):\n            result = []\n            for tup in lst:\n                if all(x % k == 0 for x in tup):\n                    result.append(tup)\n            return result\n        # Test cases\n        assert find_tuples([(6, 24, 12), (7, 9, 6), (12, 18, 21)], 6) == '[(6, 24, 12)]'\n        assert find_tuples([(5, 25, 30), (4, 2, 3"
    },
    {
        "original": "def count_Squares(m,n):\r\n    if(n < m):\r\n        temp = m\r\n        m = n\r\n        n = temp\r\n    return ((m * (m + 1) * (2 * m + 1) / 6 + (n - m) * m * (m + 1) / 2))",
        "sampled": "def count_Squares(width, height):\n    \"\"\"\n    This function takes in the width and height of a rectangle and returns the number of squares in the rectangle.\n    \"\"\"\n    return width * height\n# Test cases\nassert count_Squares(4,3) == 20\nassert count_Squares(2,2) == 5\nassert count_Squares(1,1) == 1"
    },
    {
        "original": "def is_Diff(n): \r\n    return (n % 11 == 0) ",
        "sampled": "def is_Diff(num):\n    even_sum = 0\n    odd_sum = 0\n    for digit in str(num):\n        if int(digit) % 2 == 0:\n            even_sum += int(digit)\n        else:\n            odd_sum += int(digit)\n    return even_sum - odd_sum\n# Test cases\nassert is_Diff(12345) == False\nassert is_Diff(1212112) == True\nassert is_Diff(1212) == False"
    },
    {
        "original": "def count_With_Odd_SetBits(n): \r\n    if (n % 2 != 0): \r\n        return (n + 1) / 2\r\n    count = bin(n).count('1') \r\n    ans = n / 2\r\n    if (count % 2 != 0): \r\n        ans += 1\r\n    return ans ",
        "sampled": "def count_With_Odd_SetBits(n):\n    count = 0\n    while n > 0:\n        if n & 1:\n            count += 1\n        n >>= 1\n    return count\n# Test cases\nassert count_With_Odd_SetBits(5) == 3\nassert count_With_Odd_SetBits(10) == 5\nassert count_With_Odd_SetBits(15) == 8"
    },
    {
        "original": "def word_len(s): \r\n    s = s.split(' ')   \r\n    for word in s:    \r\n        if len(word)%2!=0: \r\n            return True  \r\n        else:\r\n          return False",
        "sampled": "def word_len(word):\n    if len(word) % 2 == 0:\n        return False\n    else:\n        return True\n# Test cases\nassert word_len(\"Hadoop\") == False\nassert word_len(\"great\") == True\nassert word_len(\"structure\") == True"
    },
    {
        "original": "def tetrahedral_number(n): \r\n\treturn (n * (n + 1) * (n + 2)) / 6",
        "sampled": "def tetrahedral_number(n):\n    \"\"\"\n    Returns the nth tetrahedral number.\n    \"\"\"\n    return (1 + 4*n + 6*n**2 + 4*n**3) / 6\n# Test cases\nassert tetrahedral_number(5) == 35.0\nassert tetrahedral_number(6) == 56.0\nassert tetrahedral_number(7) == 84.0"
    },
    {
        "original": "def zip_tuples(test_tup1, test_tup2):\r\n  res = []\r\n  for i, j in enumerate(test_tup1):\r\n    res.append((j, test_tup2[i % len(test_tup2)])) \r\n  return (res) ",
        "sampled": "The function should take two tuples as input and return a new tuple containing all the pairs of elements from both tuples. The order of the elements in the new tuple should be the same as in the input tuples.\nExample:\nInput: (7, 8, 4, 5, 9, 10), (1, 5, 6)\nOutput: [(7, 1), (8, 5), (4, 6), (5, 1), (9, 5), (10, 6)]\nInput: (8, 9"
    },
    {
        "original": "import math\r\ndef volume_sphere(r):\r\n  volume=(4/3)*math.pi*r*r*r\r\n  return volume",
        "sampled": "The function should take a single argument, the radius of the sphere, and return the volume of the sphere. The volume of a sphere is given by V = 4/3 * pi * r^3, where r is the radius of the sphere.\nHere's the code:\ndef volume_sphere(radius):\n    import math\n    return (4/3) * math.pi * radius**3\nYou can test the function with the provided test cases:\nassert volume_sphere(10)==4188.790204786391"
    },
    {
        "original": "def get_Char(strr):  \r\n    summ = 0\r\n    for i in range(len(strr)): \r\n        summ += (ord(strr[i]) - ord('a') + 1)  \r\n    if (summ % 26 == 0): \r\n        return ord('z') \r\n    else: \r\n        summ = summ % 26\r\n        return chr(ord('a') + summ - 1)",
        "sampled": "def get_Char(str):\n    # initialize an empty string to store the character\n    char = \"\"\n    # loop through each character in the string\n    for i in str:\n        # add the character to the empty string\n        char += i\n    # return the character\n    return char\n# Test cases\nassert get_Char(\"abc\") == \"f\"\nassert get_Char(\"gfg\") == \"t\"\nassert get_Char(\"ab\") == \"c\""
    },
    {
        "original": "def sequence(n): \r\n\tif n == 1 or n == 2: \r\n\t\treturn 1\r\n\telse: \r\n\t\treturn sequence(sequence(n-1)) + sequence(n-sequence(n-1))",
        "sampled": "def sequence(n):\n    \"\"\"\n    Returns the n-th number in the Newman Conway sequence.\n    \"\"\"\n    sequence = [1, 1]\n    for i in range(2, n):\n        sequence.append(sequence[-1] + sequence[-2])\n    return sequence[-1]\n# Test cases\nassert sequence(10) == 6\nassert sequence(2) == 1\nassert sequence(3) == 2"
    },
    {
        "original": "import math\r\ndef surfacearea_sphere(r):\r\n  surfacearea=4*math.pi*r*r\r\n  return surfacearea",
        "sampled": "The function should take a single argument, the radius of the sphere, and return the surface area of the sphere in square units. The surface area of a sphere is given by 4*pi*r^2, where pi is a mathematical constant approximately equal to 3.14159.\nHere's a Python implementation of the function:\n```python\nimport math\ndef surfacearea_sphere(radius):\n    return 4 * math.pi * radius ** 2\n```\nThe function first imports the `math` module, which provides access to mathematical constants like `pi`."
    },
    {
        "original": "def centered_hexagonal_number(n):\r\n  return 3 * n * (n - 1) + 1",
        "sampled": "def centered_hexagonal_number(n):\n    \"\"\"\n    Returns the nth centered hexagonal number.\n    \"\"\"\n    # Calculate thealices ofices ofices ofices ofices\n   alices = [1, 6, 15, 20, 21]\n   ices = [1, 5, 10, 15, 20]\n   ices_of_v = [1, 4, 8, 12, 16]\n   ices_of_v_of_v"
    },
    {
        "original": "import collections as ct\r\ndef merge_dictionaries_three(dict1,dict2, dict3):\r\n    merged_dict = dict(ct.ChainMap({},dict1,dict2,dict3))\r\n    return merged_dict",
        "sampled": "\" }, { \"G\": \"Green\", \"W\": \"White\" },{})=={'R': 'Red', 'B': 'Black', 'P': 'Pink', 'G': 'Green', 'W': 'White'}\nassert merge_dictionaries_three({ \"R\": \"Red\", \"B\": \"Black\", \"P\": \"Pink\" }, {},{ \"G\": \"Green\", \"W\": \"White\" })=={'R': 'Red', 'B': 'Black', 'P': 'Pink', 'G': 'Green', 'W': 'White'}\nassert merge"
    },
    {
        "original": "import collections\r\ndef freq_count(list1):\r\n  freq_count= collections.Counter(list1)\r\n  return freq_count",
        "sampled": "            Note: The input list can have duplicate elements."
    },
    {
        "original": "def closest_num(N):\r\n  return (N - 1)",
        "sampled": ""
    },
    {
        "original": "def len_log(list1):\r\n    max=len(list1[0])\r\n    for i in list1:\r\n        if len(i)>max:\r\n            max=len(i)\r\n    return max",
        "sampled": "def len_log(words):\n    \"\"\"\n    This function takes a list of words as input and returns the length of the longest word in the list.\n    \"\"\"\n    longest_word = \"\"\n    for word in words:\n        if len(word) > len(longest_word):\n            longest_word = word\n    return len(longest_word)\n# Test cases\nassert len_log([\"python\",\"PHP\",\"bigdata\"]) == 7\nassert len_log([\"a\",\"ab\",\"abc\"]) == 3\nassert len_log([\"small\",\"big\",\"tall\"]) == 5"
    },
    {
        "original": "def find_substring(str1, sub_str):\r\n   if any(sub_str in s for s in str1):\r\n       return True\r\n   return False",
        "sampled": "def find_substring(lst, sub):\n    for item in lst:\n        if sub in item:\n            return True\n    return False\n# Test cases\nassert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ack\")==True\nassert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"abc\")==False\nassert find_substring([\"red\", \"black\", \"white\", \"green\", \"orange\"],\"ange\")==True"
    },
    {
        "original": "def is_undulating(n): \r\n\tif (len(n) <= 2): \r\n\t\treturn False\r\n\tfor i in range(2, len(n)): \r\n\t\tif (n[i - 2] != n[i]): \r\n\t\t\treturn False\r\n\treturn True",
        "sampled": "The function should take a string as input and return True if the number is undulating, and False otherwise. A number is undulating if the sum of its digits is equal to the number itself. For example, 1212121 is undulating because 1 + 2 + 1 + 2 + 1 = 12, and 12 is equal to 1212121.\nHere's a possible implementation:\ndef is_undulating(num):\n    digits = [int(d) for d in num]\n    return sum(digits)"
    },
    {
        "original": "def power(a,b):\r\n\tif b==0:\r\n\t\treturn 1\r\n\telif a==0:\r\n\t\treturn 0\r\n\telif b==1:\r\n\t\treturn a\r\n\telse:\r\n\t\treturn a*power(a,b-1)",
        "sampled": "def power(a, b):\n    result = 1\n    for i in range(b):\n        result *= a\n    return result\n# Test cases\nassert power(3,4) == 81\nassert power(2,3) == 8\nassert power(5,5) == 3125"
    },
    {
        "original": "from operator import itemgetter \r\ndef index_minimum(test_list):\r\n  res = min(test_list, key = itemgetter(1))[0]\r\n  return (res) ",
        "sampled": "def index_minimum(lst):\n    \"\"\"\n    Returns the index of the minimum value record in the given list of tuples.\n    \"\"\"\n    min_index = 0\n    min_value = lst[0][1]\n    for i in range(1, len(lst)):\n        if lst[i][1] < min_value:\n            min_index = i\n            min_value = lst[i][1]\n    return min_index\n# Test cases\nassert index_minimum([('Rash', 143), ('Manjeet', 200), ('Varsha', "
    },
    {
        "original": "def Find_Min_Length(lst):  \r\n    minLength = min(len(x) for x in lst )\r\n    return minLength ",
        "sampled": "def Find_Min_Length(lst):\n    min_length = float('inf')\n    for sublist in lst:\n        if len(sublist) < min_length:\n            min_length = len(sublist)\n    return min_length\n# Test cases\nassert Find_Min_Length([[1],[1,2]]) == 1\nassert Find_Min_Length([[1,2],[1,2,3],[1,2,3,4]]) == 2\nassert Find_Min_Length([[3,3,3],[4,4,4,4]]) == "
    },
    {
        "original": "def divisor(n):\r\n  for i in range(n):\r\n    x = len([i for i in range(1,n+1) if not n % i])\r\n  return x",
        "sampled": "The function should take an integer as input and return the number of divisors of the integer. A divisor of an integer is an integer that divides evenly into it without leaving a remainder. For example, 2 is a divisor of 8 because 2 can be written as a sum of 2 and 4, which is 6. The function should return the number of divisors of the input integer."
    },
    {
        "original": "def frequency_lists(list1):\r\n    list1 = [item for sublist in list1 for item in sublist]\r\n    dic_data = {}\r\n    for num in list1:\r\n        if num in dic_data.keys():\r\n            dic_data[num] += 1\r\n        else:\r\n            key = num\r\n            value = 1\r\n            dic_data[key] = value\r\n    return dic_data\r\n",
        "sampled": ",25,32,22],[15,20,25,28]])=={15: 1, 20: 2, 25: 2, 28: 1, 30: 1, 32: 1, 40: 1, 17: 1, 18: 1, 19: 1, 22: 1, 23: 1, 24: 1, 25: 1, 26: 1,"
    },
    {
        "original": "def multiply_num(numbers):  \r\n    total = 1\r\n    for x in numbers:\r\n        total *= x  \r\n    return total/len(numbers) ",
        "sampled": "def multiply_num(lst):\n    return sum(lst) / len(lst)\n# Test cases\nassert multiply_num((8, 2, 3, -1, 7))==-67.2\nassert multiply_num((-10,-20,-30))==-2000.0\nassert multiply_num((19,15,18))==1710.0"
    },
    {
        "original": "def decimal_to_binary(n): \r\n    return bin(n).replace(\"0b\",\"\") ",
        "sampled": "def decimal_to_binary(num):\n    binary = ''\n    while num > 0:\n        binary = str(num % 2) + binary\n        num //= 2\n    return binary\n# Test cases\nassert decimal_to_binary(8) == '1000'\nassert decimal_to_binary(18) == '10010'\nassert decimal_to_binary(7) == '111'"
    },
    {
        "original": "import sys\r\ndef next_smallest_palindrome(num):\r\n    numstr = str(num)\r\n    for i in range(num+1,sys.maxsize):\r\n        if str(i) == str(i)[::-1]:\r\n            return i",
        "sampled": "def next_smallest_palindrome(num):\n    # Convert the number to a string\n    num_str = str(num)\n    # Find the largest palindrome less than or equal to the number\n    largest_palindrome = int(num_str[::-1])\n    # Find the smallest palindrome greater than the number\n    smallest_palindrome = largest_palindrome + 1\n    # Check if the smallest palindrome is a palindrome\n    while str(smallest_palindrome)[::-1]!= str(smallest_palindrome):\n        smallest_palindrome += 1\n    # Check if"
    },
    {
        "original": "def kth_element(arr, n, k):\r\n  for i in range(n):\r\n    for j in range(0, n-i-1):\r\n      if arr[j] > arr[j+1]:\r\n        arr[j], arr[j+1] == arr[j+1], arr[j]\r\n  return arr[k-1]",
        "sampled": " */\n        def kth_element(arr, n, k):\n            arr.sort()\n            return arr[k-1]\n# Test cases\nassert kth_element([12,3,5,7,19], 5, 2) == 3\nassert kth_element([17,24,8,23], 4, 3) == 8\nassert kth_element([16,21,25,36,4], 5, 4) == 36"
    },
    {
        "original": "def snake_to_camel(word):\r\n        import re\r\n        return ''.join(x.capitalize() or '_' for x in word.split('_'))",
        "sampled": "def snake_to_camel(snake_str):\n    \"\"\"\n    Convert snake case string to camel case string.\n    \"\"\"\n    camel_str = ''\n    for word in snake_str.split('_'):\n        camel_str += word.capitalize()\n    return camel_str\n# Test cases\nassert snake_to_camel('python_program')=='PythonProgram'\nassert snake_to_camel('python_language')==('PythonLanguage')\nassert snake_to_camel('programming_language')==('ProgrammingLanguage')"
    },
    {
        "original": "def eulerian_num(n, m): \r\n\tif (m >= n or n == 0): \r\n\t\treturn 0 \r\n\tif (m == 0): \r\n\t\treturn 1 \r\n\treturn ((n - m) * eulerian_num(n - 1, m - 1) +(m + 1) * eulerian_num(n - 1, m))",
        "sampled": "def eulerian_num(n, m):\n    \"\"\"\n    Returns the eulerian number a(n, m).\n    The eulerian number a(n, m) is the number oftetris pieces that can be placed on a n x m grid,\n    such that each piece is placed in a row that is either above or below the piece,\n    and each piece is placed in a column that is either to the left or to the right of the piece.\n    For example, if n = 3 and m = 1, then there are 4 pieces and 1"
    },
    {
        "original": "def sort_sublists(input_list):\r\n    result = [sorted(x, key = lambda x:x[0]) for x in input_list] \r\n    return result\r",
        "sampled": "def sort_sublists(lst):\n    return sorted(lst, key=lambda x: sorted(x))"
    },
    {
        "original": "def count(lst):   \r\n    return sum(lst) ",
        "sampled": "def count(lst):\n    count = 0\n    for i in lst:\n        if i == True:\n            count += 1\n    return count\n# Test cases\nassert count([True,False,True]) == 2\nassert count([False,False]) == 0\nassert count([True,True,True]) == 3"
    },
    {
        "original": "def add_lists(test_list, test_tup):\r\n  res = tuple(list(test_tup) + test_list)\r\n  return (res) ",
        "sampled": "def add_lists(lst, tup):\n    return lst + tup\n# Test cases\nassert add_lists([5, 6, 7], (9, 10)) == (9, 10, 5, 6, 7)\nassert add_lists([6, 7, 8], (10, 11)) == (10, 11, 6, 7, 8)\nassert add_lists([7, 8, 9], (11, 12)) == (11, 12"
    },
    {
        "original": "def count_Hexadecimal(L,R) :  \r\n    count = 0;  \r\n    for i in range(L,R + 1) : \r\n        if (i >= 10 and i <= 15) : \r\n            count += 1;  \r\n        elif (i > 15) : \r\n            k = i;  \r\n            while (k != 0) :  \r\n                if (k % 16 >= 10) : \r\n                    count += 1;  \r\n                k = k // 16;  \r\n    return count;  ",
        "sampled": "def count_Hexadecimal(start, end):\n    count = 0\n    for num in range(start, end+1):\n        if num >= 0 and num <= 15:\n            count += 1\n    return count\n# Test cases\nassert count_Hexadecimal(10,15) == 6\nassert count_Hexadecimal(2,4) == 0\nassert count_Hexadecimal(15,16) == 1"
    },
    {
        "original": "import heapq\r\ndef merge_sorted_list(num1,num2,num3):\r\n  num1=sorted(num1)\r\n  num2=sorted(num2)\r\n  num3=sorted(num3)\r\n  result = heapq.merge(num1,num2,num3)\r\n  return list(result)",
        "sampled": " 2, 3, 4, 5, 5, 6, 7, 7, 8, 8, 9, 11, 12]\nassert merge_sorted_list([1, 3, 5, 6, 8, 9], [2, 5, 7, 11], [1, 4, 7, 8, 12], [1, 2, 4, 5, 6, 7, 8, 9, 10, 11, "
    },
    {
        "original": "def odd_Equivalent(s,n): \r\n    count=0\r\n    for i in range(0,n): \r\n        if (s[i] == '1'): \r\n            count = count + 1\r\n    return count ",
        "sampled": "def odd_Equivalent(binary_string, n):\n    count = 0\n    for i in range(n):\n        if binary_string[i] == '1':\n            count += 1\n    return count\n# Test cases\nprint(odd_Equivalent(\"011001\",6)) # Output: 3\nprint(odd_Equivalent(\"11011\",5)) # Output: 4\nprint(odd_Equivalent(\"1010\",4)) # Output: 2"
    },
    {
        "original": "def extract_missing(test_list, strt_val, stop_val):\r\n  res = []\r\n  for sub in test_list:\r\n    if sub[0] > strt_val:\r\n      res.append((strt_val, sub[0]))\r\n      strt_val = sub[1]\r\n    if strt_val < stop_val:\r\n      res.append((strt_val, stop_val))\r\n  return (res) ",
        "sampled": "52), (2, 15), (19, 52), (19, 38), (50, 52)]\nassert extract_missing([(7, 2), (15, 19), (38, 50)], 5, 52) == [(5, 7), (2, 52), (2, 15), (19, 52), (19, 38), (50, 52)]\nassert extract_missing([(7, 2), (15,"
    },
    {
        "original": "def common_in_nested_lists(nestedlist):\r\n    result = list(set.intersection(*map(set, nestedlist)))\r\n    return result",
        "sampled": "assert common_in_nested_lists([[1, 2, 3], [4, 5, 6], [7, 8, 9]])==[]"
    },
    {
        "original": "def perimeter(diameter,height) : \r\n    return 2*(diameter+height)  ",
        "sampled": "def perimeter(radius, height):\n    \"\"\"\n    Calculates the perimeter of a cylinder with the given radius and height.\n    \"\"\"\n    return 2 * math.pi * radius + 2 * math.pi * radius * height\n# Test cases\nassert perimeter(2,4) == 12\nassert perimeter(1,2) == 6\nassert perimeter(3,1) == 8"
    },
    {
        "original": "def check_integer(text):\r\n text = text.strip()\r\n if len(text) < 1:\r\n    return None\r\n else:\r\n     if all(text[i] in \"0123456789\" for i in range(len(text))):\r\n          return True\r\n     elif (text[0] in \"+-\") and \\\r\n         all(text[i] in \"0123456789\" for i in range(1,len(text))):\r\n         return True\r\n     else:\r\n        return False",
        "sampled": "def check_integer(s):\n    try:\n        int(s)\n        return True\n    except ValueError:\n        return False"
    },
    {
        "original": "from collections import Counter \r\ndef assign_freq(test_list):\r\n  res = [(*key, val) for key, val in Counter(test_list).items()]\r\n  return (str(res)) ",
        "sampled": "), (11, 13, 10)] ) == '[(11, 13, 10, 3), (17, 21, 2), (4, 2, 3, 1), (9, 2, 1)]'\nassert assign_freq([(1, 2, 3), (4, 5, 6), (7, 8, 9), (1, 2, 3), (4, 5, 6), (7, 8, 9)] ) == '[(1"
    },
    {
        "original": "def empty_dit(list1):\r\n empty_dit=all(not d for d in list1)\r\n return empty_dit",
        "sampled": ""
    },
    {
        "original": "def tuple_to_int(nums):\r\n    result = int(''.join(map(str,nums)))\r\n    return result",
        "sampled": "def tuple_to_int(t):\n    return sum(t)"
    },
    {
        "original": "def list_to_float(test_list):\r\n  res = []\r\n  for tup in test_list:\r\n    temp = []\r\n    for ele in tup:\r\n      if ele.isalpha():\r\n        temp.append(ele)\r\n      else:\r\n        temp.append(float(ele))\r\n    res.append((temp[0],temp[1])) \r\n  return (str(res)) ",
        "sampled": " ) == '[(6.0, 78.0), (5.0, 26.45), (1.33, 4.0), (82.0, 13.0)]'\nassert list_to_float( [(\"1\", \"2\"), (\"3\", \"4\"), (\"5\", \"6\"), (\"7\", \"8\")] ) == '[(1.0, 2.0), (3.0, 4.0), (5.0, 6.0), (7.0, 8.0)]'"
    },
    {
        "original": "def string_to_list(string): \r\n    lst = list(string.split(\" \")) \r\n    return lst",
        "sampled": ""
    },
    {
        "original": "def search(arr,n) :\r\n    XOR = 0\r\n    for i in range(n) :\r\n        XOR = XOR ^ arr[i]\r\n    return (XOR)",
        "sampled": "def search(arr, x):\n    \"\"\"\n    This function takes a sorted array and an element x as input and returns the element that appears only once in the array.\n    If there are multiple elements that appear only once, the function returns the first one it finds.\n    If the element x is not present in the array, the function returns None.\n    \"\"\"\n    # Initialize a dictionary to store the frequency of each element in the array\n    freq = {}\n    for num in arr:\n        if num in freq:\n            freq[num] += 1\n        else:\n            freq[num] = 1\n    # Iterate through"
    },
    {
        "original": "def max_product_tuple(list1):\r\n    result_max = max([abs(x * y) for x, y in list1] )\r\n    return result_max",
        "sampled": "The function should take a list of tuples as input and return the maximum product of any two pairs of tuples in the list.\nFor example, if the input is [(2, 7), (2, 6), (1, 8), (4, 9)], the function should return 36, since the maximum product of any two pairs is 2*7 = 14 and 2*6 = 12.\nIf the input is [(10,20), (15,2), (5,10)], the function should return 200,"
    },
    {
        "original": "def check_triplet(A, n, sum, count):\r\n    if count == 3 and sum == 0:\r\n        return True\r\n    if count == 3 or n == 0 or sum < 0:\r\n        return False\r\n    return check_triplet(A, n - 1, sum - A[n - 1], count + 1) or\\\r\n           check_triplet(A, n - 1, sum, count)",
        "sampled": " */\n        def check_triplet(arr, target_sum):\n            arr.sort()\n            for i in range(len(arr) - 2):\n                if i > 0 and arr[i] == arr[i - 1]:\n                    continue\n                left = i + 1\n                right = len(arr) - 1\n                while left < right:\n                    current_sum = arr[i] + arr[left] + arr[right]\n                    if current_sum == target_sum:\n                        return True\n                    elif current_sum < target_sum:\n                        left += 1\n                    else:"
    },
    {
        "original": "MAX = 3000 \r\ndef smartNumber(n): \r\n\tprimes = [0] * MAX \r\n\tresult = [] \r\n\tfor i in range(2, MAX): \r\n\t\tif (primes[i] == 0): \r\n\t\t\tprimes[i] = 1 \r\n\t\t\tj = i * 2 \r\n\t\t\twhile (j < MAX): \r\n\t\t\t\tprimes[j] -= 1 \r\n\t\t\t\tif ( (primes[j] + 3) == 0): \r\n\t\t\t\t\tresult.append(j) \r\n\t\t\t\tj = j + i \r\n\tresult.sort() \r\n\treturn result[n - 1] ",
        "sampled": "The function should take an integer n as input and return the n\u2019th smart number. A smart number is a positive integer that is divisible by 3, 5, and 7. The is to write a function that can find the n\u2019th smart number in O(1) time complexity.\nHere's a possible implementation:\ndef smartNumber(n):\n    # Initialize the to store the numbers\n   _numbers = [i for i in range(1, 1000)]\n    # Initialize the number to be found\n    target_number = 0"
    },
    {
        "original": "def amicable_numbers_sum(limit):\r\n    if not isinstance(limit, int):\r\n        return \"Input is not an integer!\"\r\n    if limit < 1:\r\n        return \"Input must be bigger than 0!\"\r\n    amicables = set()\r\n    for num in range(2, limit+1):\r\n        if num in amicables:\r\n            continue\r\n        sum_fact = sum([fact for fact in range(1, num) if num % fact == 0])\r\n        sum_fact2 = sum([fact for fact in range(1, sum_fact) if sum_fact % fact == 0])\r\n        if num == sum_fact2 and num != sum_fact:\r\n            amicables.add(num)\r\n            amicables.add(sum_fact2)\r\n    return sum(amicables)",
        "sampled": "def amicable_numbers_sum(n):\n    \"\"\"\n    Returns the sum of all amicable numbers from 1 to n.\n    \"\"\"\n    # Create a list of all numbers from 1 to n\n    numbers = list(range(1, n+1))\n    # Initialize a dictionary to store the sum of each pair of amicable numbers\n    amicable_sum_dict = {}\n    # Loop through the numbers and check if they are amicable\n    for num in numbers:\n        # Check if the number is divisible by any number from 2 to the square root of the number"
    },
    {
        "original": "import cmath\r\ndef angle_complex(a,b):\r\n  cn=complex(a,b)\r\n  angle=cmath.phase(a+b)\r\n  return angle",
        "sampled": "Here's the function:\ndef angle_complex(a, b):\n    import math\n    return math.atan2(b.imag, b.real)\nThe function takes two complex numbers as input, `a` and `b`, and returns their angle in radians. The `math.atan2` function is used to calculate the angle, which takes the imaginary and real parts of the complex number as input and returns the angle in radians.\nThe function passes the tests because it calculates the correct angle for the given complex numbers."
    },
    {
        "original": "def find_length(string, n): \r\n\tcurrent_sum = 0\r\n\tmax_sum = 0\r\n\tfor i in range(n): \r\n\t\tcurrent_sum += (1 if string[i] == '0' else -1) \r\n\t\tif current_sum < 0: \r\n\t\t\tcurrent_sum = 0\r\n\t\tmax_sum = max(current_sum, max_sum) \r\n\treturn max_sum if max_sum else 0",
        "sampled": "_diff_in_substrings(\"11000010001\", 11) == 6\nassert find_length(\"10111\", 5) == 1\nassert find_length(\"11011101100101\", 14) == 2"
    },
    {
        "original": "def sum(a,b): \r\n    sum = 0\r\n    for i in range (1,min(a,b)): \r\n        if (a % i == 0 and b % i == 0): \r\n            sum += i \r\n    return sum",
        "sampled": "Here's the code for the function:\ndef sum_common_divisors(num1, num2):\n    # Find the set of common divisors of num1 and num2\n    common_divisors = set(set(num1).intersection(set(num2)))\n    # Find the sum of common divisors\n    sum_of_common_divisors = sum(common_divisors)\n    return sum_of_common_divisors\n# Test cases\nassert sum_common_divisors(10,15) == 6"
    },
    {
        "original": "def multiply_int(x, y):\r\n    if y < 0:\r\n        return -multiply_int(x, -y)\r\n    elif y == 0:\r\n        return 0\r\n    elif y == 1:\r\n        return x\r\n    else:\r\n        return x + multiply_int(x, y - 1)",
        "sampled": "def multiply_int(a,b):\n    result = 0\n    while b > 0:\n        if b & 1:\n            result += a\n        a <<= 1\n        b >>= 1\n    return result\n# Test cases\nassert multiply_int(10,20)==200\nassert multiply_int(5,10)==50\nassert multiply_int(4,8)==32"
    },
    {
        "original": "def long_words(n, str):\r\n    word_len = []\r\n    txt = str.split(\" \")\r\n    for x in txt:\r\n        if len(x) > n:\r\n            word_len.append(x)\r\n    return word_len\t",
        "sampled": "def long_words(n,words):\n    return [word for word in words if len(word)>n]\n# Test cases\nassert long_words(3,\"python is a programming language\")==['python','programming','language']\nassert long_words(2,\"writing a program\")==['writing','program']\nassert long_words(5,\"sorting list\")==['sorting']"
    },
    {
        "original": "def magic_square_test(my_matrix):\r\n    iSize = len(my_matrix[0])\r\n    sum_list = []\r\n    sum_list.extend([sum (lines) for lines in my_matrix])   \r\n    for col in range(iSize):\r\n        sum_list.append(sum(row[col] for row in my_matrix))\r\n    result1 = 0\r\n    for i in range(0,iSize):\r\n        result1 +=my_matrix[i][i]\r\n    sum_list.append(result1)      \r\n    result2 = 0\r\n    for i in range(iSize-1,-1,-1):\r\n        result2 +=my_matrix[i][i]\r\n    sum_list.append(result2)\r\n    if len(set(sum_list))>1:\r\n        return False\r\n    return True",
        "sampled": "The function should take a list of lists as input and return True if the input is a magic square, and False otherwise. A magic square is a square matrix where the sum of the elements in each row, column, and diagonal is the same.\nFor example, the magic square [[7, 12, 1, 14], [2, 13, 8, 11], [16, 3, 10, 5], [9, 6, 15, 4]] is a valid magic square, while the magic square [[2, "
    },
    {
        "original": "from collections import defaultdict\r\ndef max_occurrences(nums):\r\n    dict = defaultdict(int)\r\n    for i in nums:\r\n        dict[i] += 1\r\n    result = max(dict.items(), key=lambda x: x[1]) \r\n    return result",
        "sampled": "def max_occurrences(lst):\n    # Create a dictionary to store the frequency of each item in the list\n    freq_dict = {}\n    for item in lst:\n        if item in freq_dict:\n            freq_dict[item] += 1\n        else:\n            freq_dict[item] = 1\n    # Find the item with the maximum frequency\n    max_item = None\n    max_freq = 0\n    for item, freq in freq_dict.items():\n        if freq > max_freq:\n            max_item = item\n            max_freq = freq\n    return max_item, max"
    },
    {
        "original": "def reverse_vowels(str1):\r\n\tvowels = \"\"\r\n\tfor char in str1:\r\n\t\tif char in \"aeiouAEIOU\":\r\n\t\t\tvowels += char\r\n\tresult_string = \"\"\r\n\tfor char in str1:\r\n\t\tif char in \"aeiouAEIOU\":\r\n\t\t\tresult_string += vowels[-1]\r\n\t\t\tvowels = vowels[:-1]\r\n\t\telse:\r\n\t\t\tresult_string += char\r\n\treturn result_string",
        "sampled": ""
    },
    {
        "original": "def tup_string(tup1):\r\n  str =  ''.join(tup1)\r\n  return str",
        "sampled": "def tup_string(tup):\n    return ''.join(tup)"
    },
    {
        "original": "def sum_negativenum(nums):\r\n  sum_negativenum = list(filter(lambda nums:nums<0,nums))\r\n  return sum(sum_negativenum)",
        "sampled": "Here's the code to implement the function:\ndef sum_negativenum(numbers):\n    return sum(map(lambda x: x if x < 0 else 0, numbers))\n# Test cases\nassert sum_negativenum([2, 4, -6, -9, 11, -12, 14, -5, 17])==-32\nassert sum_negativenum([10,15,-14,13,-18,12,-20])==-52\nassert sum"
    },
    {
        "original": "def check_last (arr,n,p): \r\n    _sum = 0\r\n    for i in range(n): \r\n        _sum = _sum + arr[i] \r\n    if p == 1: \r\n        if _sum % 2 == 0: \r\n            return \"ODD\"\r\n        else: \r\n            return \"EVEN\"\r\n    return \"EVEN\"\r\n      ",
        "sampled": "def check_last(arr, p, op):\n    if op == 1:\n        return \"ODD\" if arr[-1] % 2!= 0 else \"EVEN\"\n    elif op == 2:\n        return \"EVEN\" if arr[-1] % 2 == 0 else \"ODD\"\n    else:\n        return \"Invalid operation\""
    },
    {
        "original": "def hexagonal_num(n): \r\n\treturn n*(2*n - 1) ",
        "sampled": "The_num function should take an integer n as input and return the nth hexagonal number. The_num function should use the formula:\nh_num = (n * (3 * n - 1)) / 2\nwhere n is the input integer.\nNote: This function assumes that n is a positive integer. If n is negative, the function should return None. If n is 0, the function should return 0."
    },
    {
        "original": "def cal_electbill(units):\r\n if(units < 50):\r\n    amount = units * 2.60\r\n    surcharge = 25\r\n elif(units <= 100):\r\n    amount = 130 + ((units - 50) * 3.25)\r\n    surcharge = 35\r\n elif(units <= 200):\r\n    amount = 130 + 162.50 + ((units - 100) * 5.26)\r\n    surcharge = 45\r\n else:\r\n    amount = 130 + 162.50 + 526 + ((units - 200) * 8.45)\r\n    surcharge = 75\r\n total = amount + surcharge\r\n return total",
        "sampled": "The function should take a single argument, which is theage of the. The function should return the electricity bill in dollars.\nTo calculate the electricity bill, you can use the formula:\nelectricity bill =age *age *age *age *age *age * 0.0001\nYou can use the math module in Python to perform the calculation. Here's the code:\ndef cal_electbill(age):\n    electricity_bill = age * age * age * age * age * age * 0.0"
    },
    {
        "original": "from array import array\r\ndef zero_count(nums):\r\n    n = len(nums)\r\n    n1 = 0\r\n    for x in nums:\r\n        if x == 0:\r\n            n1 += 1\r\n        else:\r\n          None\r\n    return round(n1/n,2)",
        "sampled": "The function should take an array of integers as input and return the ration of zeroes in the array. The ration is calculated as the number of zeroes divided by the total number of elements in the array. If there are no zeroes, the function should return 0.0.\nExamples:\nzero_count([0, 1, 2, -1, -5, 6, 0, -3, -2, 3, 4, 6, 8]) == 0.15\nzero_count([2, 1, 2, -"
    },
    {
        "original": "def is_Sum_Of_Powers_Of_Two(n): \r\n    if (n % 2 == 1): \r\n        return False\r\n    else: \r\n        return True",
        "sampled": ""
    },
    {
        "original": "def circle_circumference(r):\r\n  perimeter=2*3.1415*r\r\n  return perimeter",
        "sampled": "The function should take a radius as input and return the circumference of a circle with that radius. The formula for the circumference of a circle is:\nC = 2 * pi * r\nwhere pi is a mathematical constant approximately equal to 3.14159.\nNote: The input radius should be a positive number. If the radius is 0, the function should return 0."
    },
    {
        "original": "def extract_singly(test_list):\r\n  res = []\r\n  temp = set()\r\n  for inner in test_list:\r\n    for ele in inner:\r\n      if not ele in temp:\r\n        temp.add(ele)\r\n        res.append(ele)\r\n  return (res) ",
        "sampled": "def extract_singly(lst):\n    singly_elements = []\n    for tup in lst:\n        if len(tup) == len(set(tup)):\n            singly_elements.extend(tup)\n    return singly_elements\n# Test cases\nassert extract_singly([(3, 4, 5), (4, 5, 7), (1, 4)]) == [3, 4, 5, 7, 1]\nassert extract_singly([(1, 2, 3), (4, 2, 3), (7"
    },
    {
        "original": "def pancake_sort(nums):\r\n    arr_len = len(nums)\r\n    while arr_len > 1:\r\n        mi = nums.index(max(nums[0:arr_len]))\r\n        nums = nums[mi::-1] + nums[mi+1:len(nums)]\r\n        nums = nums[arr_len-1::-1] + nums[arr_len:len(nums)]\r\n        arr_len -= 1\r\n    return nums",
        "sampled": "def pancake_sort(lst):\n    # Helper function to swap elements in the list\n    def swap(lst, i, j):\n        lst[i], lst[j] = lst[j], lst[i]\n    # Helper function to reverse the list from index i to j\n    def reverse(lst, i, j):\n        while i < j:\n            swap(lst, i, j)\n            i += 1\n            j -= 1\n    # Helper function to find the position of the element\n    def find_max(lst, i, j):\n        max_index = i"
    },
    {
        "original": "def count_samepair(list1,list2,list3):\r\n    result = sum(m == n == o for m, n, o in zip(list1,list2,list3))\r\n    return result",
        "sampled": "Here's the function:\ndef count_samepair(list1, list2, list3):\n    count = 0\n    for i in range(len(list1)):\n        if list1[i] == list2[i] and list1[i] == list3[i]:\n            count += 1\n    return count\n# Test cases\nassert count_samepair([1,2,3,4,5,6,7,8],[2,2,3,1,2,6,7,9],[2,1,3,1,2,6,"
    },
    {
        "original": "def find_lists(Input): \r\n\tif isinstance(Input, list): \r\n\t\treturn 1\r\n\telse: \r\n\t\treturn len(Input) ",
        "sampled": "def find_lists(t):\n    count = 0\n    for item in t:\n        if isinstance(item, list):\n            count += 1\n    return count\n# Test cases\nassert find_lists(([1, 2, 3, 4], [5, 6, 7, 8])) == 2\nassert find_lists(([1, 2], [3, 4], [5, 6]))  == 3\nassert find_lists(([9, 8, 7, 6, 5, 4, 3, 2,"
    },
    {
        "original": "def sum_Pairs(arr,n): \r\n    sum = 0\r\n    for i in range(n - 1,-1,-1): \r\n        sum += i*arr[i] - (n-1-i) * arr[i] \r\n    return sum",
        "sampled": "def sum_Pairs(arr, n):\n    \"\"\"\n    This function takes an array and a number n as input and returns the sum of absolute differences in all pairs of the array.\n    \"\"\"\n    arr.sort()\n    diff_sum = 0\n    for i in range(n):\n        diff_sum += abs(arr[i] - arr[i+1])\n    return diff_sum\n# Test cases\nassert sum_Pairs([1,8,9,15,16],5) == 74\nassert sum_Pairs([1,2,3,4],4)"
    },
    {
        "original": "def max_Abs_Diff(arr,n): \r\n    minEle = arr[0] \r\n    maxEle = arr[0] \r\n    for i in range(1, n): \r\n        minEle = min(minEle,arr[i]) \r\n        maxEle = max(maxEle,arr[i]) \r\n    return (maxEle - minEle) ",
        "sampled": "def max_Abs_Diff(arr, n):\n    \"\"\"\n    This function takes an array and its length as input and returns the maximum absolute difference between any two elements in the array.\n    \"\"\"\n    max_diff = 0\n    for i in range(n):\n        for j in range(i+1, n):\n            diff = abs(arr[i] - arr[j])\n            if diff > max_diff:\n                max_diff = diff\n    return max_diff\n# Test cases\nassert max_Abs_Diff((2,1,5,3),4) == 4"
    },
    {
        "original": "def ascii_value_string(str1):\r\n  for i in range(len(str1)):\r\n   return ord(str1[i])",
        "sampled": "def ascii_value_string(string):\n    total_ascii = 0\n    for char in string:\n        total_ascii += ord(char)\n    return total_ascii"
    },
    {
        "original": "def max_path_sum(tri, m, n): \r\n\tfor i in range(m-1, -1, -1): \r\n\t\tfor j in range(i+1): \r\n\t\t\tif (tri[i+1][j] > tri[i+1][j+1]): \r\n\t\t\t\ttri[i][j] += tri[i+1][j] \r\n\t\t\telse: \r\n\t\t\t\ttri[i][j] += tri[i+1][j+1] \r\n\treturn tri[0][0]",
        "sampled": "def max_path_sum(triangle, row, col):\n    if row == len(triangle) - 1:\n        return triangle[row][col]\n    return max(triangle[row][col], triangle[row][col] + max_path_sum(triangle, row + 1, col))\n# Test cases\nassert max_path_sum([[1, 0, 0], [4, 8, 0], [1, 5, 3]], 2, 2) == 14\nassert max_path_sum([[13, 0"
    },
    {
        "original": "def sum_digits_single(x) : \r\n    ans = 0\r\n    while x : \r\n        ans += x % 10\r\n        x //= 10  \r\n    return ans \r\ndef closest(x) : \r\n    ans = 0\r\n    while (ans * 10 + 9 <= x) : \r\n        ans = ans * 10 + 9  \r\n    return ans   \r\ndef sum_digits_twoparts(N) : \r\n    A = closest(N)  \r\n    return sum_digits_single(A) + sum_digits_single(N - A) ",
        "sampled": "def sum_digits_twoparts(n):\n    # convert the number to a string\n    num_str = str(n)\n    # initialize the maximum sum and the two parts\n    max_sum = 0\n    part1 = 0\n    part2 = 0\n    # loop through the digits of the number\n    for digit in num_str:\n        # convert the digit to an integer\n        digit_int = int(digit)\n        # add the digit to the current part\n        part1 += digit_int\n        # check if the sum of digits is greater than the maximum sum\n        if part1 > max"
    },
    {
        "original": "def longest_subseq_with_diff_one(arr, n): \r\n\tdp = [1 for i in range(n)] \r\n\tfor i in range(n): \r\n\t\tfor j in range(i): \r\n\t\t\tif ((arr[i] == arr[j]+1) or (arr[i] == arr[j]-1)): \r\n\t\t\t\tdp[i] = max(dp[i], dp[j]+1) \r\n\tresult = 1\r\n\tfor i in range(n): \r\n\t\tif (result < dp[i]): \r\n\t\t\tresult = dp[i] \r\n\treturn result",
        "sampled": "def longest_subseq_with_diff_one(arr, target):\n    if len(arr) < 2:\n        return 0\n    = [0] * len(arr)\n   [0] = 1\n    for i in range(1, len(arr)):\n        for j in range(i):\n            if arr[i] - arr[j] == 1:\n                if j == 0 or[j - 1] == 1:\n                    if i == len(arr) - 1 or[i] == 1:\n                        if i == len"
    },
    {
        "original": "def does_Contain_B(a,b,c): \r\n    if (a == b): \r\n        return True\r\n    if ((b - a) * c > 0 and (b - a) % c == 0): \r\n        return True\r\n    return False",
        "sampled": "The function should take three arguments: the first argument is the starting number, the second argument is the ending number, and the third argument is the number to be searched for. The function should return True if the number is present in the infinite sequence, and False otherwise.\nThe infinite sequence is defined as:\nn = a + b * n\nwhere a and b are the given constants, and n is the current number in the sequence.\nFor example, if a = 1 and b = 2, then the sequence would be:\n1\n3\n5\n7\n9\n1"
    },
    {
        "original": "def gcd(p,q):\r\n    while q != 0:\r\n        p, q = q,p%q\r\n    return p\r\ndef is_coprime(x,y):\r\n    return gcd(x,y) == 1",
        "sampled": "def is_coprime(a, b):\n    \"\"\"\n    Returns True if a and b are co-prime, False otherwise.\n    \"\"\"\n    if a < b:\n        a, b = b, a\n    for i in range(2, b):\n        if a % i == 0 and b % i == 0:\n            return False\n    return True\n# Test cases\nassert is_coprime(17,13) == True\nassert is_coprime(15,21) == False\nassert is_coprime(25,45) == False"
    },
    {
        "original": "def merge(a,b):\r\n    c = []\r\n    while len(a) != 0 and len(b) != 0:\r\n        if a[0] < b[0]:\r\n            c.append(a[0])\r\n            a.remove(a[0])\r\n        else:\r\n            c.append(b[0])\r\n            b.remove(b[0])\r\n    if len(a) == 0:\r\n        c += b\r\n    else:\r\n        c += a\r\n    return c\r\ndef merge_sort(x):\r\n    if len(x) == 0 or len(x) == 1:\r\n        return x\r\n    else:\r\n        middle = len(x)//2\r\n        a = merge_sort(x[:middle])\r\n        b = merge_sort(x[middle:])\r\n        return merge(a,b)\r\n",
        "sampled": "def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    mid = len(arr) // 2\n    left = arr[:mid]\n    right = arr[mid:]\n    left = merge_sort(left)\n    right = merge_sort(right)\n    return merge(left, right)\ndef merge(left, right):\n    result = []\n    i = j = 0\n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i"
    },
    {
        "original": "def parabola_vertex(a, b, c): \r\n  vertex=(((-b / (2 * a)),(((4 * a * c) - (b * b)) / (4 * a))))\r\n  return vertex",
        "sampled": "def parabola_vertex(a, b, c):\n    # calculate the discriminant\n    discriminant = b**2 - 4*a*c\n    # check if the discriminant is negative\n    if discriminant < 0:\n        return None\n    # calculate the roots\n    root1 = (-b + discriminant**0.5)/(2*a)\n    root2 = (-b - discriminant**0.5)/(2*a)\n    # sort the roots in ascending order\n    roots = sorted([root1, root2])\n    # return the vertex\n    return roots"
    },
    {
        "original": "def specified_element(nums, N):\r\n    result = [i[N] for i in nums]\r\n    return result",
        "sampled": "Here's the function you can use:\ndef specified_element(lst, index):\n    return [lst[i][index] for i in range(len(lst))]\nYou can test your function with the provided tests."
    },
    {
        "original": "def even_bit_toggle_number(n) : \r\n    res = 0; count = 0; temp = n \r\n    while (temp > 0) :     \r\n        if (count % 2 == 1) : \r\n            res = res | (1 << count)      \r\n        count = count + 1\r\n        temp >>= 1 \r\n    return n ^ res ",
        "sampled": "The function should take an integer as input and return the integer with all even bits toggled.\nFor example, if the input is 10, the output should be 0, since all even bits are already zero. If the input is 20, the output should be 30, since the even bits are now 1 and 3. If the input is 30, the output should be 20, since the even bits are now 0 and 2."
    },
    {
        "original": "def tuple_int_str(tuple_str):\r\n    result = tuple((int(x[0]), int(x[1])) for x in tuple_str)\r\n    return result",
        "sampled": "def tuple_int_str(tup):\n    return tuple(map(lambda x: (int(x[0]), int(x[1])), tup))\n# Test cases\nassert tuple_int_str((('333', '33'), ('1416', '55')))==((333, 33), (1416, 55))\nassert tuple_int_str((('999', '99'), ('1000', '500')))==((999, 99), (100"
    },
    {
        "original": "from itertools import groupby\r\ndef encode_list(list1):\r\n    return [[len(list(group)), key] for key, group in groupby(list1)]",
        "sampled": "def encode_list(lst):\n    \"\"\"\n    Takes a list of elements and returns a list of lists representing the run-length encoding.\n    \"\"\"\n    # Initialize an empty list to store the encoded list\n    encoded_lst = []\n    # Iterate through the list\n    for i in range(len(lst)):\n        # If the current element is the same as the next element, increment the count\n        if i+1 < len(lst) and lst[i] == lst[i+1]:\n            lst[i] += 1\n        # If the current element is different from the next element, add the current element"
    },
    {
        "original": "def min_Ops(arr,n,k): \r\n    max1 = max(arr) \r\n    res = 0\r\n    for i in range(0,n):  \r\n        if ((max1 - arr[i]) % k != 0): \r\n            return -1 \r\n        else: \r\n            res += (max1 - arr[i]) / k \r\n    return int(res) ",
        "sampled": " */\n        def min_Ops(arr, k, n):\n            = {}\n            for i in range(n):\n                if arr[i] not in:\n                   [arr[i]] = 1\n                else:\n                    if k == 0:\n                        return -1\n                    else:\n                        k -= 1\n            return k\n        # Test cases\n        assert min_Ops([2, 2, 2, 2], 4, 3) == 0\n        assert min_Ops([4, 2, 6, 8], 4, 3) == -1\n        assert"
    },
    {
        "original": "def month_season(month,days):\r\n if month in ('January', 'February', 'March'):\r\n\t season = 'winter'\r\n elif month in ('April', 'May', 'June'):\r\n\t season = 'spring'\r\n elif month in ('July', 'August', 'September'):\r\n\t season = 'summer'\r\n else:\r\n\t season = 'autumn'\r\n if (month == 'March') and (days > 19):\r\n\t season = 'spring'\r\n elif (month == 'June') and (days > 20):\r\n\t season = 'summer'\r\n elif (month == 'September') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'October') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'November') and (days > 21):\r\n\t season = 'autumn'\r\n elif (month == 'December') and (days > 20):\r\n\t season = 'winter'\r\n return season",
        "sampled": "def month_season(month,day):\n    if month in ['January','March','May','July','August','October','December']:\n        if day <= 15:\n            return'spring'\n        elif day <= 31:\n            return'summer'\n        else:\n            return 'autumn'\n    else:\n        return 'winter'\n# Test cases\nassert month_season('January',4)==('spring')\nassert month_season('October',28)==('autumn')\nassert month_season('June',6)==('spring')"
    },
    {
        "original": "def solution (a, b, n): \r\n\ti = 0\r\n\twhile i * a <= n: \r\n\t\tif (n - (i * a)) % b == 0: \r\n\t\t\treturn (\"x = \",i ,\", y = \", \r\n\t\t\tint((n - (i * a)) / b)) \r\n\t\t\treturn 0\r\n\t\ti = i + 1\r\n\treturn (\"No solution\") ",
        "sampled": "def solution(a, b, n):\n    if a == 0:\n        return 'No solution'\n    x = (-b + (b**2 - 4*a*n) ** 0.5) / (2*a)\n    y = (-b - (b**2 - 4*a*n) ** 0.5) / (2*a)\n    return f'x = {x:.2f}, y = {y:.2f}'\n# Test cases\nassert solution(2, 3, 7) == ('x = ', 2."
    },
    {
        "original": "def remove_elements(list1, list2):\r\n    result = [x for x in list1 if x not in list2]\r\n    return result",
        "sampled": "def remove_elements(lst1, lst2):\n    return [x for x in lst1 if x not in lst2]\n# Test cases\nprint(remove_elements([1,2,3,4,5,6,7,8,9,10],[2,4,6,8])) #[1, 3, 5, 7, 9, 10]\nprint(remove_elements([1, 2, 3, 4, 5, 6, 7, 8, 9, 10],[1, "
    },
    {
        "original": "def sum_series(n):\r\n  if n < 1:\r\n    return 0\r\n  else:\r\n    return n + sum_series(n - 2)",
        "sampled": "def sum_series(n):\n    if n == 1:\n        return 1\n    else:\n        return n + sum_series(n-1)\n# Test cases\nassert sum_series(6) == 12\nassert sum_series(10) == 30\nassert sum_series(9) == 25"
    },
    {
        "original": "from math import tan, pi\r\ndef area_polygon(s,l):\r\n  area = s * (l ** 2) / (4 * tan(pi / s))\r\n  return area",
        "sampled": "The function should take two arguments:ts, which is the number of sides of the polygon, andr, which is the radius of the polygon. The function should return the area of the polygon as a float.\nTheion of the is to implement the formula for the area of a regular polygon using the formula:\nArea = (pi * r^2) / (2 *)\nwhere pi is the mathematical constant pi, r is the radius of the polygon, and is the number of sides of the polygon.\nThe is the parameter, which is"
    },
    {
        "original": "import math \r\ndef divSum(n): \r\n    sum = 1; \r\n    i = 2; \r\n    while(i * i <= n): \r\n        if (n % i == 0): \r\n            sum = (sum + i +math.floor(n / i)); \r\n        i += 1; \r\n    return sum; \r\ndef areEquivalent(num1,num2): \r\n    return divSum(num1) == divSum(num2); ",
        "sampled": "def areEquivalent(num1, num2):\n    \"\"\"\n    This function takes two integers as input and returns True if the sum of their divisors are same, else False.\n    \"\"\"\n    # Finding the set of divisors of num1\n    div1 = set(set(range(1, num1+1)) - set(range(1, num1//2+1)))\n    # Finding the set of divisors of num2\n    div2 = set(set(range(1, num2+1)) - set(range(1, num2//2+1)))"
    },
    {
        "original": "def count_char_position(str1): \r\n    count_chars = 0\r\n    for i in range(len(str1)):\r\n        if ((i == ord(str1[i]) - ord('A')) or \r\n            (i == ord(str1[i]) - ord('a'))): \r\n            count_chars += 1\r\n    return count_chars ",
        "sampled": ""
    },
    {
        "original": "def find_even_Pair(A,N): \r\n    evenPair = 0\r\n    for i in range(0,N): \r\n        for j in range(i+1,N): \r\n            if ((A[i] ^ A[j]) % 2 == 0): \r\n                evenPair+=1\r\n    return evenPair; ",
        "sampled": "def find_even_Pair(arr, xor):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[i] ^ arr[j] == xor and arr[i] % 2 == 0:\n                count += 1\n    return count\n# Test cases\nassert find_even_Pair([5,4,7,2,1],5) == 4\nassert find_even_Pair([7,2,8,1,0,5,11],7) =="
    },
    {
        "original": "def next_Power_Of_2(n): \r\n    count = 0; \r\n    if (n and not(n & (n - 1))): \r\n        return n   \r\n    while( n != 0): \r\n        n >>= 1\r\n        count += 1\r\n    return 1 << count; ",
        "sampled": ""
    },
    {
        "original": "def frequency(a,x): \r\n    count = 0  \r\n    for i in a: \r\n        if i == x: count += 1\r\n    return count ",
        "sampled": "def frequency(arr, num):\n    count = 0\n    for i in arr:\n        if i == num:\n            count += 1\n    return count\n# Test cases\nassert frequency([1,2,3],4) == 0\nassert frequency([1,2,2,3,3,3,4],3) == 3\nassert frequency([0,1,2,3,1,2],1) == 2"
    },
    {
        "original": "def get_pell(n): \r\n\tif (n <= 2): \r\n\t\treturn n \r\n\ta = 1\r\n\tb = 2\r\n\tfor i in range(3, n+1): \r\n\t\tc = 2 * b + a \r\n\t\ta = b \r\n\t\tb = c \r\n\treturn b ",
        "sampled": "def get_pell(n):\n    \"\"\"\n    Returns the nth pell number.\n    \"\"\"\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 4\n    else:\n        return 4 * (n - 1) + 1\n# Test cases\nassert get_pell(4) == 12\nassert get_pell(7) == 169\nassert get_pell(8) == 408"
    },
    {
        "original": "def sum_range_list(list1, m, n):                                                                                                                                                                                                \r\n    sum_range = 0                                                                                                                                                                                                         \r\n    for i in range(m, n+1, 1):                                                                                                                                                                                        \r\n        sum_range += list1[i]                                                                                                                                                                                                  \r\n    return sum_range   ",
        "sampled": "def sum_range_list(lst, start, end):\n    \"\"\"\n    This function takes a list, a start index, and an end index as input and returns the sum of the numbers in the list between the start and end indices.\n    \"\"\"\n    return sum(lst[start:end+1])\n# Test cases\nassert sum_range_list( [2,1,5,6,8,3,4,9,10,11,8,12],8,10)==29\nassert sum_range_list( [2,1,5,6"
    },
    {
        "original": "import math\r\ndef perimeter_pentagon(a):\r\n  perimeter=(5*a)\r\n  return perimeter",
        "sampled": "def perimeter_pentagon(n):\n    \"\"\"\n    Returns the perimeter of a pentagon with n sides.\n    \"\"\"\n    return 5*n**2\n# Test cases\nassert perimeter_pentagon(5)==25\nassert perimeter_pentagon(10)==50\nassert perimeter_pentagon(15)==75"
    },
    {
        "original": "def count_occurance(s):\r\n  count=0\r\n  for i in range(len(s)):\r\n    if (s[i]== 's' and s[i+1]=='t' and s[i+2]== 'd'):\r\n      count = count + 1\r\n  return count",
        "sampled": "def count_occurance(string):\n    count = 0\n    for char in string:\n        if char =='s':\n            count += 1\n    return count\n# Test cases\nassert count_occurance(\"letstdlenstdporstd\") == 3\nassert count_occurance(\"truststdsolensporsd\") == 1\nassert count_occurance(\"makestdsostdworthit\") == 2"
    },
    {
        "original": "import re\r\ndef remove_splchar(text): \r\n pattern = re.compile('[\\W_]+')\r\n return (pattern.sub('', text))",
        "sampled": "Note: The function should not modify the original string."
    },
    {
        "original": "def group_keyvalue(l):\r\n    result = {}\r\n    for k, v in l:\r\n         result.setdefault(k, []).append(v)\r\n    return result",
        "sampled": "def group_keyvalue(seq):\n    \"\"\"\n    Group a sequence of key-value pairs into a dictionary of lists.\n    \"\"\"\n    # Initialize an empty dictionary\n    result = {}\n    # Iterate over the sequence of key-value pairs\n    for key, value in seq:\n        # If the key is already in the dictionary, append the value to the list\n        if key in result:\n            result[key].append(value)\n        # Otherwise, create a new list with the value and add it to the dictionary\n        else:\n            result[key] = [value]\n    return result\n# Test the function with"
    },
    {
        "original": "def is_valid_parenthese( str1):\r\n        stack, pchar = [], {\"(\": \")\", \"{\": \"}\", \"[\": \"]\"}\r\n        for parenthese in str1:\r\n            if parenthese in pchar:\r\n                stack.append(parenthese)\r\n            elif len(stack) == 0 or pchar[stack.pop()] != parenthese:\r\n                return False\r\n        return len(stack) == 0",
        "sampled": "def is_valid_parenthese(s):\n    stack = []\n    for p in s:\n        if p in ['(', '[', '{']:\n            stack.append(p)\n        elif p in [')', ']', '}']:\n            if not stack:\n                return False\n            if p == ')' and stack[-1]!= '(':\n                return False\n            if p == ']' and stack[-1]!= '[':\n                return False\n            if p == '}' and stack[-1]!= '{':\n                return False\n            stack.pop()\n    return not stack\n# Test cases\nassert is_valid_"
    },
    {
        "original": "def perimeter_triangle(a,b,c):\r\n  perimeter=a+b+c\r\n  return perimeter",
        "sampled": "def perimeter_triangle(a,b,c):\n    s = (a+b+c)/2\n    return 2*s"
    },
    {
        "original": "def answer(L,R): \r\n    if (2 * L <= R): \r\n        return (L ,2*L)\r\n    else: \r\n        return (-1) ",
        "sampled": "def find_two_distinct_numbers(range_start, range_end):\n    # Write your code here\n    pass\n# Test cases\nassert find_two_distinct_numbers(3,8) == (3,6)\nassert find_two_distinct_numbers(2,6) == (2,4)\nassert find_two_distinct_numbers(1,3) == (1,2)"
    },
    {
        "original": "import re\r\ndef string_literals(patterns,text):\r\n  for pattern in patterns:\r\n     if re.search(pattern,  text):\r\n       return ('Matched!')\r\n     else:\r\n       return ('Not Matched!')",
        "sampled": "def string_literals(literals,string):\n    for literal in literals:\n        if literal in string:\n            return 'Matched!'\n    return 'Not Matched!'"
    },
    {
        "original": "def is_num_keith(x): \r\n\tterms = [] \r\n\ttemp = x \r\n\tn = 0 \r\n\twhile (temp > 0): \r\n\t\tterms.append(temp % 10) \r\n\t\ttemp = int(temp / 10) \r\n\t\tn+=1 \r\n\tterms.reverse() \r\n\tnext_term = 0 \r\n\ti = n \r\n\twhile (next_term < x): \r\n\t\tnext_term = 0 \r\n\t\tfor j in range(1,n+1): \r\n\t\t\tnext_term += terms[i - j] \r\n\t\tterms.append(next_term) \r\n\t\ti+=1 \r\n\treturn (next_term == x) ",
        "sampled": ""
    },
    {
        "original": "from math import radians, sin, cos, acos\r\ndef distance_lat_long(slat,slon,elat,elon):\r\n dist = 6371.01 * acos(sin(slat)*sin(elat) + cos(slat)*cos(elat)*cos(slon - elon))\r\n return dist",
        "sampled": "The function should take four parameters:_lat, ver_long, dest_lat, dest_long. The function should return the distance between the two points in kilometers.\nTo calculate the distance between two points, you can use the Haversine formula:\ndistance = 6371 * acos(cos(lat1) * cos(lat2) * cos(lon2 - lon1))\nwhere lat1, lon1, lat2, and lon2 are the latitude and longitude of the two points, respectively.\nTo convert degrees to radians, you can"
    },
    {
        "original": "def common_prefix_util(str1, str2): \r\n\tresult = \"\"; \r\n\tn1 = len(str1) \r\n\tn2 = len(str2) \r\n\ti = 0\r\n\tj = 0\r\n\twhile i <= n1 - 1 and j <= n2 - 1: \r\n\t\tif (str1[i] != str2[j]): \r\n\t\t\tbreak\r\n\t\tresult += str1[i] \r\n\t\ti += 1\r\n\t\tj += 1\r\n\treturn (result) \r\ndef common_prefix (arr, n): \r\n\tprefix = arr[0] \r\n\tfor i in range (1, n): \r\n\t\tprefix = common_prefix_util(prefix, arr[i]) \r\n\treturn (prefix) ",
        "sampled": "def common_prefix(strs, n):\n    \"\"\"\n    Given a set of strings, find the longest common prefix of length n.\n    Args:\n        strs (list): A list of strings.\n        n (int): The length of the common prefix to find.\n    Returns:\n        str: The longest common prefix of length n.\n    \"\"\"\n    # Initialize the longest common prefix to an empty string\n    prefix = \"\"\n    # Iterate through the strings and find the longest common prefix of length n\n    for i in range(len(strs[0]) - n + 1):\n        # Check if the current prefix is"
    },
    {
        "original": "import re\r\ndef find_character(string):\r\n  uppercase_characters = re.findall(r\"[A-Z]\", string) \r\n  lowercase_characters = re.findall(r\"[a-z]\", string) \r\n  numerical_characters = re.findall(r\"[0-9]\", string) \r\n  special_characters = re.findall(r\"[, .!?]\", string) \r\n  return uppercase_characters, lowercase_characters, numerical_characters, special_characters",
        "sampled": "def find_character(string):\n    # Define regex patterns for uppercase, lowercase, special character and numeric values\n    uppercase_pattern = r'[A-Z]'\n    lowercase_pattern = r'[a-z]'\n    special_pattern = r'[!@#$%^&*()_+\\-=\\[\\]{};':\"\\\\|,.<>\\/?]'\n    numeric_pattern = r'\\d'\n    # Find uppercase, lowercase, special character and numeric values using regex\n    uppercase_values = re.findall(uppercase_pattern, string)\n    lowercase_values = re.findall(lowercase_pattern, string)"
    },
    {
        "original": "def count_pairs(arr, n, k):\r\n  count=0;\r\n  for i in range(0,n):\r\n    for j in range(i+1, n):\r\n      if arr[i] - arr[j] == k or arr[j] - arr[i] == k:\r\n        count += 1\r\n  return count",
        "sampled": "def count_pairs(arr, k, n):\n    count = 0\n    for i in range(len(arr)):\n        for j in range(i+1, len(arr)):\n            if arr[j] - arr[i] == k:\n                count += 1\n    return count\n# Test cases\nassert count_pairs([1, 5, 3, 4, 2], 5, 3) == 2\nassert count_pairs([8, 12, 16, 4, 0, 20], 6, 4"
    },
    {
        "original": "def greater_specificnum(list,num):\r\n greater_specificnum=all(x >= num for x in list)\r\n return greater_specificnum",
        "sampled": " */\n        def greater_specificnum(lst, num):\n            return any(x > num for x in lst)\n        assert greater_specificnum([220, 330, 500], 200) == True\n        assert greater_specificnum([12, 17, 21], 20) == False\n        assert greater_specificnum([1, 2, 3, 4], 10) == False"
    },
    {
        "original": "def parabola_focus(a, b, c): \r\n  focus= (((-b / (2 * a)),(((4 * a * c) - (b * b) + 1) / (4 * a))))\r\n  return focus",
        "sampled": " {output}The function `parabola_focus` takes three parameters: `a`, `b`, and `c`. The equation of a parabola is `y = ax^2 + bx + c`, where `a`, `b`, and `c` are the coefficients of the equation. The focus of the parabola is the point where the slope of the parabola is zero. The function should return a tuple containing the x-coordinate and y-coordinate of the focus point.\nTo find the focus of a parabola, we can use the quadratic formula:\n`x"
    },
    {
        "original": "import re\r\ndef check_literals(text, patterns):\r\n  for pattern in patterns:\r\n    if re.search(pattern,  text):\r\n        return ('Matched!')\r\n    else:\r\n        return ('Not Matched!')",
        "sampled": "def check_literals(string, literals):\n    pattern = '|'.join(literals)\n    if re.search(pattern, string):\n        return 'Matched!'\n    else:\n        return 'Not Matched!'\n# Test cases\nassert check_literals('The quick brown fox jumps over the lazy dog.',['fox']) == 'Matched!'\nassert check_literals('The quick brown fox jumps over the lazy dog.',['horse']) == 'Not Matched!'\nassert check_literals('The quick brown fox jumps over the lazy dog.',['lazy']) == 'Matched!'"
    },
    {
        "original": "def longest_common_subsequence(X, Y, m, n): \r\n    if m == 0 or n == 0: \r\n       return 0 \r\n    elif X[m-1] == Y[n-1]: \r\n       return 1 + longest_common_subsequence(X, Y, m-1, n-1) \r\n    else: \r\n       return max(longest_common_subsequence(X, Y, m, n-1), longest_common_subsequence(X, Y, m-1, n))",
        "sampled": "def longest_common_subsequence(s1, s2, m, n):\n    # create a 2D table to store the lengths of LCS for all prefixes of s1 and s2\n    table = [[0] * (n + 1) for _ in range(m + 1)]\n    # fill the table in bottom-up manner\n    for i in range(1, m + 1):\n        for j in range(1, n + 1):\n            if s1[i - 1] == s2[j - 1]:\n                table[i][j]"
    },
    {
        "original": "def prod_Square(n):\r\n    for i in range(2,(n) + 1):\r\n        if (i*i < (n+1)):\r\n            for j in range(2,n + 1):\r\n                if ((i*i*j*j) == n):\r\n                    return True;\r\n    return False;",
        "sampled": "def prod_Square(num):\n    if num < 0:\n        return False\n    for i in range(2, int(num**0.5)+1):\n        if num % i == 0:\n            if (num//i)**2 == i:\n                return True\n            elif (num//i)**2 == num//i:\n                return False\n    return False\n# Test cases\nassert prod_Square(25) == False\nassert prod_Square(30) == False\nassert prod_Square(16) == True"
    },
    {
        "original": "def first_Missing_Positive(arr,n): \r\n    ptr = 0\r\n    for i in range(n):\r\n        if arr[i] == 1:\r\n            ptr = 1\r\n            break\r\n    if ptr == 0:\r\n        return(1)\r\n    for i in range(n):\r\n        if arr[i] <= 0 or arr[i] > n:\r\n            arr[i] = 1\r\n    for i in range(n):\r\n        arr[(arr[i] - 1) % n] += n\r\n    for i in range(n):\r\n        if arr[i] <= n:\r\n            return(i + 1)\r\n    return(n + 1)",
        "sampled": "def first_Missing_Positive(nums, n):\n    # create a list of numbers from 1 to n\n    nums_list = list(range(1, n+1))\n    # iterate through the list and find the missing positive numbers\n    for num in nums:\n        # if the number is greater than n, it means it is already in the list\n        if num > n:\n            continue\n        # if the number is less than or equal to 0, it means it is not in the list\n        if num <= 0:\n            # find the next missing positive number\n            next_missing_positive = find"
    },
    {
        "original": "def count_Intgral_Points(x1,y1,x2,y2): \r\n    return ((y2 - y1 - 1) * (x2 - x1 - 1)) ",
        "sampled": "def count_Intgral_Points(x1,y1,x2,y2):\n    # check if the coordinates are valid\n    if x1 > x2 or y1 > y2:\n        return 0\n    # count the number of integral points\n    count = 0\n    for i in range(x1,x2+1):\n        for j in range(y1,y2+1):\n            if i == x1 or i == x2 or j == y1 or j == y2:\n                count += 1\n    return count\n# Test cases\nassert count_"
    },
    {
        "original": "def check_monthnumber(monthname3):\r\n  if monthname3 ==\"April\" or monthname3== \"June\" or monthname3== \"September\" or monthname3== \"November\":\r\n    return True\r\n  else:\r\n    return False",
        "sampled": "def check_monthnumber(month):\n    if month in [\"January\", \"March\", \"May\", \"July\", \"August\", \"October\", \"December\"]:\n        return False\n    elif month in [\"April\", \"June\", \"September\", \"November\"]:\n        return True\n    else:\n        raise ValueError(\"Invalid month name\")\n# Test cases\nassert check_monthnumber(\"February\")==False\nassert check_monthnumber(\"June\")==True\nassert check_monthnumber(\"April\")==True"
    },
    {
        "original": "def check_String(str): \r\n    flag_l = False\r\n    flag_n = False\r\n    for i in str: \r\n        if i.isalpha(): \r\n            flag_l = True  \r\n        if i.isdigit(): \r\n            flag_n = True\r\n    return flag_l and flag_n ",
        "sampled": ""
    },
    {
        "original": "def remove_tuple(test_tup):\r\n  res = tuple(set(test_tup))\r\n  return (res) ",
        "sampled": "def remove_tuple(tuple_):\n    return list(set(tuple_))\n# Test cases\nassert remove_tuple((1, 3, 5, 2, 3, 5, 1, 1, 3)) == (1, 2, 3, 5)\nassert remove_tuple((2, 3, 4, 4, 5, 6, 6, 7, 8, 8)) == (2, 3, 4, 5, 6, 7, 8)\nassert remove_"
    },
    {
        "original": "def octal_To_Decimal(n):  \r\n    num = n; \r\n    dec_value = 0; \r\n    base = 1; \r\n    temp = num; \r\n    while (temp): \r\n        last_digit = temp % 10; \r\n        temp = int(temp / 10); \r\n        dec_value += last_digit*base; \r\n        base = base * 8; \r\n    return dec_value; ",
        "sampled": "def octal_To_Decimal(octal_num):\n    decimal_num = 0\n    for digit in octal_num:\n        decimal_num = decimal_num * 8 + int(digit)\n    return decimal_num"
    },
    {
        "original": "def first(arr,x,n): \r\n    low = 0\r\n    high = n - 1\r\n    res = -1  \r\n    while (low <= high):\r\n        mid = (low + high) // 2 \r\n        if arr[mid] > x:\r\n            high = mid - 1\r\n        elif arr[mid] < x:\r\n            low = mid + 1\r\n        else:\r\n            res = mid\r\n            high = mid - 1\r\n    return res",
        "sampled": "def first(arr, target, n):\n    \"\"\"\n    Returns the index of the first occurrence of target in arr, or -1 if not found.\n    \"\"\"\n    # Initialize left and right pointers\n    left = 0\n    right = n - 1\n    # Initialize result variable\n    result = -1\n    # Iterate through the array\n    while left <= right:\n        # Calculate the midpoint\n        mid = (left + right) // 2\n        # If the target is found, update the result and update the pointers\n        if arr[mid] == target:\n            result = mid\n            left = mid + 1"
    },
    {
        "original": "def remove_tuples(test_list, K):\r\n  res = [ele for ele in test_list if len(ele) != K]\r\n  return (res) ",
        "sampled": "The function should take in two parameters: a list of tuples and an integer k. The function should return a new list with all the tuples with length k removed. If there are no tuples with length k, the function should return the original list.\nHere's the code for the function:\ndef remove_tuples(lst, k):\n    return [t for t in lst if len(t)!= k]\nYou can test the function with the provided tests:\nassert remove_tuples([(4, 5), (4, ), (8, 6, 7), (1,"
    },
    {
        "original": "def find_exponentio(test_tup1, test_tup2):\r\n  res = tuple(ele1 ** ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res)\r\n",
        "sampled": "The function should take two tuples as input and return a tuple containing the result of exponentiation of the two tuples. The exponentiation of two tuples is the product of the corresponding elements of the two tuples raised to the power of the corresponding elements of the second tuple.\nFor example, if we have two tuples (a, b, c, d) and (e, f, g, h), then the exponentiation of (a, b, c, d) and (e, f, g, h) is calculated as follows:\n(a^e) * (b^f) * (c"
    },
    {
        "original": "import math\r\ndef largest_triangle(a,b): \r\n    if (a < 0 or b < 0): \r\n        return -1 \r\n    area = (3 * math.sqrt(3) * pow(a, 2)) / (4 * b);  \r\n    return area ",
        "sampled": "The function should take two arguments: and x. The argument is thetopi the ellipse, and the x argument is thetopi thetopi thetopi thetopi thetopi thetopi thetopi thetopiheto thetopihetoheto thetopiheto thetopiheto thetopiheto thetopiheto thetopiheto thetopiheto thetopiheto thetopiheto"
    },
    {
        "original": "def highest_Power_of_2(n): \r\n    res = 0; \r\n    for i in range(n, 0, -1):  \r\n        if ((i & (i - 1)) == 0): \r\n            res = i; \r\n            break;      \r\n    return res; ",
        "sampled": "def highest_Power_of_2(n):\n    \"\"\"\n    This function takes an integer n as input and returns the highest power of 2 less than or equal to n.\n    \"\"\"\n    if n == 0:\n        return 0\n    else:\n        return 1 << (31 - n.bit_length())"
    },
    {
        "original": "def position_max(list1):\r\n    max_val = max(list1)\r\n    max_result = [i for i, j in enumerate(list1) if j == max_val]\r\n    return max_result",
        "sampled": "def position_max(lst):\n    max_val = lst[0]\n    max_pos = [0]\n    for i in range(1,len(lst)):\n        if lst[i] > max_val:\n            max_val = lst[i]\n            max_pos = [i]\n        elif lst[i] == max_val:\n            max_pos.append(i)\n    return max_pos\n# Test cases\nassert position_max([12,33,23,10,67,89,45,667,23"
    },
    {
        "original": "def chkList(lst): \r\n    return len(set(lst)) == 1",
        "sampled": "def chkList(lst):\n    if len(lst) == 0:\n        return True\n    elif lst[0] == lst[1]:\n        return chkList(lst[1:])\n    else:\n        return False\n# Test cases\nassert chkList(['one','one','one']) == True\nassert chkList(['one','Two','Three']) == False\nassert chkList(['bigdata','python','Django']) == False"
    },
    {
        "original": "def remove_even(str1):\r\n str2 = ''\r\n for i in range(1, len(str1) + 1):\r\n    if(i % 2 != 0):\r\n        str2 = str2 + str1[i - 1]\r\n return str2",
        "sampled": "def remove_even(s):\n    return ''.join(c for c in s if c % 2!= 0)\n# Test cases\nassert remove_even(\"python\")==(\"pto\")\nassert remove_even(\"program\")==(\"porm\")\nassert remove_even(\"language\")==(\"lnug\")"
    },
    {
        "original": "def hamming_Distance(n1,n2) : \r\n    x = n1 ^ n2  \r\n    setBits = 0\r\n    while (x > 0) : \r\n        setBits += x & 1\r\n        x >>= 1\r\n    return setBits  ",
        "sampled": "def hamming_Distance(a, b):\n    # Convert the integers to binary strings\n    a_binary = bin(a)[2:]\n    b_binary = bin(b)[2:]\n    # Pad the binary strings with zeros to the same length\n    max_length = max(len(a_binary), len(b_binary))\n    a_binary = a_binary.zfill(max_length)\n    b_binary = b_binary.zfill(max_length)\n    # Calculate the Hamming distance\n    distance = 0\n    for i in range(max_length):"
    },
    {
        "original": "def count(s,c) : \r\n    res = 0 \r\n    for i in range(len(s)) : \r\n        if (s[i] == c): \r\n            res = res + 1\r\n    return res ",
        "sampled": "def count(string, char):\n    count = 0\n    for i in range(len(string)):\n        if string[i] == char:\n            count += 1\n    return count\n# Test cases\nassert count(\"abcc\",\"c\") == 2\nassert count(\"ababca\",\"a\") == 3\nassert count(\"mnmm0pm\",\"m\") == 4"
    },
    {
        "original": "def inversion_elements(test_tup):\r\n  res = tuple(list(map(lambda x: ~x, list(test_tup))))\r\n  return (res) ",
        "sampled": "The function should take a tuple list as input and return a tuple containing the inversions of the tuple elements. The inversion of two elements (a, b) and (c, d) is the number of elements in the list that are smaller than either of the elements (a, b) or (c, d), respectively.\nFor example, inversion_elements((7, 8, 9, 1, 10, 7)) should return (-8, -9, -10, -2, -11, -8). The inversion of (7, 8"
    },
    {
        "original": "def concatenate_elements(test_tup):\r\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\r\n  return (res) ",
        "sampled": "def concatenate_elements(tuples):\n    concatenated_elements = []\n    for i in range(len(tuples)):\n        concatenated_elements.append(tuples[i][0])\n        for j in range(i+1, len(tuples)):\n            concatenated_elements.append(tuples[j][0])\n    return concatenated_elements\n# Test cases\nassert concatenate_elements((\"DSP \", \"IS \", \"BEST \", \"FOR \", \"ALL \", \"UTS\")) == ('DSP IS ', 'IS BEST ', 'BEST FOR ', 'FOR ALL ', 'ALL UTS')\nassert concatenate"
    },
    {
        "original": "def find_longest_repeating_subseq(str): \r\n\tn = len(str) \r\n\tdp = [[0 for k in range(n+1)] for l in range(n+1)] \r\n\tfor i in range(1, n+1): \r\n\t\tfor j in range(1, n+1): \r\n\t\t\tif (str[i-1] == str[j-1] and i != j): \r\n\t\t\t\tdp[i][j] = 1 + dp[i-1][j-1] \r\n\t\t\telse: \r\n\t\t\t\tdp[i][j] = max(dp[i][j-1], dp[i-1][j]) \r\n\treturn dp[n][n]",
        "sampled": "def find_longest_repeating_subseq(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    max_len = 0\n    for i in range(n):\n        for j in range(i, n):\n            if s[i] == s[j]:\n                dp[i][j] = 1 + dp[i+1][j-1]\n                max_len = max(max_len, dp[i][j])\n    return max_len\n# Test cases\nassert find_longest_repeating"
    },
    {
        "original": "import re\r\ndef is_decimal(num):\r\n  num_fetch = re.compile(r\"\"\"^[0-9]+(\\.[0-9]{1,2})?$\"\"\")\r\n  result = num_fetch.search(num)\r\n  return bool(result)",
        "sampled": "def is_decimal(decimal_str):\n    # Use regex to check if the decimal is a valid decimal with a precision of 2\n    pattern = r'^[-+]?\\d*\\.\\d{2}$'\n    return bool(re.match(pattern, decimal_str))\n# Test cases\nassert is_decimal('123.11') == True\nassert is_decimal('0.21') == True\nassert is_decimal('123.1214') == False"
    },
    {
        "original": "import heapq as hq\r\ndef heap_replace(heap,a):\r\n  hq.heapify(heap)\r\n  hq.heapreplace(heap, a)\r\n  return heap",
        "sampled": "def heap_replace(heap, new_item):\n    # Replace the smallest element with the new item\n    heap[0] = new_item\n    # Bubble down the new item to its correct position\n    n = len(heap)\n    i = 0\n    while i < n:\n        smallest = i\n        left = 2 * i + 1\n        right = 2 * i + 2\n        if left < n and heap[left] < heap[smallest]:\n            smallest = left\n        if right < n and heap[right] < heap[smallest]:\n            smallest = right\n        if smallest"
    },
    {
        "original": "import re\r\ndef is_allowed_specific_char(string):\r\n    get_char = re.compile(r'[^a-zA-Z0-9.]')\r\n    string = get_char.search(string)\r\n    return not bool(string)",
        "sampled": ""
    },
    {
        "original": "def count_Num(n): \r\n    if (n == 1): \r\n        return 1\r\n    count = pow(2,n - 2) \r\n    return count ",
        "sampled": "def count_Num(n):\n    count = 0\n    for i in range(1, n+1):\n        if (i & (i-1)) == 0 and (i & (i-2)) == 0:\n            count += 1\n    return count\n# Test cases\nassert count_Num(2) == 1\nassert count_Num(3) == 2\nassert count_Num(1) == 1"
    },
    {
        "original": "import math  \r\ndef fourth_Power_Sum(n): \r\n    sum = 0\r\n    for i in range(1,n+1) : \r\n        sum = sum + (i*i*i*i) \r\n    return sum",
        "sampled": "def fourth_Power_Sum(n):\n    return sum([i**4 for i in range(1, n+1)])\n# Test cases\nassert fourth_Power_Sum(2) == 17\nassert fourth_Power_Sum(4) == 354\nassert fourth_Power_Sum(6) == 2275"
    },
    {
        "original": "def concatenate_strings(test_tup1, test_tup2):\r\n  res = tuple(ele1 + ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ",
        "sampled": "# Here's the function to concatenate two string tuples:\ndef concatenate_strings(str1, str2):\n    return str1[0] +'' + str2[0] + ','+ str1[1] +'' + str2[1] + ','+ str1[2] +'' + str2[2]"
    },
    {
        "original": "import math\r\ndef degree_radian(radian):\r\n degree = radian*(180/math.pi)\r\n return degree",
        "sampled": "The function should take a single argument, the angle in radians, and return the angle in degrees. The formula for converting radians to degrees is:\ndegrees = angle * 180 / pi\nwhere pi is the mathematical constant pi.\nNote that the function should handle cases where the angle is negative or zero. In that case, the function should return 0."
    },
    {
        "original": "def decode_list(alist):\r\n    def aux(g):\r\n        if isinstance(g, list):\r\n            return [(g[1], range(g[0]))]\r\n        else:\r\n            return [(g, [0])]\r\n    return [x for g in alist for x, R in aux(g) for i in R]",
        "sampled": "def decode_list(lst):\n    result = []\n    for item in lst:\n        if isinstance(item, list):\n            result.extend(item)\n        else:\n            result.extend([item] * item)\n    return result\n# Test cases\nassert decode_list([[2, 1], 2, 3, [2, 4], 5,1])==[1,1,2,3,4,4,5,1]\nassert decode_list(['a', 'u', 't', 'o','m', 'a', 't', 'i"
    },
    {
        "original": "def check_subset_list(list1, list2): \r\n    l1, l2 = list1[0], list2[0] \r\n    exist = True\r\n    for i in list2: \r\n        if i not in list1: \r\n            exist = False\r\n    return exist ",
        "sampled": "def check_subset_list(list1, list2):\n    \"\"\"\n    Check if one nested list is a subset of another nested list.\n    \"\"\"\n    # Check if thest list is a subset of the second list\n    for item in list1:\n        if item not in list2:\n            return False\n    return True\n# Test cases\nassert check_subset_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14],[["
    },
    {
        "original": "def first_Repeated_Char(str): \r\n    h = {}\r\n    for ch in str:\r\n        if ch in h: \r\n            return ch;\r\n        else: \r\n            h[ch] = 0\r\n    return '\\0'",
        "sampled": "def first_Repeated_Char(str):\n    # Initialize a dictionary to store the frequency of each character in the string\n    freq = {}\n    for char in str:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    # Find the first repeated character\n    for char in freq:\n        if freq[char] > 1:\n            return char\n    # If no repeated character is found, return '\\0'\n    return '\\0'\n# Test cases\nassert first_Repeated_Char(\"Google\") == \"o\"\nassert first_Repeated"
    },
    {
        "original": "import math   \r\ndef min_Operations(A,B):  \r\n    if (A > B): \r\n        swap(A,B)  \r\n    B = B // math.gcd(A,B);  \r\n    return B - 1",
        "sampled": "def min_Operations(num1, num2):\n    # Initialize the variables\n    diff = num1 - num2\n    min_diff = abs(diff)\n    count = 0\n    # Loop through the absolute difference\n    while min_diff > 0:\n        # Increment the count by the number of times we can divide the absolute difference by 2\n        count += min_diff // 2\n        # Update the minimum difference by the remainder of the division\n        min_diff = abs(diff - count * 2)\n    # Return the count of operations\n    return count\n# Test cases\nassert min_"
    },
    {
        "original": "\r\ndef extract_min_max(test_tup, K):\r\n  res = []\r\n  test_tup = list(test_tup)\r\n  temp = sorted(test_tup)\r\n  for idx, val in enumerate(temp):\r\n    if idx < K or idx >= len(temp) - K:\r\n      res.append(val)\r\n  res = tuple(res)\r\n  return (res) ",
        "sampled": "def extract_min_max(arr, k):\n    \"\"\"\n    Returns a tuple containing the k smallest and largest elements in the given array.\n    \"\"\"\n    arr.sort()\n    return arr[:k], arr[-k:]\n# Test cases\nassert extract_min_max((5, 20, 3, 7, 6, 8), 2) == (3, 5, 8, 20)\nassert extract_min_max((4, 5, 6, 1, 2, 7), 3) == (1, "
    },
    {
        "original": "import re\r\ndef replace_max_specialchar(text,n):\r\n return (re.sub(\"[ ,.]\", \":\", text, n))",
        "sampled": ""
    },
    {
        "original": "def first_even(nums):\r\n    first_even = next((el for el in nums if el%2==0),-1)\r\n    return first_even",
        "sampled": "Here's the code for the function:\ndef first_even(numbers):\n    for num in numbers:\n        if num % 2 == 0:\n            return num\n    return None\n# Test cases\nassert first_even([1, 3, 5, 7, 4, 1, 6, 8]) == 4\nassert first_even([2, 3, 4]) == 2\nassert first_even([5, 6, 7]) == 6"
    },
    {
        "original": "def check_type(test_tuple):\r\n  res = True\r\n  for ele in test_tuple:\r\n    if not isinstance(ele, type(test_tuple[0])):\r\n      res = False\r\n      break\r\n  return (res) ",
        "sampled": "def check_type(t):\n    \"\"\"\n    This function takes a tuple as input and returns True if all the elements in the tuple have same data type, else False.\n    \"\"\"\n    # Get the first element of the tuple\n    first_element = t[0]\n    # Loop through the rest of the tuple\n    for element in t[1:]:\n        # If the element is not of the same data type as the first element, return False\n        if not isinstance(element, type(first_element)):\n            return False\n    # If all the elements are of the same data type, return True\n    return True"
    },
    {
        "original": "def is_majority(arr, n, x):\r\n\ti = binary_search(arr, 0, n-1, x)\r\n\tif i == -1:\r\n\t\treturn False\r\n\tif ((i + n//2) <= (n -1)) and arr[i + n//2] == x:\r\n\t\treturn True\r\n\telse:\r\n\t\treturn False\r\ndef binary_search(arr, low, high, x):\r\n\tif high >= low:\r\n\t\tmid = (low + high)//2 \r\n\t\tif (mid == 0 or x > arr[mid-1]) and (arr[mid] == x):\r\n\t\t\treturn mid\r\n\t\telif x > arr[mid]:\r\n\t\t\treturn binary_search(arr, (mid + 1), high, x)\r\n\t\telse:\r\n\t\t\treturn binary_search(arr, low, (mid -1), x)\r\n\treturn -1",
        "sampled": " */\n        def is_majority(arr, target, majority_count):\n            count = 0\n            for num in arr:\n                if num == target:\n                    count += 1\n            if count > majority_count:\n                return True\n            return False\n        # Test cases\n        assert is_majority([1, 2, 3, 3, 3, 3, 10], 7, 3) == True\n        assert is_majority([1, 1, 2, 4, 4, 4, 6, 6], 8, 4)"
    },
    {
        "original": "def count_Set_Bits(n): \r\n    count = 0\r\n    while (n): \r\n        count += n & 1\r\n        n >>= 1\r\n    return count ",
        "sampled": "def count_Set_Bits(n):\n    count = 0\n    while n > 0:\n        count += n & 1\n        n >>= 1\n    return count\n# Test cases\nassert count_Set_Bits(2) == 1\nassert count_Set_Bits(4) == 1\nassert count_Set_Bits(6) == 2"
    },
    {
        "original": "def find_Min(arr,low,high): \r\n    while (low < high): \r\n        mid = low + (high - low) // 2;   \r\n        if (arr[mid] == arr[high]): \r\n            high -= 1; \r\n        elif (arr[mid] > arr[high]): \r\n            low = mid + 1; \r\n        else: \r\n            high = mid; \r\n    return arr[high]; ",
        "sampled": "def find_Min(arr, start, end):\n    if start == end:\n        return arr[start]\n    mid = (start + end) // 2\n    if arr[mid] > arr[start]:\n        return find_Min(arr, start, mid)\n    else:\n        return find_Min(arr, mid+1, end)\n# Test cases\nassert find_Min([1,2,3,4,5],0,4) == 1\nassert find_Min([4,6,8],0,2) == 4\nassert find_Min(["
    },
    {
        "original": "def odd_values_string(str):\r\n  result = \"\" \r\n  for i in range(len(str)):\r\n    if i % 2 == 0:\r\n      result = result + str[i]\r\n  return result",
        "sampled": "def odd_values_string(s):\n    return ''.join([s[i] for i in range(len(s)) if i % 2 == 1])\n# Test cases\nassert odd_values_string('abcdef') == 'ace'\nassert odd_values_string('python') == 'pto'\nassert odd_values_string('data') == 'dt'"
    },
    {
        "original": "def min_of_three(a,b,c): \r\n      if (a <= b) and (a <= c): \r\n        smallest = a \r\n      elif (b <= a) and (b <= c): \r\n        smallest = b \r\n      else: \r\n        smallest = c \r\n      return smallest ",
        "sampled": "def min_of_three(a, b, c):\n    if a < b and a < c:\n        return a\n    elif b < a and b < c:\n        return b\n    else:\n        return c\n# Test cases\nassert min_of_three(10,20,0)==0\nassert min_of_three(19,15,18)==15\nassert min_of_three(-10,-20,-30)==-30"
    },
    {
        "original": "def all_Bits_Set_In_The_Given_Range(n,l,r):  \r\n    num = (((1 << r) - 1) ^ ((1 << (l - 1)) - 1)) \r\n    new_num = n & num\r\n    if (new_num == 0): \r\n        return True\r\n    return False",
        "sampled": "def all_Bits_Set_In_The_Given_Range(n, start, end):\n    \"\"\"\n    This function takes three arguments:\n    n: an integer representing the number to be checked\n    start: an integer representing the starting bit to check\n    end: an integer representing the ending bit to check\n    The function returns True if all the bits are set in the given range, and False otherwise.\n    \"\"\"\n    # Convert the given range to a binary string\n    binary_string = bin(n)[2:]\n    # Check if all the bits are set in the given range\n    for i in range(start,"
    },
    {
        "original": "def re_arrange_array(arr, n):\r\n  j=0\r\n  for i in range(0, n):\r\n    if (arr[i] < 0):\r\n      temp = arr[i]\r\n      arr[i] = arr[j]\r\n      arr[j] = temp\r\n      j = j + 1\r\n  return arr",
        "sampled": "def re_arrange_array(arr, n):\n    # Initialize two pointers, one for positive and one for negative elements\n    pos = 0\n    neg = 0\n    # Iterate through the array\n    for i in range(len(arr)):\n        # If the element is positive, increment the positive pointer\n        if arr[i] > 0:\n            pos += 1\n            # If the positive pointer is less than the negative pointer, swap the elements\n            if pos < neg:\n                arr[pos], arr[neg] = arr[neg], arr[pos]\n        # If the element is negative, increment"
    },
    {
        "original": "def replace_blank(str1,char):\r\n str2 = str1.replace(' ', char)\r\n return str2",
        "sampled": "def replace_blank(string,char):\n    return string.replace(\" \",char)"
    },
    {
        "original": "def max_sum(tri, n): \r\n\tif n > 1: \r\n\t\ttri[1][1] = tri[1][1]+tri[0][0] \r\n\t\ttri[1][0] = tri[1][0]+tri[0][0] \r\n\tfor i in range(2, n): \r\n\t\ttri[i][0] = tri[i][0] + tri[i-1][0] \r\n\t\ttri[i][i] = tri[i][i] + tri[i-1][i-1] \r\n\t\tfor j in range(1, i): \r\n\t\t\tif tri[i][j]+tri[i-1][j-1] >= tri[i][j]+tri[i-1][j]: \r\n\t\t\t\ttri[i][j] = tri[i][j] + tri[i-1][j-1] \r\n\t\t\telse: \r\n\t\t\t\ttri[i][j] = tri[i][j]+tri[i-1][j] \r\n\treturn (max(tri[n-1]))",
        "sampled": "The function should take in the following parameters:\n- triangle: a list of lists, where each inner list contains the numbers of the triangle\n- k: the number of rows to consider for the maximum sum\nThe function should return the maximum sum of the k rows of the triangle.\nTo solve this problem, you can use dynamic programming. Here's a Python implementation:\ndef max_sum(triangle, k):\n    n = len(triangle)\n    dp = [[0] * n for _ in range(n)]\n    for i in range(n):\n        dp[i][i] ="
    },
    {
        "original": "import heapq\r\ndef larg_nnum(list1,n):\r\n largest=heapq.nlargest(n,list1)\r\n return largest",
        "sampled": "def larg_nnum(dataset, n):\n    \"\"\"\n    Returns the n largest items from a dataset.\n    \"\"\"\n    # Sort the dataset in descending order\n    sorted_dataset = sorted(dataset, reverse=True)\n    # Return the first n items\n    return sorted_dataset[:n]\n# Test cases\nassert larg_nnum([10, 20, 50, 70, 90, 20, 50, 40, 60, 80, 100],2)==[100,90"
    },
    {
        "original": "def lateralsuface_cylinder(r,h):\r\n  lateralsurface= 2*3.1415*r*h\r\n  return lateralsurface",
        "sampled": "The lateral surface area of a cylinder is given by:\nLateral surface area = * h\nwhere:\nu =/2\nv =\nwhere:\nu = height of\nv = of\nThe is the diameter of the, and h is the height of the.\nThe of the is the of the, and the of the is the of the.\nThe of the is the of the, and the of the is the of the"
    },
    {
        "original": "def volume_cube(l):\r\n  volume = l * l * l\r\n  return volume",
        "sampled": "def volume_cube(side):\n    \"\"\"\n    This function takes a side of a cube as input and returns the volume of the cube.\n    \"\"\"\n    return side**3\n# Test cases\nassert volume_cube(3)==27\nassert volume_cube(2)==8\nassert volume_cube(5)==125"
    },
    {
        "original": "def even_bit_set_number(n): \r\n    count = 0;res = 0;temp = n \r\n    while(temp > 0): \r\n        if (count % 2 == 1): \r\n            res |= (1 << count)\r\n        count+=1\r\n        temp >>= 1\r\n    return (n | res) ",
        "sampled": "def even_bit_set_number(num):\n    \"\"\"\n    This function takes an integer as input and returns the number with all even bits set to 1.\n    \"\"\"\n    # Initialize a variable to store the result\n    result = 0\n    # Iterate over each bit in the input number\n    for bit in bin(num)[2:]:\n        # If the bit is even, set it to 1\n        if int(bit) == 0:\n            result += 1\n        else:\n            result += 2\n    # Return the result\n    return result"
    },
    {
        "original": "def No_of_Triangle(N,K):\r\n    if (N < K):\r\n        return -1;\r\n    else:\r\n        Tri_up = 0;\r\n        Tri_up = ((N - K + 1) *(N - K + 2)) // 2;\r\n        Tri_down = 0;\r\n        Tri_down = ((N - 2 * K + 1) *(N - 2 * K + 2)) // 2;\r\n        return Tri_up + Tri_down;",
        "sampled": "def No_of_Triangle(a,b):\n    if a+b>2 and a+b>a and a+b>b:\n        return int(a*b/2)\n    else:\n        return -1\n# Test cases\nprint(No_of_Triangle(4,2)) # Output: 7\nprint(No_of_Triangle(4,3)) # Output: 3\nprint(No_of_Triangle(1,3)) # Output: -1"
    },
    {
        "original": "from collections import Counter \r\ndef check_occurences(test_list):\r\n  res = dict(Counter(tuple(ele) for ele in map(sorted, test_list)))\r\n  return  (res) ",
        "sampled": "25, 16): 1}\nassert check_occurences([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6)] ) == {}\nassert check_occurences([(1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7)] ) == {}\nassert check_occurences([(1, 2), (2, 3), (3, 4), (4, 5), ("
    },
    {
        "original": "def number_of_substrings(str): \r\n\tstr_len = len(str); \r\n\treturn int(str_len * (str_len + 1) / 2); ",
        "sampled": "def number_of_substrings(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            count += 1\n    return count\n# Test cases\nassert number_of_substrings(\"abc\") == 6\nassert number_of_substrings(\"abcd\") == 10\nassert number_of_substrings(\"abcde\") == 15"
    },
    {
        "original": "def get_total_number_of_sequences(m,n): \r\n\tT=[[0 for i in range(n+1)] for i in range(m+1)] \r\n\tfor i in range(m+1): \r\n\t\tfor j in range(n+1): \r\n\t\t\tif i==0 or j==0: \r\n\t\t\t\tT[i][j]=0\r\n\t\t\telif i<j: \r\n\t\t\t\tT[i][j]=0\r\n\t\t\telif j==1: \r\n\t\t\t\tT[i][j]=i \r\n\t\t\telse: \r\n\t\t\t\tT[i][j]=T[i-1][j]+T[i//2][j-1] \r\n\treturn T[m][n]",
        "sampled": "def get_total_number_of_sequences(n, m):\n    def is_valid_sequence(sequence):\n        for i in range(1, len(sequence)):\n            if sequence[i] < sequence[i-1] * 2 or sequence[i] > sequence[i-1] * m:\n                return False\n        return True\n    def get_combinations(n, m):\n        if n == 0:\n            return [[]]\n        if m == 1:\n            return [[1]]\n       _combinations = get_combinations(n-1, m)"
    },
    {
        "original": "def replace_list(list1,list2):\r\n list1[-1:] = list2\r\n replace_list=list1\r\n return replace_list\r\n",
        "sampled": "def replace_list(lst, new_lst):\n    lst[-1] = new_lst\n    return lst\n# Test cases\nassert replace_list([1, 3, 5, 7, 9, 10],[2, 4, 6, 8])==[1, 3, 5, 7, 9, 2, 4, 6, 8]\nassert replace_list([1,2,3,4,5],[5,6,7,8])==[1,2,3,4,5,"
    },
    {
        "original": "def array_3d(m,n,o):\r\n array_3d = [[ ['*' for col in range(m)] for col in range(n)] for row in range(o)]\r\n return array_3d",
        "sampled": "(3,4,5)==[[['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']], [['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*'], ['*', '*', '*', '*', '*', '*']]]"
    },
    {
        "original": "def count_charac(str1):\r\n total = 0\r\n for i in str1:\r\n    total = total + 1\r\n return total",
        "sampled": "def count_charac(string):\n    count = 0\n    for char in string:\n        count += 1\n    return count\n# Test cases\nassert count_charac(\"python programming\")==18\nassert count_charac(\"language\")==8\nassert count_charac(\"words\")==5"
    },
    {
        "original": "def sort_on_occurence(lst): \r\n\tdct = {} \r\n\tfor i, j in lst: \r\n\t\tdct.setdefault(i, []).append(j) \r\n\treturn ([(i, *dict.fromkeys(j), len(j)) \r\n\t\t\t\tfor i, j in dct.items()]) ",
        "sampled": "def sort_on_occurence(lst):\n    # create a dictionary to store the count of each element in the list\n    count_dict = {}\n    for tup in lst:\n        if tup[0] in count_dict:\n            count_dict[tup[0]] += 1\n        else:\n            count_dict[tup[0]] = 1\n    # sort the list based on the count of each element\n    sorted_lst = sorted(lst, key=lambda x: count_dict[x[0]])\n    # create a new list to store the sorted tuples with their count\n    sorted_"
    },
    {
        "original": "import math  \r\ndef next_Perfect_Square(N): \r\n    nextN = math.floor(math.sqrt(N)) + 1\r\n    return nextN * nextN ",
        "sampled": "def next_Perfect_Square(num):\n    # Check if the given number is a perfect square\n    if num < 0:\n        return None\n    if num == 0:\n        return 1\n    if num == 1:\n        return 2\n    if num == 2:\n        return 4\n    if num == 3:\n        return 9\n    if num == 4:\n        return 16\n    if num == 5:\n        return 25\n    if num == 6:\n        return 36\n    if num == 7:\n        return 49\n    if num =="
    },
    {
        "original": "def max_sum(arr, n): \r\n\tMSIBS = arr[:] \r\n\tfor i in range(n): \r\n\t\tfor j in range(0, i): \r\n\t\t\tif arr[i] > arr[j] and MSIBS[i] < MSIBS[j] + arr[i]: \r\n\t\t\t\tMSIBS[i] = MSIBS[j] + arr[i] \r\n\tMSDBS = arr[:] \r\n\tfor i in range(1, n + 1): \r\n\t\tfor j in range(1, i): \r\n\t\t\tif arr[-i] > arr[-j] and MSDBS[-i] < MSDBS[-j] + arr[-i]: \r\n\t\t\t\tMSDBS[-i] = MSDBS[-j] + arr[-i] \r\n\tmax_sum = float(\"-Inf\") \r\n\tfor i, j, k in zip(MSIBS, MSDBS, arr): \r\n\t\tmax_sum = max(max_sum, i + j - k) \r\n\treturn max_sum",
        "sampled": " */\n        def max_sum(arr, k):\n            = {}\n           [0] = arr[0]\n            max_sum = arr[0]\n            for i in range(1, len(arr)):\n                if i - k >= 0:\n                    if i - k in:\n                        if[i - k] + arr[i] > max_sum:\n                            max_sum = arr[i] + max_sum\n                    else:\n                        if arr[i] > max_sum:\n                            max_sum = arr[i]\n                else:\n                    if arr[i] > max"
    },
    {
        "original": "def babylonian_squareroot(number):\r\n    if(number == 0):\r\n        return 0;\r\n    g = number/2.0;\r\n    g2 = g + 1;\r\n    while(g != g2):\r\n        n = number/ g;\r\n        g2 = g;\r\n        g = (g + n)/2;\r\n    return g;",
        "sampled": "The function should take a single argument, which is the number for which you want to compute the square root. The function should return the square root as a float.\nThe babylonian method is a simple and efficient way to compute square roots. It works by repeatedly approximating the square root by the average of the previous two estimates. The is the number for which we want to compute the square root, and the is the function to approximate the square root. The function is the function for the babylonian method, which is the function for the function.\nThe"
    },
    {
        "original": "def lps(str): \r\n\tn = len(str) \r\n\tL = [[0 for x in range(n)] for x in range(n)] \r\n\tfor i in range(n): \r\n\t\tL[i][i] = 1\r\n\tfor cl in range(2, n+1): \r\n\t\tfor i in range(n-cl+1): \r\n\t\t\tj = i+cl-1\r\n\t\t\tif str[i] == str[j] and cl == 2: \r\n\t\t\t\tL[i][j] = 2\r\n\t\t\telif str[i] == str[j]: \r\n\t\t\t\tL[i][j] = L[i+1][j-1] + 2\r\n\t\t\telse: \r\n\t\t\t\tL[i][j] = max(L[i][j-1], L[i+1][j]); \r\n\treturn L[0][n-1]",
        "sampled": "def lps(s):\n    n = len(s)\n    dp = [[0] * n for _ in range(n)]\n    max_len = 1\n    start = 0\n    for i in range(n):\n        dp[i][i] = 1\n        if s[i] == s[i + 1]:\n            dp[i][i + 1] = 2\n            max_len = 2\n            start = i\n    for length in range(3, n + 1):\n        for i in range(n - length + 1):\n            j = i +"
    },
    {
        "original": "def harmonic_sum(n):\r\n  if n < 2:\r\n    return 1\r\n  else:\r\n    return 1 / n + (harmonic_sum(n - 1)) ",
        "sampled": "The harmonic sum of a sequence of n numbers is the sum of the reciprocals of the numbers divided by the sum of the numbers. The harmonic sum of n-1 is the sum of the reciprocals of the numbers divided by the sum of the numbers up to n-1.\nFor example, the harmonic sum of 7 is 2.5928571428571425, which is the sum of the reciprocals of the numbers divided by the sum of the numbers up to 7:\nreci"
    },
    {
        "original": "def intersection_array(array_nums1,array_nums2):\r\n result = list(filter(lambda x: x in array_nums1, array_nums2)) \r\n return result",
        "sampled": "def intersection_array(arr1, arr2):\n    return list(set(arr1) & set(arr2))\n# Test cases\nassert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[1, 2, 4, 8, 9])==[1, 2, 8, 9]\nassert intersection_array([1, 2, 3, 5, 7, 8, 9, 10],[3,5,7,9])=="
    },
    {
        "original": "def count_X(tup, x): \r\n    count = 0\r\n    for ele in tup: \r\n        if (ele == x): \r\n            count = count + 1\r\n    return count ",
        "sampled": "def count_X(tuple_X, X):\n    count = 0\n    for i in tuple_X:\n        if i == X:\n            count += 1\n    return count\n# Test cases\nassert count_X((10, 8, 5, 2, 10, 15, 10, 8, 5, 8, 8, 2),4) == 0\nassert count_X((10, 8, 5, 2, 10, 15, 10, 8, "
    },
    {
        "original": "def insert_element(list,element):\r\n list = [v for elt in list for v in (element, elt)]\r\n return list",
        "sampled": "def insert_element(lst, element):\n    \"\"\"\n    This function takes a list and an element as input and returns a new list with the element inserted before each element of the original list.\n    \"\"\"\n    new_lst = []\n    for i in range(len(lst)):\n        new_lst.append(element)\n        new_lst.append(lst[i])\n    return new_lst\n# Test cases\nassert insert_element(['Red', 'Green', 'Black'],'c')==['c', 'Red', 'c', 'Green', 'c', 'Black'] \nassert insert"
    },
    {
        "original": "import cmath  \r\ndef convert(numbers):    \r\n  num = cmath.polar(numbers)  \r\n  return (num) ",
        "sampled": "assert convert(1+2j) == (1.4142135623730951, 0.7853981633974483)\nassert convert(2+3j) == (2.23606797749979, 0.9424777960769379)\nassert convert(3+4j) == (2.949747401953125, "
    },
    {
        "original": "def count_integer(list1):\r\n    ctr = 0\r\n    for i in list1:\r\n        if isinstance(i, int):\r\n            ctr = ctr + 1\r\n    return ctr",
        "sampled": "def count_integer(lst):\n    count = 0\n    for item in lst:\n        if isinstance(item, int):\n            count += 1\n    return count\n# Test cases\nassert count_integer([1,2,'abc',1.2]) == 2\nassert count_integer([1,2,3]) == 3\nassert count_integer([1,1.2,4,5.1]) == 2"
    },
    {
        "original": "import re\r\ndef words_ae(text):\r\n list = re.findall(\"[ae]\\w+\", text)\r\n return list",
        "sampled": "def words_ae(s):\n    words = s.split()\n    result = []\n    for word in words:\n        if word[0] in ['a', 'e']:\n            result.append(word)\n    return result\n# Test cases\nassert words_ae(\"python programe\")==['ame']\nassert words_ae(\"python programe language\")==['ame','anguage']\nassert words_ae(\"assert statement\")==['assert', 'atement']"
    },
    {
        "original": "from itertools import combinations_with_replacement \r\ndef combinations_colors(l, n):\r\n    return list(combinations_with_replacement(l,n))\r",
        "sampled": "def combinations_colors(colors, n):\n    result = []\n    for i in range(len(colors)):\n        for j in range(i+1, len(colors)):\n            for k in range(j+1, len(colors)):\n                combination = (colors[i], colors[j], colors[k])\n                if len(combination) == n:\n                    result.append(combination)\n    return result\n# Test cases\nassert combinations_colors( [\"Red\",\"Green\",\"Blue\"],1)==[('Red',), ('Green',), ('Blue',)]\nassert combinations_colors("
    },
    {
        "original": "def count_Primes_nums(n):\r\n    ctr = 0\r\n    for num in range(n):\r\n        if num <= 1:\r\n            continue\r\n        for i in range(2,num):\r\n            if (num % i) == 0:\r\n                break\r\n        else:\r\n            ctr += 1\r\n    return ctr",
        "sampled": "def count_Primes_nums(n):\n    count = 0\n    for i in range(2, n):\n        if all(i % j!= 0 for j in range(2, int(i**0.5)+1)):\n            count += 1\n    return count\n# Test cases\nassert count_Primes_nums(5) == 2\nassert count_Primes_nums(10) == 4\nassert count_Primes_nums(100) == 25"
    },
    {
        "original": "def swap_numbers(a,b):\r\n temp = a\r\n a = b\r\n b = temp\r\n return (a,b)",
        "sampled": "def swap_numbers(a, b):\n    return (b, a)\n# Test cases\nassert swap_numbers(10,20)==(20,10)\nassert swap_numbers(15,17)==(17,15)\nassert swap_numbers(100,200)==(200,100)"
    },
    {
        "original": "def count_odd(array_nums):\r\n   count_odd = len(list(filter(lambda x: (x%2 != 0) , array_nums)))\r\n   return count_odd",
        "sampled": "def count_odd(lst):\n    return len(list(filter(lambda x: x%2!=0, lst)))\n# Test cases\nassert count_odd([1, 2, 3, 5, 7, 8, 10])==4\nassert count_odd([10,15,14,13,-18,12,-20])==2\nassert count_odd([1, 2, 4, 8, 9])==2"
    },
    {
        "original": "def maximize_elements(test_tup1, test_tup2):\r\n  res = tuple(tuple(max(a, b) for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res) ",
        "sampled": " 5))) == ((8, 9), (6, 11), (4, 11), (9, 12))\nassert maximize_elements(((1, 2), (3, 4), (5, 6), (7, 8)), ((9, 10), (11, 12), (9, 13), (13, 14))) == ((9, 10), (11, 12), (13, 14), (14, 15))\nassert maximize_"
    },
    {
        "original": "def newman_prime(n): \r\n\tif n == 0 or n == 1: \r\n\t\treturn 1\r\n\treturn 2 * newman_prime(n - 1) + newman_prime(n - 2)",
        "sampled": "def newman_prime(n):\n    \"\"\"\n    Returns the nth newman-shanks-williams prime number.\n    \"\"\"\n    # Initialize the_primes list with the first 10man-shanks-williams primes\n   _primes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]\n    # Iterate over the remaining_primes to find the nth newman-shanks-williams prime\n    for i in range(1"
    },
    {
        "original": "def division_elements(test_tup1, test_tup2):\r\n  res = tuple(ele1 // ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ",
        "sampled": "def division_elements(tuple1, tuple2):\n    \"\"\"\n    This function takes two tuples as input and returns the result of the division operation\n    across the tuples.\n    \"\"\"\n    result = []\n    for i in range(len(tuple1)):\n        result.append(tuple1[i] / tuple2[i])\n    return tuple(result)\n# Test cases\nassert division_elements((10, 4, 6, 9),(5, 2, 3, 3)) == (2, 2, 2, 3)\nassert division_elements((1"
    },
    {
        "original": "def split_two_parts(list1, L):\r\n    return list1[:L], list1[L:]",
        "sampled": "def split_two_parts(lst, n):\n    \"\"\"\n    Split a given list into two parts where the length of the first part of the list is given.\n    \"\"\"\n    if n > len(lst):\n        raise ValueError(\"The length of the first part should be less than or equal to the length of the list.\")\n    return lst[:n], lst[n:]"
    },
    {
        "original": "def merge_dict(d1,d2):\r\n d = d1.copy()\r\n d.update(d2)\r\n return d",
        "sampled": "def merge_dict(dict1, dict2):\n    \"\"\"\n    Merge two dictionaries.\n    \"\"\"\n    merged_dict = dict1.copy()\n    merged_dict.update(dict2)\n    return merged_dict\n# Test cases\nassert merge_dict({'a': 100, 'b': 200},{'x': 300, 'y': 200})=={'x': 300, 'y': 200, 'a': 100, 'b': 200}\nassert merge_dict({'a"
    },
    {
        "original": "def dog_age(h_age):\r\n if h_age < 0:\r\n \texit()\r\n elif h_age <= 2:\r\n\t d_age = h_age * 10.5\r\n else:\r\n\t d_age = 21 + (h_age - 2)*4\r\n return d_age",
        "sampled": "def dog_age(dog_years):\n   _dog_years = dog_years * 7\n   _dog_years = int(round(float(dog_years) * 7))\n    return str(int(round(float(dog_years) * 7))) + \" years\""
    },
    {
        "original": "def list_split(S, step):\r\n    return [S[i::step] for i in range(step)]",
        "sampled": "def list_split(lst, n):\n    \"\"\"\n    Split a list for every nth element.\n    Args:\n        lst (list): A list to split.\n        n (int): The number of elements to split for.\n    Returns:\n        list: A list of lists, where each inner list contains n elements from the original list.\n    \"\"\"\n    return [lst[i:i+n] for i in range(0, len(lst), n)]\n# Test cases\nassert list_split(['a', 'b', 'c', 'd', 'e', 'f', 'g', '"
    },
    {
        "original": "def lateralsurface_cube(l):\r\n  LSA = 4 * (l * l)\r\n  return LSA",
        "sampled": "The function should take a single argument, which is the length of the cube. The function should return the lateral surface area of the cube.\nThe lateral surface area of a cube is the sum of theices of theices of the cube. Theices are theices of theices of the cube, and so on. Theices are theices of theices of theices of the cube, and so on.\nFor example, the lateral surface area of a cube with side length 5 is:\n5^2 + 5^2 + "
    },
    {
        "original": "def square_Sum(n):  \r\n    return int(n*(4*n*n-1)/3) ",
        "sampled": "def square_Sum(n):\n    \"\"\"\n    This function takes an integer n as input and returns the sum of squares of first n odd natural numbers.\n    \"\"\"\n    sum_of_squares = 0\n    for i in range(1, n+1, 2):\n        sum_of_squares += i**2\n    return sum_of_squares\n# Test cases\nassert square_Sum(2) == 10\nassert square_Sum(3) == 35\nassert square_Sum(4) == 84"
    },
    {
        "original": "def find_star_num(n): \r\n\treturn (6 * n * (n - 1) + 1) ",
        "sampled": "def find_star_num(n):\n    # initialize the list with the sequence\n    v = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 2"
    },
    {
        "original": "def ascii_value(k):\r\n  ch=k\r\n  return ord(ch)",
        "sampled": ""
    },
    {
        "original": "def sum_even_and_even_index(arr,n):  \r\n    i = 0\r\n    sum = 0\r\n    for i in range(0,n,2): \r\n        if (arr[i] % 2 == 0) : \r\n            sum += arr[i]  \r\n    return sum",
        "sampled": "def sum_even_and_even_index(lst, n):\n    even_sum = 0\n    even_index = 0\n    for i in range(n):\n        if lst[i] % 2 == 0:\n            even_sum += lst[i]\n            even_index += 1\n    return even_sum, even_index\n# Test cases\nassert sum_even_and_even_index([5, 6, 12, 1, 18, 8],6) == (30, 2)\nassert sum_even_"
    },
    {
        "original": "def even_Power_Sum(n): \r\n    sum = 0; \r\n    for i in range(1,n+1): \r\n        j = 2*i; \r\n        sum = sum + (j*j*j*j*j); \r\n    return sum; ",
        "sampled": "def even_Power_Sum(n):\n    \"\"\"\n    This function takes an integer n as input and returns the sum of the fifth power of the first n even natural numbers.\n    \"\"\"\n    sum = 0\n    for i in range(1, n+1, 2):\n        sum += i**5\n    return sum\n# Test cases\nassert even_Power_Sum(2) == 1056\nassert even_Power_Sum(3) == 8832\nassert even_Power_Sum(1) == 32"
    },
    {
        "original": "def rear_extract(test_list):\r\n  res = [lis[-1] for lis in test_list]\r\n  return (res) ",
        "sampled": "def rear_extract(records):\n    return [record[1] for record in records]\n# Test cases\nassert rear_extract([(1, 'Rash', 21), (2, 'Varsha', 20), (3, 'Kil', 19)]) == [21, 20, 19]\nassert rear_extract([(1, 'Sai', 36), (2, 'Ayesha', 25), (3, 'Salman', 45)]) == [36, 25, 45]"
    },
    {
        "original": "def substract_elements(test_tup1, test_tup2):\r\n  res = tuple(map(lambda i, j: i - j, test_tup1, test_tup2))\r\n  return (res) ",
        "sampled": "def substract_elements(tuple1, tuple2):\n    return tuple(x - y for x, y in zip(tuple1, tuple2))\n# Test cases\nassert substract_elements((10, 4, 5), (2, 5, 18)) == (8, -1, -13)\nassert substract_elements((11, 2, 3), (24, 45,16)) == (-13, -43, -13)\nassert substract_elements((7, 18,"
    },
    {
        "original": "import math  \r\ndef even_binomial_Coeff_Sum( n): \r\n    return (1 << (n - 1)) ",
        "sampled": "def even_binomial_Coeff_Sum(n):\n    \"\"\"\n    This function returns the sum of even index binomial coefficients of a given integer n.\n    \"\"\"\n    # Initialize the sum to 0\n    sum = 0\n    # Loop through the even indices\n    for i in range(2, n+1, 2):\n        # Calculate the binomial coefficient\n        coeff = (n-i+1) // i\n        # Add the coefficient to the sum\n        sum += coeff\n    return sum\n# Test the function\nassert even_binomial_Coeff_Sum(4) == 8\nassert"
    },
    {
        "original": "import math as mt \r\ndef get_Position(a,n,m): \r\n    for i in range(n): \r\n        a[i] = (a[i] // m + (a[i] % m != 0))  \r\n    result,maxx = -1,-1\r\n    for i in range(n - 1,-1,-1): \r\n        if (maxx < a[i]): \r\n            maxx = a[i] \r\n            result = i \r\n    return result + 1",
        "sampled": "def get_Position(arr, x, y):\n    \"\"\"\n    This function takes an array, x and y as input and returns the position of the last removed element from the array.\n    \"\"\"\n    arr.remove(x)\n    return arr.index(y)\n# Test cases\nassert get_Position([2,5,4],3,2) == 2\nassert get_Position([4,3],2,2) == 2\nassert get_Position([1,2,3,4],4,1) == 4"
    },
    {
        "original": "def volume_cylinder(r,h):\r\n  volume=3.1415*r*r*h\r\n  return volume",
        "sampled": "The function should take two arguments: and h, where v = 1/3 * \u03c0 * r^2 * h.\nNote: The is the radius of the, and the is the height of the."
    },
    {
        "original": "def dict_filter(dict,n):\r\n result = {key:value for (key, value) in dict.items() if value >=n}\r\n return result",
        "sampled": "Pierre Cox': 190},160)=={}\nassert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': 165, 'Pierre Cox': 190},180,175)=={'Alden Cantrell': 180}\nassert dict_filter({'Cierra Vega': 175, 'Alden Cantrell': 180, 'Kierra Gentry': "
    },
    {
        "original": "def count_first_elements(test_tup):\r\n  for count, ele in enumerate(test_tup):\r\n    if isinstance(ele, tuple):\r\n      break\r\n  return (count) ",
        "sampled": "Here's the function to find the element count that occurs before the record in the given tuple:\ndef count_first_elements(t):\n    count = 0\n    for i in range(len(t)):\n        if isinstance(t[i], tuple):\n            count += count_first_elements(t[i])\n        else:\n            count += 1\n    return count\nYou can test the function with the given test cases:\nassert count_first_elements((1, 5, 7, (4, 6), 10) ) == 3\nassert count_"
    },
    {
        "original": "def is_num_decagonal(n): \r\n\treturn 4 * n * n - 3 * n ",
        "sampled": "def is_num_decagonal(n):\n    \"\"\"\n    Returns True if n is a decagonal number, False otherwise.\n    A decagonal number is a positive integer that is equal to the sum of the squares of its digits.\n    For example, 155 is a decagonal number because 1^2 + 5^2 + 5^2 = 155.\n    \"\"\"\n    # Convert n to a string\n    n_str = str(n)\n    # Initialize the sum of squares to 0\n    sum_of_squares = 0\n    # Iterate over"
    },
    {
        "original": "def sequential_search(dlist, item):\r\n    pos = 0\r\n    found = False\r\n    while pos < len(dlist) and not found:\r\n        if dlist[pos] == item:\r\n            found = True\r\n        else:\r\n            pos = pos + 1\r\n    return found, pos",
        "sampled": "def sequential_search(arr, x):\n    for i in range(len(arr)):\n        if arr[i] == x:\n            return (True, i)\n    return (False, -1)\n# Test cases\nassert sequential_search([11,23,58,31,56,77,43,12,65,19],31) == (True, 3)\nassert sequential_search([12, 32, 45, 62, 35, 47, 44,"
    },
    {
        "original": "def all_unique(test_list):\r\n    if len(test_list) > len(set(test_list)):\r\n        return False\r\n    return True",
        "sampled": ""
    },
    {
        "original": "def sub_list(nums1,nums2):\r\n  result = map(lambda x, y: x - y, nums1, nums2)\r\n  return list(result)",
        "sampled": "def sub_list(list1, list2):\n    return list(map(lambda x: x - list2[0], list1))\n# Test cases\nassert sub_list([1, 2, 3], [4, 5, 6]) == [-3, -3, -3]\nassert sub_list([1, 2], [3, 4]) == [-2, -2]\nassert sub_list([90, 120], [50, 70]) == [40, 50]"
    },
    {
        "original": "def validate(n): \r\n    for i in range(10): \r\n        temp = n;  \r\n        count = 0; \r\n        while (temp): \r\n            if (temp % 10 == i): \r\n                count+=1;  \r\n            if (count > i): \r\n                return False\r\n            temp //= 10; \r\n    return True",
        "sampled": "def validate(num):\n    # convert the number to a string\n    num_str = str(num)\n    # create a dictionary to store the frequency of each digit\n    freq = {}\n    # loop through each digit in the number\n    for digit in num_str:\n        # if the digit is already in the dictionary, increment its frequency\n        if digit in freq:\n            freq[digit] += 1\n        # otherwise, add the digit to the dictionary with a frequency of 1\n        else:\n            freq[digit] = 1\n    # loop through each digit in the dictionary\n    for digit in freq:\n        #"
    },
    {
        "original": "def check_element(list,element):\r\n  check_element=all(v== element for v in list)\r\n  return check_element",
        "sampled": "def check_element(lst, target):\n    for item in lst:\n        if item!= target:\n            return False\n    return True\n# Test cases\nassert check_element([\"green\", \"orange\", \"black\", \"white\"],'blue')==False\nassert check_element([1,2,3,4],7)==False\nassert check_element([\"green\", \"green\", \"green\", \"green\"],'green')==True"
    },
    {
        "original": "import re\r\ndef text_match_two_three(text):\r\n        patterns = 'ab{2,3}'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')",
        "sampled": "def text_match_two_three(text):\n    if 'a' in text and ('b' in text or 'b' in text[1:]):\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n# Test cases\nassert text_match_two_three(\"ac\")==('Not matched!')\nassert text_match_two_three(\"dc\")==('Not matched!')\nassert text_match_two_three(\"abbbba\")==('Found a match!')"
    },
    {
        "original": "def max_sub_array_sum_repeated(a, n, k): \r\n\tmax_so_far = -2147483648\r\n\tmax_ending_here = 0\r\n\tfor i in range(n*k): \r\n\t\tmax_ending_here = max_ending_here + a[i%n] \r\n\t\tif (max_so_far < max_ending_here): \r\n\t\t\tmax_so_far = max_ending_here \r\n\t\tif (max_ending_here < 0): \r\n\t\t\tmax_ending_here = 0\r\n\treturn max_so_far",
        "sampled": " */\n        def max_sub_array_sum_repeated(arr, n, k):\n            = sum(arr)\n            = // k\n           _arr = [0] * k\n           _arr[0] = arr[0]\n           _arr[1] = arr[1]\n            for i in range(2, n):\n               _arr[i % k] = max(arr[i], arr[i] +_arr[(i - 1) % k])\n            return max(it.accumulate(it.chain(it.repeat(0,"
    },
    {
        "original": "def square_Sum(n):  \r\n    return int(2*n*(n+1)*(2*n+1)/3)",
        "sampled": "def square_Sum(n):\n    \"\"\"\n    This function takes an integer n as input and returns the sum of squares of first n even natural numbers.\n    \"\"\"\n    sum_of_squares = 0\n    for i in range(2, n+1, 2):\n        sum_of_squares += i**2\n    return sum_of_squares\n# Test cases\nassert square_Sum(2) == 20\nassert square_Sum(3) == 56\nassert square_Sum(4) == 120"
    },
    {
        "original": "def modular_inverse(arr, N, P):\r\n\tcurrent_element = 0\r\n\tfor i in range(0, N):\r\n\t\tif ((arr[i] * arr[i]) % P == 1):\r\n\t\t\tcurrent_element = current_element + 1\r\n\treturn current_element",
        "sampled": "def modular_inverse(arr, p, mod):\n    # Calculate the modular multiplicative inverse of a number a (mod p)\n    def inv(a, p):\n        if p == 1:\n            return a\n        else:\n            return inv(p, a % p) * (1 / p)\n    # Calculate the modular multiplicative inverse of each element in the array\n    inv_arr = [inv(x, p) for x in arr]\n    # Count the number of elements in the array that have modular inverse under p\n    count = 0\n    for x in arr:\n        if inv"
    },
    {
        "original": "def odd_Days(N): \r\n    hund1 = N // 100\r\n    hund4 = N // 400\r\n    leap = N >> 2\r\n    ordd = N - leap \r\n    if (hund1): \r\n        ordd += hund1 \r\n        leap -= hund1 \r\n    if (hund4): \r\n        ordd -= hund4 \r\n        leap += hund4 \r\n    days = ordd + leap * 2\r\n    odd = days % 7\r\n    return odd ",
        "sampled": ""
    },
    {
        "original": "def max_length(list1):\r\n    max_length = max(len(x) for x in  list1 )  \r\n    max_list = max((x) for x in   list1)\r\n    return(max_length, max_list)",
        "sampled": "def max_length(lst):\n    max_length = 0\n    max_list = []\n    for sublist in lst:\n        if len(sublist) > max_length:\n            max_length = len(sublist)\n            max_list = sublist\n    return max_length, max_list\n# Test cases\nassert max_length([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])\nassert max"
    },
    {
        "original": "def count_no_of_ways(n, k): \r\n\tdp = [0] * (n + 1) \r\n\ttotal = k \r\n\tmod = 1000000007\r\n\tdp[1] = k \r\n\tdp[2] = k * k\t \r\n\tfor i in range(3,n+1): \r\n\t\tdp[i] = ((k - 1) * (dp[i - 1] + dp[i - 2])) % mod \r\n\treturn dp[n]",
        "sampled": "def count_no_of_ways(n, k):\n    = [0] * (k + 1)\n   [0] = 1\n    for i in range(1, k + 1):\n        for j in range(1, n + 1):\n            if[i] == 0:\n                break\n            if i == j:\n                if j == 1:\n                    ver = 1\n                else:\n                    ver = 2\n            else:\n                ver = 1\n            if i == 1:\n                hor = 1\n            else:\n                hor = 2"
    },
    {
        "original": "def find(n,m):  \r\n    q = n//m \r\n    return (q)",
        "sampled": "def find(num1, num2):\n    return num1 // num2\n# Test cases\nassert find(10,3) == 3\nassert find(4,2) == 2\nassert find(20,5) == 4"
    },
    {
        "original": "import math\r\ndef otherside_rightangle(w,h):\r\n  s=math.sqrt((w*w)+(h*h))\r\n  return s",
        "sampled": "Here's the function:\ndef otherside_rightangle(a,b):\n    c = a**2 + b**2\n    return (a**2 + b**2 + c**2)**0.5\n# Test cases\nassert otherside_rightangle(7,8)==10.63014581273465\nassert otherside_rightangle(3,4)==5\nassert otherside_rightangle(7,15)==16.55294535724685"
    },
    {
        "original": "def max_val(listval):\r\n     max_val = max(i for i in listval if isinstance(i, int)) \r\n     return(max_val)",
        "sampled": "Here's the function:\ndef max_val(lst):\n    max_val = lst[0]\n    for i in range(1, len(lst)):\n        if type(lst[i]) > type(max_val):\n            max_val = lst[i]\n    return max_val\n# Test cases\nassert max_val(['Python', 3, 2, 4, 5,'version'])==5\nassert max_val(['Python', 15, 20, 25])==25\nassert max_val(['Python', 3"
    },
    {
        "original": "def sum_div(number):\r\n    divisors = [1]\r\n    for i in range(2, number):\r\n        if (number % i)==0:\r\n            divisors.append(i)\r\n    return sum(divisors)",
        "sampled": "def sum_div(n):\n    div_sum = 0\n    for i in range(1, n+1):\n        if n % i == 0:\n            div_sum += i\n    return div_sum\n# Test cases\nassert sum_div(8)==7\nassert sum_div(12)==16\nassert sum_div(7)==1"
    },
    {
        "original": "def get_Inv_Count(arr,n): \r\n    inv_count = 0\r\n    for i in range(n): \r\n        for j in range(i + 1,n): \r\n            if (arr[i] > arr[j]): \r\n                inv_count += 1\r\n    return inv_count ",
        "sampled": "def get_Inv_Count(arr, n):\n    # Sort the array\n    arr.sort()\n    # Initialize the count variable\n    count = 0\n    # Traverse the array\n    for i in range(n):\n        # Calculate the index\n        left = i\n        right = n - 1\n        # Traverse the left half of the array\n        while left < right:\n            # If the left element is greater than the right element, increment the count and swap the elements\n            if arr[left] > arr[right]:\n                count += right - left\n                arr[left], arr[right] = arr"
    },
    {
        "original": "def flatten_list(list1):\r\n    result_list = []\r\n    if not list1: return result_list\r\n    stack = [list(list1)]\r\n    while stack:\r\n        c_num = stack.pop()\r\n        next = c_num.pop()\r\n        if c_num: stack.append(c_num)\r\n        if isinstance(next, list):\r\n            if next: stack.append(list(next))\r\n        else: result_list.append(next)\r\n    result_list.reverse()\r\n    return result_list ",
        "sampled": "7,8,9]])==[1,2,3,4,5,6,7,8,9]\nassert flatten_list([1,2,[3,4,[5,6,[7,8]]]])==[1,2,3,4,5,6,7,8]\nassert flatten_list([1,2,[3,4,[5,6,[7,8]]],9])==[1,2,3,4,5,6,7,8,9]\nassert flatten_list([1,2,[3,4,[5,"
    },
    {
        "original": "def intersection_nested_lists(l1, l2):\r\n    result = [[n for n in lst if n in l1] for lst in l2]\r\n    return result",
        "sampled": "['george']])==[['john'], ['john']]\nassert intersection_nested_lists([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10, 11, 12]])==[[1, 2, 3], [4, 5, 6], [7, 8, 9]]\nassert intersection_nested_lists([[1, 2, 3],"
    },
    {
        "original": "from collections import defaultdict\r\ndef max_aggregate(stdata):\r\n    temp = defaultdict(int)\r\n    for name, marks in stdata:\r\n        temp[name] += marks\r\n    return max(temp.items(), key=lambda x: x[1])",
        "sampled": "def max_aggregate(lst):\n    max_name = ''\n    max_sum = 0\n    for name, sum in lst:\n        if sum > max_sum:\n            max_sum = sum\n            max_name = name\n    return max_name, max_sum\n# Test cases\nassert max_aggregate([('Juan Whelan',90),('Sabah Colley',88),('Peter Nichols',7),('Juan Whelan',122),('Sabah Colley',84)])==('Juan Whelan', "
    },
    {
        "original": "def count_binary_seq(n): \r\n\tnCr = 1\r\n\tres = 1\r\n\tfor r in range(1, n + 1): \r\n\t\tnCr = (nCr * (n + 1 - r)) / r \r\n\t\tres += nCr * nCr \r\n\treturn res ",
        "sampled": "def count_binary_seq(n):\n    count = 0\n    for i in range(2**n):\n        for j in range(2**n):\n            if i + j == 2**(2*n):\n                count += 1\n    return count\n# Test cases\nassert count_binary_seq(1) == 2.0\nassert count_binary_seq(2) == 6.0\nassert count_binary_seq(3) == 20.0"
    },
    {
        "original": "def dict_depth(d):\r\n    if isinstance(d, dict):\r\n        return 1 + (max(map(dict_depth, d.values())) if d else 0)\r\n    return 0",
        "sampled": "def dict_depth(d):\n    \"\"\"\n    This function takes a dictionary as input and returns its depth.\n    The depth of a dictionary is the number of nested dictionaries it contains.\n    \"\"\"\n    depth = 0\n    for value in d.values():\n        if isinstance(value, dict):\n            depth += 1\n    return depth\n# Test cases\nassert dict_depth({'a':1, 'b': {'c': {'d': {}}}}) == 4\nassert dict_depth({'a':1, 'b': {'c':'python'}}) == 2\nassert dict_depth({1:"
    },
    {
        "original": "def set_Bit_Number(n): \r\n    if (n == 0): \r\n        return 0; \r\n    msb = 0; \r\n    n = int(n / 2); \r\n    while (n > 0): \r\n        n = int(n / 2); \r\n        msb += 1; \r\n    return (1 << msb)",
        "sampled": "def set_Bit_Number(n):\n    # Convert the integer to binary\n    binary_str = bin(n)[2:]\n    # Find the most significant set bit\n    most_significant_set_bit = None\n    for i in range(len(binary_str)):\n        if binary_str[i] == '1':\n            most_significant_set_bit = i\n            break\n    # Find the least significant set bit\n    least_significant_set_bit = None\n    for i in range(len(binary_str) - 1, -1, -1):\n        if binary"
    },
    {
        "original": "import sys \r\ndef solve(a,n):   \r\n    mx = -sys.maxsize - 1\r\n    for j in range(1,n):  \r\n        if (mx > a[j]):  \r\n            return False  \r\n        mx = max(mx,a[j - 1])    \r\n    return True",
        "sampled": "def solve(arr, n):\n    # Sort the array in ascending order\n    arr.sort()\n    # Initialize two pointers, left and right, to the first and last indices of the array, respectively\n    left = 0\n    right = n - 1\n    # Initialize two variables,1 and2, to 0\n    ver1 = 0\n    ver2 = 0\n    # Iterate through the array\n    while left < right:\n        # If the element at the left pointer is greater than the element at the right pointer, increment the count of inversion\n        if arr[left] > arr[right"
    },
    {
        "original": "def find_Element(arr,ranges,rotations,index) :  \r\n    for i in range(rotations - 1,-1,-1 ) : \r\n        left = ranges[i][0] \r\n        right = ranges[i][1] \r\n        if (left <= index and right >= index) : \r\n            if (index == left) : \r\n                index = right \r\n            else : \r\n                index = index - 1 \r\n    return arr[index] ",
        "sampled": "def find_Element(arr, rotations,_index,_rotation):\n    # Find the_index after rotations\n    for i in range(len(rotations)):\n        if rotations[i][0] == v_index and rotations[i][1] == v_rotation:\n            v_index = rotations[i][0] + rotations[i][1]\n            v_rotation = i\n            break\n    # Find the_index after rotations\n    for i in range(len(rotations)):\n        if rotations[i][0] ==_"
    },
    {
        "original": "import re\r\ndef start_withp(words):\r\n for w in words:\r\n        m = re.match(\"(P\\w+)\\W(P\\w+)\", w)\r\n        if m:\r\n            return m.groups()",
        "sampled": "def start_withp(words):\n    for word in words:\n        if word[0] == 'p':\n            return word.split()[0], word.split()[1]\n    return None, None\n# Test cases\nassert start_withp([\"Python PHP\", \"Java JavaScript\", \"c c++\"])==('Python', 'PHP')\nassert start_withp([\"Python Programming\",\"Java Programming\"])==('Python','Programming')\nassert start_withp([\"Pqrst Pqr\",\"qrstuv\"])==('Pqrst','Pqr')"
    },
    {
        "original": "def max_sum_increasing_subseq(a, n, index, k):\r\n\tdp = [[0 for i in range(n)] \r\n\t\t\tfor i in range(n)]\r\n\tfor i in range(n):\r\n\t\tif a[i] > a[0]:\r\n\t\t\tdp[0][i] = a[i] + a[0]\r\n\t\telse:\r\n\t\t\tdp[0][i] = a[i]\r\n\tfor i in range(1, n):\r\n\t\tfor j in range(n):\r\n\t\t\tif a[j] > a[i] and j > i:\r\n\t\t\t\tif dp[i - 1][i] + a[j] > dp[i - 1][j]:\r\n\t\t\t\t\tdp[i][j] = dp[i - 1][i] + a[j]\r\n\t\t\t\telse:\r\n\t\t\t\t\tdp[i][j] = dp[i - 1][j]\r\n\t\t\telse:\r\n\t\t\t\tdp[i][j] = dp[i - 1][j]\r\n\treturn dp[index][k]",
        "sampled": "def max_sum_increasing_subseq(arr, n, i, k):\n    # Initialize the maximum sum and the current sum\n    max_sum = float('-inf')\n    curr_sum = 0\n    # Traverse through the array from i to n-1\n    for j in range(i, n):\n        # If the current element is greater than k\n        if arr[j] > k:\n            # Calculate the sum of the increasing subsequence till j\n            curr_sum += arr[j]\n            # Update the maximum sum if the current sum is greater than the maximum sum\n            if curr"
    },
    {
        "original": "from copy import deepcopy\r\ndef colon_tuplex(tuplex,m,n):\r\n  tuplex_colon = deepcopy(tuplex)\r\n  tuplex_colon[m].append(n)\r\n  return tuplex_colon",
        "sampled": "def colon_tuplex(tup, index1, index2):\n    \"\"\"\n    Returns a tuple with the elements from the input tuple up to the index1-th element,\n    and the elements from the index1-th element to the index2-th element,\n    and the elements from the index2-th element to the end of the tuple.\n    \"\"\"\n    return tup[:index1] + (tup[index1],) + tup[index2:]\n# Test cases\nassert colon_tuplex((\"HELLO\", 5, [], True),2,50)==(\"HELLO\","
    },
    {
        "original": "def large_product(nums1, nums2, N):\r\n    result = sorted([x*y for x in nums1 for y in nums2], reverse=True)[:N]\r\n    return result",
        "sampled": "def large_product(list1, list2, n):\n    \"\"\"\n    Given two lists, find the n largest products of their elements.\n    Args:\n        list1 (list): The first list of numbers.\n        list2 (list): The second list of numbers.\n        n (int): The number of largest products to find.\n    Returns:\n        list: A list of the n largest products.\n    \"\"\"\n    # Sort the lists in descending order\n    list1.sort(reverse=True)\n    list2.sort(reverse=True)\n    # Initialize the result list\n    result = []\n    # Iterate over"
    },
    {
        "original": "def maximum(a,b):   \r\n    if a >= b: \r\n        return a \r\n    else: \r\n        return b ",
        "sampled": "def maximum(a, b):\n    if a > b:\n        return a\n    else:\n        return b\n# Test cases\nassert maximum(5,10) == 10\nassert maximum(-1,-2) == -1\nassert maximum(9,7) == 9"
    },
    {
        "original": "def string_to_tuple(str1):\r\n    result = tuple(x for x in str1 if not x.isspace()) \r\n    return result",
        "sampled": "def string_to_tuple(s):\n    return tuple(s)"
    },
    {
        "original": "def set_left_most_unset_bit(n): \r\n    if not (n & (n + 1)): \r\n        return n \r\n    pos, temp, count = 0, n, 0 \r\n    while temp: \r\n        if not (temp & 1): \r\n            pos = count      \r\n        count += 1; temp>>=1\r\n    return (n | (1 << (pos))) ",
        "sampled": "def set_left_most_unset_bit(n):\n    # Initialize the leftmost unset bit to 1\n    left_most_unset_bit = 1\n    # Iterate through the bits of n\n    for i in range(32):\n        # Check if the current bit is set\n        if (n & left_most_unset_bit)!= 0:\n            # If it is, set the leftmost unset bit to the current bit\n            left_most_unset_bit = left_most_unset_bit << 1\n            break\n        else:\n            # If it is not, shift the"
    },
    {
        "original": "import math\r\ndef volume_cone(r,h):\r\n  volume = (1.0/3) * math.pi * r * r * h\r\n  return volume",
        "sampled": "The function should take two arguments: and h, where ver is the base of the cone and is the height. The function should return the volume of the cone in cubic units.\nHere's the code for the function:\n```python\nimport math\ndef volume_cone(ver, h):\n    = ver * math.sin(math.pi/3)\n    = ver * math.cos(math.pi/3)\n    = ver * math.tan(math.pi/3)\n    = ver * math.tan(math.pi/3"
    },
    {
        "original": "def pos_nos(list1):\r\n  for num in list1: \r\n    if num >= 0: \r\n       return num ",
        "sampled": "def pos_nos(lst):\n    \"\"\"\n    This function takes a list of numbers as input and returns the positive numbers in the list.\n    \"\"\"\n    pos_nums = []\n    for num in lst:\n        if num > 0:\n            pos_nums.append(num)\n    return pos_nums\n# Test cases\nassert pos_nos([-1,-2,1,2]) == 1,2\nassert pos_nos([3,4,-5]) == 3,4\nassert pos_nos([-2,-3,1]) == 1"
    },
    {
        "original": "def max_sum_rectangular_grid(grid, n) : \r\n\tincl = max(grid[0][0], grid[1][0]) \r\n\texcl = 0\r\n\tfor i in range(1, n) : \r\n\t\texcl_new = max(excl, incl) \r\n\t\tincl = excl + max(grid[0][i], grid[1][i]) \r\n\t\texcl = excl_new \r\n\treturn max(excl, incl)",
        "sampled": "def max_sum_rectangular_grid(grid, n):\n    # Initialize the maximum sum to be negative infinity\n    max_sum = float('-inf')\n    # Iterate through the of the grid\n    for i in range(n):\n        for j in range(n):\n            # Initialize the current sum to be the value of the current cell\n            current_sum = grid[i][j]\n            # Iterate through the of the grid\n            for k in range(n):\n                # If the current cell is not adjacent to the chosen cell, add its value to the current sum\n                if k!= j:"
    },
    {
        "original": "def find_Max_Len_Even(str): \r\n    n = len(str) \r\n    i = 0\r\n    currlen = 0\r\n    maxlen = 0\r\n    st = -1\r\n    while (i < n): \r\n        if (str[i] == ' '): \r\n            if (currlen % 2 == 0): \r\n                if (maxlen < currlen): \r\n                    maxlen = currlen \r\n                    st = i - currlen \r\n            currlen = 0 \r\n        else : \r\n            currlen += 1\r\n        i += 1\r\n    if (currlen % 2 == 0): \r\n        if (maxlen < currlen): \r\n            maxlen = currlen \r\n            st = i - currlen \r\n    if (st == -1): \r\n        return \"-1\" \r\n    return str[st: st + maxlen] ",
        "sampled": "def find_Max_Len_Even(sentence):\n    words = sentence.split()\n    max_len = -1\n    for word in words:\n        if len(word) % 2 == 0 and len(word) > max_len:\n            max_len = len(word)\n    if max_len == -1:\n        return \"-1\"\n    else:\n        return str(max_len)\n# Test cases\nassert find_Max_Len_Even(\"python language\") == \"language\"\nassert find_Max_Len_Even(\"maximum even length\") == \"length\""
    },
    {
        "original": "def find_last_occurrence(A, x):\r\n    (left, right) = (0, len(A) - 1)\r\n    result = -1\r\n    while left <= right:\r\n        mid = (left + right) // 2\r\n        if x == A[mid]:\r\n            result = mid\r\n            left = mid + 1\r\n        elif x < A[mid]:\r\n            right = mid - 1\r\n        else:\r\n            left = mid + 1\r\n    return result ",
        "sampled": ""
    },
    {
        "original": "from itertools import groupby\r\ndef modified_encode(alist):\r\n        def ctr_ele(el):\r\n            if len(el)>1: return [len(el), el[0]]\r\n            else: return el[0]\r\n        return [ctr_ele(list(group)) for key, group in groupby(alist)]",
        "sampled": "The function should take a list as input and return the modified run-length encoding. The modified run-length encoding is a list where each element is either a number or a list of two elements, where the first element is the number of times the element appears and the second element is the element itself.\nFor example, if the input is [1,1,2,3,4,4,5,1], the output should be [[2, 1], 2, 3, [2, 4], 5, 1].\nIf the input is 'automatically', the output"
    },
    {
        "original": "def max_volume (s): \r\n    maxvalue = 0\r\n    i = 1\r\n    for i in range(s - 1): \r\n        j = 1\r\n        for j in range(s): \r\n            k = s - i - j \r\n            maxvalue = max(maxvalue, i * j * k)         \r\n    return maxvalue ",
        "sampled": "def max_volume(sides):\n   _side = sides[0]\n   _side_squared = (sides[0] ** 2)\n   _side_cubed = (sides[0] ** 3)\n   _side_cubed_plus_four_sides = (sides[0] ** 3) + (sides[1] ** 3) + (sides[2] ** 3) + (sides[3] ** 3)\n   _side_cubed_plus_two_sides = (sides[0] ** 3) + ("
    },
    {
        "original": "import re\r\ndef find_long_word(text):\r\n  return (re.findall(r\"\\b\\w{5}\\b\", text))",
        "sampled": "def find_long_word(string):\n    import re\n    words = re.findall(r'\\b\\w{5,}\\b', string)\n    return words\n# Test cases\nassert find_long_word('Please move back to strem') == ['strem']\nassert find_long_word('4K Ultra HD streaming player') == ['Ultra']\nassert find_long_word('Streaming Media Player') == ['Media']"
    },
    {
        "original": "def sum_difference(n):\r\n    sumofsquares = 0\r\n    squareofsum = 0\r\n    for num in range(1, n+1):\r\n        sumofsquares += num * num\r\n        squareofsum += num\r\n    squareofsum = squareofsum ** 2\r\n    return squareofsum - sumofsquares",
        "sampled": "def sum_difference(n):\n    # Calculate the sum of squared first n natural numbers\n    sum_squared = sum([i**2 for i in range(1, n+1)])\n    # Calculate the squared sum of first n natural numbers\n    squared_sum = sum(range(1, n+1)**2)\n    # Calculate the difference between the two sums\n    difference = squared_sum - sum_squared\n    return difference\n# Test the function with the given test cases\nassert sum_difference(12)==5434\nassert sum_difference(20)==41230"
    },
    {
        "original": "def find_demlo(s): \r\n\tl = len(s) \r\n\tres = \"\" \r\n\tfor i in range(1,l+1): \r\n\t\tres = res + str(i) \r\n\tfor i in range(l-1,0,-1): \r\n\t\tres = res + str(i) \r\n\treturn res \t",
        "sampled": "def find_demlo(num):\n    \"\"\"\n    This function takes a string as input and returns the Demlo number for that string.\n    \"\"\"\n    # Convert the string to a list of digits\n    digits = list(map(int, list(num)))\n    # Initialize the number to 0\n   _num = 0\n    # Iterate over the digits in reverse order\n    for digit in digits[::-1]:\n        # Multiply the current digit by the number\n        new_num = digit *_num\n        # Add the new number to the number\n        if new_num > 9:"
    },
    {
        "original": "def position_min(list1):\r\n    min_val = min(list1)\r\n    min_result = [i for i, j in enumerate(list1) if j == min_val]\r\n    return min_result",
        "sampled": "def position_min(lst):\n    min_val = lst[0]\n    min_pos = 0\n    for i in range(1,len(lst)):\n        if lst[i] < min_val:\n            min_val = lst[i]\n            min_pos = i\n    return [min_pos]\n# Test cases\nassert position_min([12,33,23,10,67,89,45,667,23,12,11,10,54])==[3,11]"
    },
    {
        "original": "def right_rotate(arr, n, out_of_place, cur):\r\n\ttemp = arr[cur]\r\n\tfor i in range(cur, out_of_place, -1):\r\n\t\tarr[i] = arr[i - 1]\r\n\tarr[out_of_place] = temp\r\n\treturn arr\r\ndef re_arrange(arr, n):\r\n\tout_of_place = -1\r\n\tfor index in range(n):\r\n\t\tif (out_of_place >= 0):\r\n\t\t\tif ((arr[index] >= 0 and arr[out_of_place] < 0) or\r\n\t\t\t(arr[index] < 0 and arr[out_of_place] >= 0)):\r\n\t\t\t\tarr = right_rotate(arr, n, out_of_place, index)\r\n\t\t\t\tif (index-out_of_place > 2):\r\n\t\t\t\t\tout_of_place += 2\r\n\t\t\t\telse:\r\n\t\t\t\t\tout_of_place = - 1\r\n\t\tif (out_of_place == -1):\r\n\t\t\tif ((arr[index] >= 0 and index % 2 == 0) or\r\n\t\t\t (arr[index] < 0 and index % 2 == 1)):\r\n\t\t\t\tout_of_place = index\r\n\treturn arr",
        "sampled": "def re_arrange(arr, n):\n    # Initialize two pointers, one for positive and one for negative\n    pos = 0\n    neg = n - 1\n    # Iterate through the array\n    for i in range(n):\n        # If the current element is positive, swap it with the next positive element\n        if arr[i] > 0:\n            arr[i], arr[pos] = arr[pos], arr[i]\n            pos += 1\n        # If the current element is negative, swap it with the next negative element\n        elif arr[i] < 0:\n            arr[i"
    },
    {
        "original": "def sum_of_alternates(test_tuple):\r\n  sum1 = 0\r\n  sum2 = 0\r\n  for idx, ele in enumerate(test_tuple):\r\n    if idx % 2:\r\n      sum1 += ele\r\n    else:\r\n      sum2 += ele\r\n  return ((sum1),(sum2)) ",
        "sampled": "The function should take a tuple as input and return a tuple containing the sum of the alternate chains of the tuple. The alternate chains are defined as thele oflelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelelele http://en.wikipedia.org/wiki/Tuple_(computer"
    },
    {
        "original": "def get_Min_Squares(n):\r\n    if n <= 3:\r\n        return n;\r\n    res = n \r\n    for x in range(1,n + 1):\r\n        temp = x * x;\r\n        if temp > n:\r\n            break\r\n        else:\r\n            res = min(res,1 + get_Min_Squares(n  - temp)) \r\n    return res;",
        "sampled": "def get_Min_Squares(num):\n    # Initialize variables\n    squares = []\n    min_squares = float('inf')\n    # Generate squares\n    for i in range(1, num+1):\n        squares.append(i*i)\n    # Sort squares in ascending order\n    squares.sort()\n    # Find minimum number of squares\n    for i in range(len(squares)):\n        if squares[i] + squares[i+1] == num:\n            min_squares = min(min_squares, i+1)\n    return min_squares\n# Test cases\nassert get_Min"
    },
    {
        "original": "from collections import defaultdict \r\n\r\ndef most_occurrences(test_list):\r\n  temp = defaultdict(int)\r\n  for sub in test_list:\r\n    for wrd in sub.split():\r\n      temp[wrd] += 1\r\n  res = max(temp, key=temp.get)\r\n  return (str(res)) ",
        "sampled": ""
    },
    {
        "original": "def check_isosceles(x,y,z):\r\n  if x==y or y==z or z==x:\r\n\t   return True\r\n  else:\r\n     return False",
        "sampled": "def check_isosceles(a,b,c):\n    if a+b>c and a+c>b and b+c>a:\n        return True\n    else:\n        return False\n# Test cases\nprint(check_isosceles(6,8,12)) # False\nprint(check_isosceles(6,6,12)) # True\nprint(check_isosceles(6,16,20)) # False"
    },
    {
        "original": "def rotate_left(list1,m,n):\r\n  result =  list1[m:]+list1[:n]\r\n  return result",
        "sampled": "def rotate_left(lst, n, k):\n    \"\"\"\n    Rotate a list by n items to the left and k items to the right.\n    \"\"\"\n    if n == 0:\n        return lst[k:] + lst[:k]\n    elif n > 0:\n        return lst[-k:] + lst[:-k]\n    else:\n        return lst[:-k] + lst[-k:]\n# Test cases\nassert rotate_left([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 3, "
    },
    {
        "original": "def neg_count(list):\r\n  neg_count= 0\r\n  for num in list: \r\n    if num <= 0: \r\n      neg_count += 1\r\n  return neg_count ",
        "sampled": "def neg_count(lst):\n    count = 0\n    for num in lst:\n        if num < 0:\n            count += 1\n    return count\n# Test cases\nassert neg_count([-1,-2,3,-4,-5]) == 4\nassert neg_count([1,2,3]) == 0\nassert neg_count([1,2,-3,-10,20]) == 2"
    },
    {
        "original": "import re\r\ndef find_char(text):\r\n  return (re.findall(r\"\\b\\w{3,5}\\b\", text))",
        "sampled": "def find_char(string):\n    import re\n    pattern = r'\\b\\w{3,5}\\b'\n    matches = re.findall(pattern, string)\n    return matches\n# Test cases\nassert find_char('For the four consumer complaints contact manager AKR reddy') == ['For', 'the', 'four', 'AKR','reddy']\nassert find_char('Certain service are subject to change MSR') == ['are', 'MSR']\nassert find_char('Third party legal desclaimers') == ['Third', 'party', 'legal"
    },
    {
        "original": "def count_unset_bits(n): \r\n    count = 0\r\n    x = 1\r\n    while(x < n + 1): \r\n        if ((x & n) == 0): \r\n            count += 1\r\n        x = x << 1\r\n    return count  ",
        "sampled": "def count_unset_bits(n):\n    count = 0\n    while n:\n        count += n & 1\n        n >>= 1\n    return count\n# Test cases\nassert count_unset_bits(2) == 1\nassert count_unset_bits(4) == 2\nassert count_unset_bits(6) == 1"
    },
    {
        "original": "def char_frequency(str1):\r\n    dict = {}\r\n    for n in str1:\r\n        keys = dict.keys()\r\n        if n in keys:\r\n            dict[n] += 1\r\n        else:\r\n            dict[n] = 1\r\n    return dict",
        "sampled": "def char_frequency(string):\n    freq = {}\n    for char in string:\n        if char in freq:\n            freq[char] += 1\n        else:\n            freq[char] = 1\n    return freq\n# Test cases\nassert char_frequency('python')=={'p': 1, 'y': 1, 't': 1, 'h': 1, 'o': 1, 'n': 1}\nassert char_frequency('program')=={'p': 1, 'r': 2, 'o': 1, 'g': 1"
    },
    {
        "original": "def Sort(sub_li): \r\n    sub_li.sort(key = lambda x: x[1]) \r\n    return sub_li ",
        "sampled": "def Sort(lst):\n    return sorted(lst, key=lambda x: x[1])\n# Test cases\nprint(Sort([['a', 10], ['b', 5], ['c', 20], ['d', 15]]))\nprint(Sort([['452', 10], ['256', 5], ['100', 20], ['135', 15]]))\nprint(Sort([['rishi', 10], ['akhil', 5], ['ramya', 20], ['"
    },
    {
        "original": "def check_Validity(a,b,c):  \r\n    if (a + b <= c) or (a + c <= b) or (b + c <= a) : \r\n        return False\r\n    else: \r\n        return True        ",
        "sampled": "def check_Validity(a,b,c):\n    if a+b>c and a+c>b and b+c>a:\n        return True\n    else:\n        return False"
    },
    {
        "original": "def ap_sum(a,n,d):\r\n  total = (n * (2 * a + (n - 1) * d)) / 2\r\n  return total",
        "sampled": "def ap_sum(a, b, n):\n    \"\"\"\n    Returns the sum of the arithmetic progression of a to b with n terms.\n    \"\"\"\n    return (b - a) * n // 2 + a"
    },
    {
        "original": "def check_monthnum(monthname1):\r\n  if monthname1 == \"February\":\r\n    return True\r\n  else:\r\n    return False",
        "sampled": ""
    },
    {
        "original": "import re\r\ndef text_match_word(text):\r\n        patterns = '\\w+\\S*$'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return 'Not matched!'",
        "sampled": "def text_match_word(text, punctuation='.'):\n    if text.endswith(punctuation):\n        return f'Found a match! {text}'\n    else:\n        return 'Not matched!'\n# Test cases\nassert text_match_word(\"python.\")==('Found a match! python.')\nassert text_match_word(\"python.\")==('Found a match! python.')\nassert text_match_word(\"  lang .\")==('Not matched!')"
    },
    {
        "original": "def check_Equality(s): \r\n    return (ord(s[0]) == ord(s[len(s) - 1])); \r\ndef count_Substring_With_Equal_Ends(s): \r\n    result = 0; \r\n    n = len(s); \r\n    for i in range(n):\r\n        for j in range(1,n-i+1): \r\n            if (check_Equality(s[i:i+j])): \r\n                result+=1; \r\n    return result; ",
        "sampled": "def count_Substring_With_Equal_Ends(s):\n    count = 0\n    for i in range(len(s)):\n        for j in range(i+1, len(s)+1):\n            if s[i] == s[j-1]:\n                count += 1\n    return count\n# Test cases\nassert count_Substring_With_Equal_Ends('aba') == 4\nassert count_Substring_With_Equal_Ends('abcab') == 7\nassert count_Substring_With_Equal_Ends('abc') == 3"
    },
    {
        "original": "def find_Divisor(x,y):  \r\n    if (x==y): \r\n        return y \r\n    return 2",
        "sampled": "def find_Divisor(start, end):\n    max_divisor = 1\n    for i in range(start, end+1):\n        if i % 2 == 0:\n            continue\n        for j in range(3, int(i**0.5)+1, 2):\n            if i % j == 0:\n                max_divisor = max(max_divisor, j)\n                break\n    return max_divisor\n# Test cases\nassert find_Divisor(2,2) == 2\nassert find_Divisor(2,5) == "
    },
    {
        "original": "def sum_three_smallest_nums(lst):\r\n\treturn sum(sorted([x for x in lst if x > 0])[:3])",
        "sampled": "def sum_three_smallest_nums(nums):\n    nums.sort()\n    return nums[0] + nums[1] + nums[2]\n# Test cases\nassert sum_three_smallest_nums([10,20,30,40,50,60,7]) == 37\nassert sum_three_smallest_nums([1,2,3,4,5]) == 6\nassert sum_three_smallest_nums([0,1,2,3,4,5]) == 6"
    },
    {
        "original": "def set_to_tuple(s):\r\n  t = tuple(sorted(s))\r\n  return (t)",
        "sampled": "def set_to_tuple(set_obj):\n    return tuple(sorted(set_obj))\n# Test cases\nassert set_to_tuple({1, 2, 3, 4, 5}) == (1, 2, 3, 4, 5)\nassert set_to_tuple({6, 7, 8, 9, 10, 11}) == (6, 7, 8, 9, 10, 11)\nassert set_to_tuple({12, 13,"
    },
    {
        "original": "from heapq import heappop, heappush\r\nclass Node:\r\n    def __init__(self, value, list_num, index):\r\n        self.value = value\r\n        self.list_num = list_num\r\n        self.index = index\r\n    def __lt__(self, other):\r\n        return self.value < other.value\r\ndef find_minimum_range(list):\r\n    high = float('-inf')\r\n    p = (0, float('inf'))\r\n    pq = []\r\n    for i in range(len(list)):\r\n        heappush(pq, Node(list[i][0], i, 0))\r\n        high = max(high, list[i][0])\r\n    while True:\r\n        top = heappop(pq)\r\n        low = top.value\r\n        i = top.list_num\r\n        j = top.index\r\n        if high - low < p[1] - p[0]:\r\n            p = (low, high)\r\n        if j == len(list[i]) - 1:\r\n            return p\r\n        heappush(pq, Node(list[i][j + 1], i, j + 1))\r\n        high = max(high, list[i][j + 1])",
        "sampled": " */\n        def find_minimum_range(arrays):\n           _min =_max =_sum =_count =_min_index =_max_index =_sum_index =_count_index =_min_sum =_max_sum =_sum_sum =_count_sum =_min_count =_max_count = 0\n           _min_sum =_max_sum =_sum_sum =_count_sum =_min_count =_max_count ="
    },
    {
        "original": "def dig_let(s):\r\n d=l=0\r\n for c in s:\r\n    if c.isdigit():\r\n        d=d+1\r\n    elif c.isalpha():\r\n        l=l+1\r\n    else:\r\n        pass\r\n return (l,d)",
        "sampled": "def dig_let(s):\n    \"\"\"\n    This function takes a string as input and returns a tuple containing the number of digits and letters in the string.\n    \"\"\"\n    count_digits = 0\n    count_letters = 0\n    for char in s:\n        if char.isdigit():\n            count_digits += 1\n        elif char.isalpha():\n            count_letters += 1\n    return count_digits, count_letters"
    },
    {
        "original": "def count_Odd_Squares(n,m): \r\n    return int(m**0.5) - int((n-1)**0.5) ",
        "sampled": "def count_Odd_Squares(start, end):\n    count = 0\n    for i in range(start, end+1):\n        if sum(int(digit)**2 for digit in str(i)) % 2!= 0:\n            count += 1\n    return count\n# Test cases\nassert count_Odd_Squares(5,100) == 8\nassert count_Odd_Squares(8,65) == 6\nassert count_Odd_Squares(2,5) == 1"
    },
    {
        "original": "def diff_consecutivenums(nums):\r\n    result = [b-a for a, b in zip(nums[:-1], nums[1:])]\r\n    return result",
        "sampled": "def diff_consecutivenums(lst):\n    diff_lst = []\n    for i in range(len(lst)-1):\n        diff_lst.append(lst[i+1]-lst[i])\n    return diff_lst\n# Test cases\nprint(diff_consecutivenums([1, 1, 3, 4, 4, 5, 6, 7]))\nprint(diff_consecutivenums([4, 5, 8, 9, 6, 10]))\nprint(diff_consecut"
    },
    {
        "original": "def zigzag(n, k): \r\n\tif (n == 0 and k == 0): \r\n\t\treturn 1\r\n\tif (k == 0): \r\n\t\treturn 0\r\n\treturn zigzag(n, k - 1) + zigzag(n - 1, n - k)",
        "sampled": "def zigzag(n, k):\n    # Write your code here\n    = [1] * n\n   [0] = 0\n   [n-1] = 0\n   [n//2] = 1\n   [n//2-1] = 1\n    for i in range(n//2-1, -1, -1):\n        if i == n//2-1:\n            continue\n        if i == n//2:\n            continue\n        if i == n//2+1:\n            continue\n        if i == n-1:\n            continue"
    },
    {
        "original": "def count_Squares(m,n): \r\n    if (n < m): \r\n        temp = m \r\n        m = n \r\n        n = temp \r\n    return n * (n + 1) * (3 * m - n + 1) // 6",
        "sampled": "def count_Squares(width, height):\n    return width * height * 4\n# Test cases\nassert count_Squares(4,3) == 20\nassert count_Squares(1,2) == 2\nassert count_Squares(2,2) == 5"
    },
    {
        "original": "def bin_coff(n, r): \r\n\tval = 1\r\n\tif (r > (n - r)): \r\n\t\tr = (n - r) \r\n\tfor i in range(0, r): \r\n\t\tval *= (n - i) \r\n\t\tval //= (i + 1) \r\n\treturn val \r\ndef find_ways(M): \r\n\tn = M // 2\r\n\ta = bin_coff(2 * n, n) \r\n\tb = a // (n + 1) \r\n\treturn (b) ",
        "sampled": "def find_ways(n):\n    def helper(prefix_sum, curr_seq, curr_len):\n        if curr_len == n:\n            return 1\n        if curr_len > n:\n            return 0\n        if prefix_sum < 0:\n            return 0\n        if prefix_sum == 0:\n            return helper(0, curr_seq + 1, curr_len + 1)\n        return helper(prefix_sum - values[curr_seq], curr_seq, curr_len)\n    values = list(range(1, n + 1))\n    return"
    },
    {
        "original": "def check(string) :\r\n    p = set(string) \r\n    s = {'0', '1'} \r\n    if s == p or p == {'0'} or p == {'1'}: \r\n        return (\"Yes\") \r\n    else : \r\n        return (\"No\") ",
        "sampled": "def check(binary_string):\n    if len(binary_string) % 8!= 0:\n        return \"No\"\n    for i in range(len(binary_string)):\n        if binary_string[i] not in \"01\":\n            return \"No\"\n    return \"Yes\"\n# Test cases\nassert check(\"01010101010\") == \"Yes\"\nassert check(\"name0\") == \"No\"\nassert check(\"101\") == \"Yes\""
    },
    {
        "original": "def minimum_Length(s) : \r\n    maxOcc = 0\r\n    n = len(s) \r\n    arr = [0]*26\r\n    for i in range(n) : \r\n        arr[ord(s[i]) -ord('a')] += 1\r\n    for i in range(26) : \r\n        if arr[i] > maxOcc : \r\n            maxOcc = arr[i] \r\n    return n - maxOcc ",
        "sampled": "def minimum_Length(s):\n    # create a dictionary to store the frequency of each character\n    freq = {}\n    for c in s:\n        freq[c] = freq.get(c, 0) + 1\n    # find the character with the minimum frequency\n    min_char = min(freq, key=freq.get)\n    # remove all occurrences of the minimum character\n    s = ''.join([c for c in s if c!= min_char])\n    # return the length of the string after removing the minimum character\n    return len(s)\n# Test cases\nassert minimum_Length"
    },
    {
        "original": "def first_Element(arr,n,k): \r\n    count_map = {}; \r\n    for i in range(0, n): \r\n        if(arr[i] in count_map.keys()): \r\n            count_map[arr[i]] += 1\r\n        else: \r\n            count_map[arr[i]] = 1\r\n        i += 1\r\n    for i in range(0, n):  \r\n        if (count_map[arr[i]] == k): \r\n            return arr[i] \r\n        i += 1 \r\n    return -1",
        "sampled": "def first_Element(arr, k, n):\n    count = 0\n    for i in arr:\n        if arr.count(i) == k:\n            count += 1\n            if count == n:\n                return i\n    return -1\n# Test cases\nassert first_Element([0,1,2,3,4,5],6,1) == 0\nassert first_Element([1,2,1,3,4],5,2) == 1\nassert first_Element([2,3,4,3,5,7,1,2,3"
    },
    {
        "original": "def unique_Characters(str):\r\n    for i in range(len(str)):\r\n        for j in range(i + 1,len(str)): \r\n            if (str[i] == str[j]):\r\n                return False;\r\n    return True;",
        "sampled": ""
    },
    {
        "original": "def remove_column(list1, n):\r\n   for i in list1: \r\n    del i[n] \r\n   return list1",
        "sampled": "def remove_column(nested_list, column_index):\n    \"\"\"\n    Remove a specified column from a given nested list.\n    Args:\n        nested_list (list): A nested list.\n        column_index (int): The index of the column to remove.\n    Returns:\n        list: The nested list with the specified column removed.\n    \"\"\"\n    # Create a new list to store the new nested list\n    new_list = []\n    # Loop through each row in the nested list\n    for row in nested_list:\n        # Create a new row to store the new values\n        new_row = []\n        #"
    },
    {
        "original": "def tn_ap(a,n,d):\r\n  tn = a + (n - 1) * d\r\n  return tn",
        "sampled": "def tn_ap(n,a,b):\n    return (a*n + b)/(1-1/a)**n\n# Test cases\nassert tn_ap(1,5,2)==9\nassert tn_ap(2,6,4)==22\nassert tn_ap(1,4,5)==16"
    },
    {
        "original": "def count_Rectangles(radius):  \r\n    rectangles = 0 \r\n    diameter = 2 * radius \r\n    diameterSquare = diameter * diameter \r\n    for a in range(1, 2 * radius):  \r\n        for b in range(1, 2 * radius): \r\n            diagnalLengthSquare = (a * a +  b * b)  \r\n            if (diagnalLengthSquare <= diameterSquare) : \r\n                rectangles += 1\r\n    return rectangles ",
        "sampled": "def count_Rectangles(r):\n    = 3.14159265358979323846\n   _squared = r**2\n   _cubed = r**3\n   _squared_plus_cubed = 4*r**2 + 9*r**3\n   _squared_plus_cubed_plus_pi = 4*r**2 + 9*r**3 + 3*3.14159265358979323846"
    },
    {
        "original": "def find_angle(a,b):\r\n c = 180 - (a + b)\r\n return c\r\n",
        "sampled": "The function should take two arguments, the length of the hypotenuse and the angle opposite the hypotenuse. It should return the angle opposite the hypotenuse.\nHere's a possible implementation:\n```python\nimport math\ndef find_angle(a, b):\n    c = math.sqrt(a**2 + b**2)\n    angle = math.degrees(math.acos((a**2 + b**2 - c**2) / (2 * a * b)))\n    return 180 - angle\n```\nThis implementation uses the Pyth"
    },
    {
        "original": "def find_max(test_list):\r\n  res = max(int(j) for i in test_list for j in i)\r\n  return (res) ",
        "sampled": "Here's the function you need to implement:\ndef find_max(records):\n    # Initialize the maximum value to be the first element of the first record\n    max_value = records[0][0]\n    # Iterate over the remaining records\n    for record in records[1:]:\n        # If the current record's first element is greater than the current maximum value, update the maximum value\n        if record[0] > max_value:\n            max_value = record[0]\n    return max_value\n# Test cases\nassert find_max([(2, 4), (6, 7"
    },
    {
        "original": "def moddiv_list(nums1,nums2):\r\n  result = map(lambda x, y: x % y, nums1, nums2)\r\n  return list(result)",
        "sampled": "def moddiv_list(a, b):\n    return list(map(lambda x: x % b, a))\n# Test cases\nassert moddiv_list([4,5,6],[1, 2, 3])==[0, 1, 0]\nassert moddiv_list([3,2],[1,4])==[0, 2]\nassert moddiv_list([90,120],[50,70])==[40, 50]"
    },
    {
        "original": "def Check_Solution(a,b,c): \r\n    if (2*b*b == 9*a*c): \r\n        return (\"Yes\"); \r\n    else: \r\n        return (\"No\"); ",
        "sampled": "def Check_Solution(a, b, c):\n    discriminant = b**2 - 4*a*c\n    if discriminant < 0:\n        return \"No\"\n    elif discriminant == 0:\n        return \"Yes\"\n    else:\n        x1 = (-b + discriminant**0.5)/(2*a)\n        x2 = (-b - discriminant**0.5)/(2*a)\n        if x1**2 == 2*x2:\n            return \"Yes\"\n        else:\n            return \"No\""
    },
    {
        "original": "def get_carol(n): \r\n\tresult = (2**n) - 1\r\n\treturn result * result - 2",
        "sampled": "def get_carol(n):\n    \"\"\"\n    Returns the n\u2019th carol number.\n    \"\"\"\n    carol_numbers = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27,"
    },
    {
        "original": "def remove_empty(list1):\r\n  remove_empty = [x for x in list1 if x]\r\n  return remove_empty",
        "sampled": "def remove_empty(lst):\n    return [item for sublist in lst for item in sublist if item]\n# Test cases\nassert remove_empty([[], [], [], 'Red', 'Green', [1,2], 'Blue', [], []])==['Red', 'Green', [1, 2], 'Blue']\nassert remove_empty([[], [], [],[],[], 'Green', [1,2], 'Blue', [], []])==[ 'Green', [1, 2], 'Blue']\nassert remove_empty([[], [], [], 'Python',[],[], 'programming',"
    },
    {
        "original": "def max_occurrences(nums):\r\n    max_val = 0\r\n    result = nums[0] \r\n    for i in nums:\r\n        occu = nums.count(i)\r\n        if occu > max_val:\r\n            max_val = occu\r\n            result = i \r\n    return result",
        "sampled": "def max_occurrences(lst):\n    \"\"\"\n    Returns the item with the maximum occurrences in the given list.\n    \"\"\"\n    # Create a dictionary to store the count of each item in the list\n    count_dict = {}\n    for item in lst:\n        if item in count_dict:\n            count_dict[item] += 1\n        else:\n            count_dict[item] = 1\n    # Find the item with the maximum count\n    max_count = 0\n    max_item = None\n    for item, count in count_dict.items():\n        if count > max_count:\n            max"
    },
    {
        "original": "def add_K_element(test_list, K):\r\n  res = [tuple(j + K for j in sub ) for sub in test_list]\r\n  return (res) ",
        "sampled": "27, 28)]\nassert add_K_element([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 0) == [(1, 2, 3), (4, 5, 6), (7, 8, 9)]\nassert add_K_element([], 4) == []\nassert add_K_element([(1, 2, 3), (4, 5, 6), (7, 8, 9)], 10) == [(11,"
    },
    {
        "original": "def make_flip(ch): \r\n\treturn '1' if (ch == '0') else '0'\r\ndef get_flip_with_starting_charcter(str, expected): \r\n\tflip_count = 0\r\n\tfor i in range(len( str)): \r\n\t\tif (str[i] != expected): \r\n\t\t\tflip_count += 1\r\n\t\texpected = make_flip(expected) \r\n\treturn flip_count \r\ndef min_flip_to_make_string_alternate(str): \r\n\treturn min(get_flip_with_starting_charcter(str, '0'),get_flip_with_starting_charcter(str, '1')) ",
        "sampled": "def min_flip_to_make_string_alternate(binary_string):\n    # Initialize variables\n    count = 0\n    prev_bit = binary_string[0]\n    for bit in binary_string[1:]:\n        if bit == prev_bit:\n            count += 1\n        else:\n            count = 1\n        prev_bit = bit\n    return count\n# Test cases\nassert min_flip_to_make_string_alternate(\"0001010111\") == 2\nassert min_flip_to_make_string_alternate(\"00"
    },
    {
        "original": "def count_Digit(n):\r\n    count = 0\r\n    while n != 0:\r\n        n //= 10\r\n        count += 1\r\n    return count",
        "sampled": "def count_Digit(num):\n    count = 0\n    while num > 0:\n        count += 1\n        num //= 10\n    return count\n# Test cases\nassert count_Digit(12345) == 5\nassert count_Digit(11223305) == 8\nassert count_Digit(4123459) == 7"
    },
    {
        "original": "def adjacent_num_product(list_nums):\r\n    return max(a*b for a, b in zip(list_nums, list_nums[1:]))",
        "sampled": "def adjacent_num_product(lst):\n    max_product = float('-inf')\n    for i in range(len(lst)-1):\n        max_product = max(max_product, lst[i]*lst[i+1])\n    return max_product\n# Test cases\nassert adjacent_num_product([1,2,3,4,5,6]) == 30\nassert adjacent_num_product([1,2,3,4,5]) == 20\nassert adjacent_num_product([2,3]) == 6"
    },
    {
        "original": "class Node: \r\n\tdef __init__(self, data): \r\n\t\tself.data = data \r\n\t\tself.left = None\r\n\t\tself.right = None\r\ndef get_height(root): \r\n\tif root is None: \r\n\t\treturn 0\r\n\treturn max(get_height(root.left), get_height(root.right)) + 1\r\ndef is_tree_balanced(root): \r\n\tif root is None: \r\n\t\treturn True\r\n\tlh = get_height(root.left) \r\n\trh = get_height(root.right) \r\n\tif (abs(lh - rh) <= 1) and is_tree_balanced( \r\n\troot.left) is True and is_tree_balanced( root.right) is True: \r\n\t\treturn True\r\n\treturn False",
        "sampled": "# Test case for a balanced binary tree\nclass TreeNode:\n    def __init__(self, val=0, left=None, right=None):\n        self.val = val\n        self.left = left\n        self.right = right\nroot1 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7)))\n# Test case for an unbalanced binary tree\nroot2 = TreeNode(1, TreeNode(2, TreeNode(4), TreeNode(5)), TreeNode(3, TreeNode(6), TreeNode(7, TreeNode"
    },
    {
        "original": "def repeat_tuples(test_tup, N):\r\n  res = ((test_tup, ) * N)\r\n  return (res) ",
        "sampled": "def repeat_tuples(tup, n):\n    \"\"\"\n    Repeats the given tuple n times.\n    \"\"\"\n    return tuple(tup for _ in range(n))\n# Test cases\nassert repeat_tuples((1, 3), 4) == ((1, 3), (1, 3), (1, 3), (1, 3))\nassert repeat_tuples((1, 2), 3) == ((1, 2), (1, 2), (1, 2))\nassert repeat_tuples((3, 4), 5) =="
    },
    {
        "original": "def lateralsurface_cuboid(l,w,h):\r\n  LSA = 2*h*(l+w)\r\n  return LSA",
        "sampled": "Here's the code:\ndef lateralsurface_cuboid(length, width, height):\n    area = 2 * (length * width + width * height + height * length)\n    surface_area = 2 * (length * width + width * height + height * length)\n    return surface_area\n# Test cases\nassert lateralsurface_cuboid(8,5,6)==156\nassert lateralsurface_cuboid(7,9,10)==320\nassert lateralsurface_cuboid(10,20,3"
    },
    {
        "original": "def float_sort(price):\r\n  float_sort=sorted(price, key=lambda x: float(x[1]), reverse=True)\r\n  return float_sort",
        "sampled": "            Note: The input tuple should be a list of tuples, where each tuple contains a string and a float. The function should return a sorted list of tuples, where the float elements are sorted in ascending order."
    },
    {
        "original": "def smallest_missing(A, left_element, right_element):\r\n    if left_element > right_element:\r\n        return left_element\r\n    mid = left_element + (right_element - left_element) // 2\r\n    if A[mid] == mid:\r\n        return smallest_missing(A, mid + 1, right_element)\r\n    else:\r\n        return smallest_missing(A, left_element, mid - 1)",
        "sampled": "def smallest_missing(arr, start, end):\n    \"\"\"\n    Finds the smallest missing element in a sorted array.\n    \"\"\"\n    if start > end:\n        return None\n    mid = (start + end) // 2\n    if arr[mid] == mid:\n        return smallest_missing(arr, start, mid - 1)\n    elif arr[mid] > mid:\n        return smallest_missing(arr, mid + 1, end)\n    else:\n        return smallest_missing(arr, start, mid - 1)\n# Test cases\nassert smallest_missing([0, 1"
    },
    {
        "original": "import heapq as hq\r\ndef heap_assending(nums):\r\n  hq.heapify(nums)\r\n  s_result = [hq.heappop(nums) for i in range(len(nums))]\r\n  return s_result",
        "sampled": " 6, 7, 8, 9]\nassert heap_assending([1, 2, 3, 4, 5, 6, 7, 8, 9, 0])==[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\nassert heap_assending([1, 2, 3, 4, 5, 6, 7, 8, 9, 0])==[0, 1, 2, 3,"
    },
    {
        "original": "def volume_cuboid(l,w,h):\r\n  volume=l*w*h\r\n  return volume",
        "sampled": "The function should take three arguments:, le, and ri, where is the length of the face, le is the length of the left face, and ri is the length of the right face. The function should return the volume of the cuboid.\nHere's a possible implementation:\n```python\ndef volume_cuboid(ver, hor,):\n    return ver * hor * ver\n```\nThis implementation uses the formula for the volume of a cuboid: * hor * ver. The function takes three arguments, ver, hor, and ver, and returns the volume of"
    },
    {
        "original": "def permute_string(str):\r\n    if len(str) == 0:\r\n        return ['']\r\n    prev_list = permute_string(str[1:len(str)])\r\n    next_list = []\r\n    for i in range(0,len(prev_list)):\r\n        for j in range(0,len(str)):\r\n            new_str = prev_list[i][0:j]+str[0]+prev_list[i][j:len(str)-1]\r\n            if new_str not in next_list:\r\n                next_list.append(new_str)\r\n    return next_list",
        "sampled": "def permute_string(s):\n    if len(s) == 0:\n        return []\n    if len(s) == 1:\n        return [s]\n    result = []\n    for i in range(len(s)):\n        rest = s[:i] + s[i+1:]\n        for p in permute_string(rest):\n            result.append(s[i] + p)\n    return result\n# Test cases\nassert permute_string('ab') == ['ab', 'ba']\nassert permute_string('abc') == ['abc', 'bac',"
    },
    {
        "original": "def round_num(n,m):\r\n    a = (n //m) * m\r\n    b = a + m\r\n    return (b if n - a > b - n else a)",
        "sampled": "def round_num(num, multiple):\n    \"\"\"\n    Rounds the given number to the nearest multiple of a specific number.\n    Args:\n        num (int): The number to be rounded.\n        multiple (int): The multiple to round the number to.\n    Returns:\n        int: The rounded number.\n    \"\"\"\n    return round(num/multiple)*multiple"
    },
    {
        "original": "def remove_replica(test_tup):\r\n  temp = set()\r\n  res = tuple(ele if ele not in temp and not temp.add(ele) \r\n\t\t\t\telse 'MSP' for ele in test_tup)\r\n  return (res)",
        "sampled": "Here's the function you need to implement:\ndef remove_replica(lst):\n    # Create a dictionary to store the count of each element in the list\n    count_dict = {}\n    for elem in lst:\n        if elem in count_dict:\n            count_dict[elem] += 1\n        else:\n            count_dict[elem] = 1\n    # Create a list to store the unique elements\n    unique_lst = []\n    # Iterate through the dictionary and add unique elements to the list\n    for elem, count in count_dict.items():\n        if count == 1:\n            unique_"
    },
    {
        "original": "def remove_Char(s,c) :  \r\n    counts = s.count(c) \r\n    s = list(s) \r\n    while counts :  \r\n        s.remove(c) \r\n        counts -= 1 \r\n    s = '' . join(s)   \r\n    return (s) ",
        "sampled": "def remove_Char(string, char):\n    return string.replace(char, \"\")\n# Test cases\nassert remove_Char(\"aba\",'a') == \"b\"\nassert remove_Char(\"toggle\",'g') == \"tole\"\nassert remove_Char(\"aabbc\",'b') == \"aac\""
    },
    {
        "original": "def move_first(test_list):\r\n  test_list = test_list[-1:] + test_list[:-1]  \r\n  return test_list",
        "sampled": "def move_first(lst):\n    lst.pop()\n    lst.insert(0, lst.pop())\n    return lst\n# Test cases\nassert move_first([1,2,3,4]) == [4,1,2,3]\nassert move_first([0,1,2,3]) == [3,0,1,2]\nassert move_first([9,8,7,1]) == [1,9,8,7]"
    },
    {
        "original": "def surfacearea_cuboid(l,w,h):\r\n  SA = 2*(l*w + l * h + w * h)\r\n  return SA",
        "sampled": "The function should take three arguments:, le, and te, where, le, and te are the lengths of the, left, and top edges, respectively. The function should return the surface area of the cuboid.\nThe surface area of a cuboid is the sum of the areas of its six faces, which are the, le, and te faces, as well as the,,,,, and faces. The, le, and te faces are all rectangles with le sides, while the,,,,"
    },
    {
        "original": "def multi_list(rownum,colnum):\r\n  multi_list = [[0 for col in range(colnum)] for row in range(rownum)]\r\n  for row in range(rownum):\r\n    for col in range(colnum):\r\n        multi_list[row][col]= row*col\r\n  return multi_list\r\n",
        "sampled": "0, 0, 0, 0], [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15], [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30], [0, "
    },
    {
        "original": "from operator import itemgetter\r\ndef index_on_inner_list(list_data, index_no):\r\n    result = sorted(list_data, key=itemgetter(index_no))\r\n    return result",
        "sampled": "91, 94), ('Brady Kent', 97, 96), ('Greyson Fulton', 98, 99), ('Beau Turnbull', 94, 98)]\nassert index_on_inner_list([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)],2)==[('Greyson F"
    },
    {
        "original": "def find_rotation_count(A):\r\n    (left, right) = (0, len(A) - 1)\r\n    while left <= right:\r\n        if A[left] <= A[right]:\r\n            return left\r\n        mid = (left + right) // 2\r\n        next = (mid + 1) % len(A)\r\n        prev = (mid - 1 + len(A)) % len(A)\r\n        if A[mid] <= A[next] and A[mid] <= A[prev]:\r\n            return mid\r\n        elif A[mid] <= A[right]:\r\n            right = mid - 1\r\n        elif A[mid] >= A[left]:\r\n            left = mid + 1\r\n    return -1",
        "sampled": "def find_rotation_count(arr):\n    n = len(arr)\n    = arr[0]\n    = arr[n-1]\n   _index = arr.index(arr[n-1])\n   _index = arr.index(arr[0])\n   _index = (n-1) - (n-1) + (n-1) - (n-1) + (n-1) - (n-1) + (n-1) - (n-1) + (n-1) - (n-1) + (n"
    },
    {
        "original": "def even_bit_toggle_number(n) : \r\n    res = 0; count = 0; temp = n    \r\n    while(temp > 0 ) : \r\n        if (count % 2 == 0) : \r\n            res = res | (1 << count)      \r\n        count = count + 1\r\n        temp >>= 1 \r\n    return n ^ res ",
        "sampled": "def even_bit_toggle_number(num):\n    \"\"\"\n    This function takes an integer as input and returns the number with all odd bits toggled.\n    \"\"\"\n    # Initialize an empty list to store the odd bits\n    odd_bits = []\n    # Iterate through each bit of the number\n    for bit in bin(num)[2:]:\n        # If the bit is odd, append it to the odd_bits list\n        if bit == '1':\n            odd_bits.append(bit)\n        # If the bit is even, toggle it and append the result to the odd_bits list\n        else:"
    },
    {
        "original": "def frequency_Of_Smallest(n,arr): \r\n    mn = arr[0] \r\n    freq = 1\r\n    for i in range(1,n): \r\n        if (arr[i] < mn): \r\n            mn = arr[i] \r\n            freq = 1\r\n        elif (arr[i] == mn): \r\n            freq += 1\r\n    return freq ",
        "sampled": "def frequency_Of_Smallest(n, arr):\n    freq = 0\n    smallest = arr[0]\n    for i in range(1, n):\n        if arr[i] < smallest:\n            smallest = arr[i]\n            freq += 1\n    return freq\n# Test cases\nassert frequency_Of_Smallest(5,[1,2,3,4,3]) == 1\nassert frequency_Of_Smallest(7,[3,1,2,5,6,2,3]) == 1\nassert frequency_Of_Smallest(7,[3"
    },
    {
        "original": "def get_perrin(n):\r\n  if (n == 0):\r\n    return 3\r\n  if (n == 1):\r\n    return 0\r\n  if (n == 2):\r\n    return 2 \r\n  return get_perrin(n - 2) + get_perrin(n - 3)",
        "sampled": "def get_perrin(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        return get_perrin(n-1) + get_perrin(n-2)\n# Test cases\nassert get_perrin(9) == 12\nassert get_perrin(4) == 2\nassert get_perrin(6) == 5"
    },
    {
        "original": "def swap_count(s):\r\n\tchars = s\r\n\tcount_left = 0\r\n\tcount_right = 0\r\n\tswap = 0\r\n\timbalance = 0; \r\n\tfor i in range(len(chars)):\r\n\t\tif chars[i] == '[':\r\n\t\t\tcount_left += 1\r\n\t\t\tif imbalance > 0:\r\n\t\t\t\tswap += imbalance\r\n\t\t\t\timbalance -= 1\r\n\t\telif chars[i] == ']':\r\n\t\t\tcount_right += 1\r\n\t\t\timbalance = (count_right - count_left) \r\n\treturn swap",
        "sampled": "def swap_count(s):\n    stack = []\n    for c in s:\n        if c == '[':\n            stack.append(c)\n        elif c == ']':\n            if not stack:\n                return 0\n            stack.pop()\n    return len(stack)\n# Test cases\nassert swap_count(\"[]][][\") == 2\nassert swap_count(\"[[][]]\") == 0\nassert swap_count(\"[[][]]][\") == 1"
    },
    {
        "original": "def even_or_odd(N): \r\n    l = len(N) \r\n    if (N[l-1] =='0'or N[l-1] =='2'or \r\n        N[l-1] =='4'or N[l-1] =='6'or \r\n        N[l-1] =='8'or N[l-1] =='A'or \r\n        N[l-1] =='C'or N[l-1] =='E'): \r\n        return (\"Even\") \r\n    else: \r\n        return (\"Odd\") ",
        "sampled": "def even_or_odd(hex_num):\n    if hex_num.startswith(\"0x\"):\n        hex_num = hex_num[2:]\n    if hex_num.startswith(\"0\"):\n        hex_num = hex_num[1:]\n    if hex_num.startswith(\"0\"):\n        hex_num = hex_num[1:]\n    if len(hex_num) % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"\n# Test cases\nassert even_or_odd(\"AB3454D\") == \"Odd\""
    },
    {
        "original": "def highest_Power_of_2(n): \r\n    res = 0; \r\n    for i in range(n, 0, -1): \r\n        if ((i & (i - 1)) == 0): \r\n            res = i; \r\n            break; \r\n    return res; ",
        "sampled": "def highest_Power_of_2(n):\n    if n == 0:\n        return 0\n    else:\n        return 1 << (32 - int(log2(n)))\ndef log2(n):\n    return int(math.log(n, 2))\n# Test cases\nassert highest_Power_of_2(10) == 8\nassert highest_Power_of_2(19) == 16\nassert highest_Power_of_2(32) == 32"
    },
    {
        "original": "def find_lucas(n): \r\n\tif (n == 0): \r\n\t\treturn 2\r\n\tif (n == 1): \r\n\t\treturn 1\r\n\treturn find_lucas(n - 1) + find_lucas(n - 2) ",
        "sampled": "def find_lucas(n):\n    if n == 0:\n        return 2\n    elif n == 1:\n        return 1\n    else:\n        return find_lucas(n-1) + find_lucas(n-2)\n# Test cases\nassert find_lucas(9) == 76\nassert find_lucas(4) == 7\nassert find_lucas(3) == 4"
    },
    {
        "original": "def add_string(list,string):\r\n add_string=[string.format(i) for i in  list]\r\n return add_string",
        "sampled": "def add_string(lst, string):\n    return [string + str(item) for item in lst]\n# Test cases\nassert add_string([1,2,3,4],'temp{0}')==['temp1', 'temp2', 'temp3', 'temp4']\nassert add_string(['a','b','c','d'], 'python{0}')==[ 'pythona', 'pythonb', 'pythonc', 'pythond']\nassert add_string([5,6,7,8],'string{0}')==['string5','string"
    },
    {
        "original": "def convert_list_dictionary(l1, l2, l3):\r\n     result = [{x: {y: z}} for (x, y, z) in zip(l1, l2, l3)]\r\n     return result",
        "sampled": "kl':{'programs':400}}]\nassert convert_list_dictionary([\"a\",\"b\",\"c\"],[\"apple\",\"banana\",\"cherry\"],[50,60,70])==[{'a':{'apple':50}},{'b':{'banana':60}},{'c':{'cherry':70}}]\nassert convert_list_dictionary([\"1\",\"2\",\"3\"],[\"apple\",\"banana\",\"cherry\"],[50,60,70])==[{'1':{'apple':50}},{'2':{'banana':60"
    },
    {
        "original": "def get_max_sum (n):\r\n\tres = list()\r\n\tres.append(0)\r\n\tres.append(1)\r\n\ti = 2\r\n\twhile i<n + 1:\r\n\t\tres.append(max(i, (res[int(i / 2)] \r\n\t\t\t\t\t\t+ res[int(i / 3)] +\r\n\t\t\t\t\t\t\tres[int(i / 4)]\r\n\t\t\t\t\t\t+ res[int(i / 5)])))\r\n\t\ti = i + 1\r\n\treturn res[n]",
        "sampled": "def get_max_sum(n):\n    if n == 1:\n        return 1\n    elif n == 2:\n        return 2\n    else:\n        return max(get_max_sum(n//2) + get_max_sum(n//3) + get_max_sum(n//4) + get_max_sum(n//5), n)\n# Test cases\nassert get_max_sum(60) == 106\nassert get_max_sum(10) == 12\nassert get_max_sum("
    },
    {
        "original": "def max_length_list(input_list):\r\n    max_length = max(len(x) for x in input_list )   \r\n    max_list = max(input_list, key = lambda i: len(i))    \r\n    return(max_length, max_list)",
        "sampled": "def max_length_list(lst):\n    return max(len(x) for x in lst), max(lst, key=len)\n# Test cases\nassert max_length_list([[0], [1, 3], [5, 7], [9, 11], [13, 15, 17]])==(3, [13, 15, 17])\nassert max_length_list([[1,2,3,4,5],[1,2,3,4],[1,2,3],[1,2],["
    },
    {
        "original": "def check_distinct(test_tup):\r\n  res = True\r\n  temp = set()\r\n  for ele in test_tup:\r\n    if ele in temp:\r\n      res = False\r\n      break\r\n    temp.add(ele)\r\n  return (res) ",
        "sampled": "def check_distinct(tuple_):\n    \"\"\"\n    This function takes a tuple as input and returns True if all the elements in the tuple are distinct,\n    and False otherwise.\n    \"\"\"\n    # Create a set to store the unique elements of the tuple\n    unique_set = set(tuple_)\n    # Check if the length of the set is equal to the length of the tuple\n    return len(unique_set) == len(tuple_)\n# Test cases\nassert check_distinct((1, 4, 5, 6, 1, 4)) == False\nassert check_distinct((1"
    },
    {
        "original": "def first_non_repeating_character(str1):\r\n  char_order = []\r\n  ctr = {}\r\n  for c in str1:\r\n    if c in ctr:\r\n      ctr[c] += 1\r\n    else:\r\n      ctr[c] = 1 \r\n      char_order.append(c)\r\n  for c in char_order:\r\n    if ctr[c] == 1:\r\n      return c\r\n  return None",
        "sampled": ""
    },
    {
        "original": "import re  \r\nregex = r'^[a-z]$|^([a-z]).*\\1$'\r\ndef check_char(string): \r\n\tif(re.search(regex, string)): \r\n\t\treturn \"Valid\" \r\n\telse: \r\n\t\treturn \"Invalid\" ",
        "sampled": "def check_char(s):\n    # Check if the string starts and ends with the same character\n    if s[0] == s[-1]:\n        return \"Valid\"\n    else:\n        return \"Invalid\"\n# Test cases\nassert check_char(\"abba\") == \"Valid\"\nassert check_char(\"a\") == \"Valid\"\nassert check_char(\"abcd\") == \"Invalid\""
    },
    {
        "original": "def median_numbers(a,b,c):\r\n if a > b:\r\n    if a < c:\r\n        median = a\r\n    elif b > c:\r\n        median = b\r\n    else:\r\n        median = c\r\n else:\r\n    if a > c:\r\n        median = a\r\n    elif b < c:\r\n        median = b\r\n    else:\r\n        median = c\r\n return median",
        "sampled": "Here's the function:\ndef median_numbers(a, b, c):\n    # Sort the three numbers in ascending order\n    sorted_numbers = sorted([a, b, c])\n    # Calculate the middle index\n    middle_index = len(sorted_numbers) // 2\n    # If the length of the list is odd, the median is the middle number\n    if len(sorted_numbers) % 2 == 1:\n        return sorted_numbers[middle_index]\n    # If the length of the list is even, the median is the average of the two middle numbers\n    else:"
    },
    {
        "original": "def sum_of_digits(nums):\r\n    return sum(int(el) for n in nums for el in str(n) if el.isdigit())",
        "sampled": "def sum_of_digits(numbers):\n    \"\"\"\n    This function takes a list of numbers as input and returns the sum of digits of each number.\n    \"\"\"\n    # Initialize an empty list to store the sum of digits of each number\n    digit_sum = []\n    # Iterate through each number in the list\n    for num in numbers:\n        # Convert the number to a string\n        num_str = str(num)\n        # Initialize a variable to store the sum of digits\n        digit_sum_num = 0\n        # Iterate through each character in the string\n        for char in num_str:\n            # Convert the"
    },
    {
        "original": "def bitwise_xor(test_tup1, test_tup2):\r\n  res = tuple(ele1 ^ ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ",
        "sampled": "The function should take two tuples as input and return the result of the bitwise xor operation across the two tuples. The result should be a tuple of the same length as the input tuples.\nFor example, if we call bitwise_xor((10, 4, 6, 9), (5, 2, 3, 3)), the function should return (15, 6, 5, 10).\nNote: The bitwise xor operation is defined as:\nx ^ y = x AND y XOR x AND NOT y\nWe can use the"
    },
    {
        "original": "def extract_freq(test_list):\r\n  res = len(list(set(tuple(sorted(sub)) for sub in test_list)))\r\n  return (res)",
        "sampled": "The function should return the frequency of unique tuples in the given list. The tuples should be sorted in ascending order."
    },
    {
        "original": "def add_nested_tuples(test_tup1, test_tup2):\r\n  res = tuple(tuple(a + b for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res) ",
        "sampled": "5, 13), (3, 3), (9, 5))) == ((12, 17), (12, 22), (7, 17), (13, 20))\nassert add_nested_tuples(((4, 6), (7, 8), (5, 12), (4, 13)), ((9, 10), (6, 14), (4, 4), (10, 6))) == ((14, 20), (14, 26), ("
    },
    {
        "original": "def ncr_modp(n, r, p): \r\n    C = [0 for i in range(r+1)]   \r\n    C[0] = 1\r\n    for i in range(1, n+1): \r\n        for j in range(min(i, r), 0, -1): \r\n            C[j] = (C[j] + C[j-1]) % p   \r\n    return C[r] ",
        "sampled": "def ncr_modp(n,r,p):\n    \"\"\"\n    Computes the value of ncr%p using modular arithmetic.\n    \"\"\"\n    if r == 0:\n        return 1\n    if r > n:\n        return 0\n    return (ncr_modp(n-1,r-1,p) * (n-r+1)) % p\n# Test cases\nassert ncr_modp(10,2,13)==6\nassert ncr_modp(15,12,43)==25\nassert ncr_mod"
    },
    {
        "original": "import re\r\ndef is_valid_URL(str):\r\n\tregex = (\"((http|https)://)(www.)?\" +\r\n\t\t\t\"[a-zA-Z0-9@:%._\\\\+~#?&//=]\" +\r\n\t\t\t\"{2,256}\\\\.[a-z]\" +\r\n\t\t\t\"{2,6}\\\\b([-a-zA-Z0-9@:%\" +\r\n\t\t\t\"._\\\\+~#?&//=]*)\")\r\n\tp = re.compile(regex)\r\n\tif (str == None):\r\n\t\treturn False\r\n\tif(re.search(p, str)):\r\n\t\treturn True\r\n\telse:\r\n\t\treturn False",
        "sampled": ""
    },
    {
        "original": "def minimum(a,b):   \r\n    if a <= b: \r\n        return a \r\n    else: \r\n        return b ",
        "sampled": "def minimum(a, b):\n    if a < b:\n        return a\n    else:\n        return b\n# Test cases\nassert minimum(1,2) == 1\nassert minimum(-5,-4) == -5\nassert minimum(0,0) == 0"
    },
    {
        "original": "def check_tuplex(tuplex,tuple1): \r\n  if tuple1 in tuplex:\r\n    return True\r\n  else:\r\n     return False",
        "sampled": "The function should take two arguments: the tuple and the element to check for. The function should return True if the element exists within the tuple, and False otherwise."
    },
    {
        "original": "def find_Parity(x): \r\n    y = x ^ (x >> 1); \r\n    y = y ^ (y >> 2); \r\n    y = y ^ (y >> 4); \r\n    y = y ^ (y >> 8); \r\n    y = y ^ (y >> 16); \r\n    if (y & 1): \r\n        return (\"Odd Parity\"); \r\n    return (\"Even Parity\"); ",
        "sampled": "def find_Parity(num):\n    if num % 2 == 0:\n        return \"Even Parity\"\n    else:\n        return \"Odd Parity\"\n# Test cases\nassert find_Parity(12) == \"Even Parity\"\nassert find_Parity(7) == \"Odd Parity\"\nassert find_Parity(10) == \"Even Parity\""
    },
    {
        "original": "def rearrange_bigger(n):\r\n    nums = list(str(n))\r\n    for i in range(len(nums)-2,-1,-1):\r\n        if nums[i] < nums[i+1]:\r\n            z = nums[i:]\r\n            y = min(filter(lambda x: x > z[0], z))\r\n            z.remove(y)\r\n            z.sort()\r\n            nums[i:] = [y] + z\r\n            return int(\"\".join(nums))\r\n    return False",
        "sampled": "def rearrange_bigger(num):\n    # check if the number is already the next bigger number\n    if num == int(str(num)[::-1]):\n        return False\n    # convert the number to a string and reverse it\n    num_str = str(num)[::-1]\n    # initialize the next bigger number\n    next_bigger = 0\n    # loop through the digits of the number\n    for digit in num_str:\n        # if the digit is 9, increment the next bigger number by 1\n        if digit == '9':\n            next_bigger += 1\n        # if"
    },
    {
        "original": "import heapq\r\ndef k_smallest_pairs(nums1, nums2, k):\r\n   queue = []\r\n   def push(i, j):\r\n       if i < len(nums1) and j < len(nums2):\r\n           heapq.heappush(queue, [nums1[i] + nums2[j], i, j])\r\n   push(0, 0)\r\n   pairs = []\r\n   while queue and len(pairs) < k:\r\n       _, i, j = heapq.heappop(queue)\r\n       pairs.append([nums1[i], nums2[j]])\r\n       push(i, j + 1)\r\n       if j == 0:\r\n           push(i + 1, 0)\r\n   return pairs",
        "sampled": "def k_smallest_pairs(arr1, arr2, k):\n   _dict = {}\n    for i in range(len(arr1)):\n        for j in range(len(arr2)):\n            if arr1[i] + arr2[j] in_dict:\n                if arr1[i] + arr2[j] in_dict[arr1[i] + arr2[j]]:\n                    continue\n                else:\n                   _dict[arr1[i] + arr2[j]].append([arr1[i], arr2[j]])\n            else:"
    },
    {
        "original": "def min_product_tuple(list1):\r\n    result_min = min([abs(x * y) for x, y in list1] )\r\n    return result_min",
        "sampled": "The function should take a list of tuples as input and return the minimum product of any two tuples in the list.\nFor example, if the input list is [(2, 7), (2, 6), (1, 8), (4, 9)], the function should return 8, since the minimum product of any two tuples in the list is 2*7=14.\nIf the input list is [(10,20), (15,2), (5,10)], the function should return 30, since the minimum product of any two tuples in"
    },
    {
        "original": "def min_val(listval):\r\n     min_val = min(i for i in listval if isinstance(i, int))\r\n     return min_val",
        "sampled": "The function should take a list of heterogeneous elements as input and return the minimum value in the list. If the list is empty, the function should return None."
    },
    {
        "original": "import re\r\ndef snake_to_camel(word):\r\n  return ''.join(x.capitalize() or '_' for x in word.split('_'))",
        "sampled": "def snake_to_camel(snake_str):\n    # Convert snake case to camel case using regex\n    camel_str = re.sub('_(.)', lambda x: x.group(1).upper(), snake_str)\n    return camel_str\n# Test cases\nassert snake_to_camel('android_tv') == 'AndroidTv'\nassert snake_to_camel('google_pixel') == 'GooglePixel'\nassert snake_to_camel('apple_watch') == 'AppleWatch'"
    },
    {
        "original": "def remove_odd(l):\r\n    for i in l:\r\n        if i % 2 != 0:\r\n            l.remove(i)\r\n    return l",
        "sampled": "def remove_odd(lst):\n    return [num for num in lst if num % 2 == 0]\n# Test cases\nassert remove_odd([1,2,3]) == [2]\nassert remove_odd([2,4,6]) == [2,4,6]\nassert remove_odd([10,20,3]) == [10,20]"
    },
    {
        "original": "def extract_nth_element(list1, n):\r\n    result = [x[n] for x in list1]\r\n    return result",
        "sampled": ", 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94, 98)],-1)==['Greyson Fulton', 'Brady Kent', 'Wyatt Knott', 'Beau Turnbull']\nassert extract_nth_element([('Greyson Fulton', 98, 99), ('Brady Kent', 97, 96), ('Wyatt Knott', 91, 94), ('Beau Turnbull', 94,"
    },
    {
        "original": "def overlapping(list1,list2):  \r\n    c=0\r\n    d=0\r\n    for i in list1: \r\n        c+=1\r\n    for i in list2: \r\n        d+=1\r\n    for i in range(0,c): \r\n        for j in range(0,d): \r\n            if(list1[i]==list2[j]): \r\n                return 1\r\n    return 0",
        "sampled": "def overlapping(seq1, seq2):\n    \"\"\"\n    This function takes two sequences as input and returns True if there is any overlapping between them,\n    and False otherwise.\n    \"\"\"\n    # Sort the sequences\n    seq1.sort()\n    seq2.sort()\n    # Iterate through the sorted sequences\n    for i in range(len(seq1)):\n        if seq1[i] == seq2[i]:\n            return True\n    return False\n# Test cases\nassert overlapping([1,2,3,4,5],[6,7,8,9]) == False\nassert overlapping([1,2"
    },
    {
        "original": "def max_Product(arr): \r\n    arr_len = len(arr) \r\n    if (arr_len < 2): \r\n        return (\"No pairs exists\")           \r\n    x = arr[0]; y = arr[1]      \r\n    for i in range(0,arr_len): \r\n        for j in range(i + 1,arr_len): \r\n            if (arr[i] * arr[j] > x * y): \r\n                x = arr[i]; y = arr[j] \r\n    return x,y    ",
        "sampled": "def max_Product(arr):\n    max1 = max2 = arr[0]\n    for i in range(1,len(arr)):\n        if arr[i] > max1:\n            max2 = max1\n            max1 = arr[i]\n        elif arr[i] > max2:\n            max2 = arr[i]\n    return (max1,max2)\n# Test cases\nassert max_Product([1,2,3,4,7,0,8,4]) == (7,8)\nassert max_Product([0,-1,-2,-4"
    },
    {
        "original": "MAX = 1000000\r\ndef breakSum(n): \r\n\tdp = [0]*(n+1) \r\n\tdp[0] = 0\r\n\tdp[1] = 1\r\n\tfor i in range(2, n+1): \r\n\t\tdp[i] = max(dp[int(i/2)] + dp[int(i/3)] + dp[int(i/4)], i); \r\n\treturn dp[n]",
        "sampled": "def breakSum(num):\n    if num < 3:\n        return num\n    else:\n        return max(breakSum(num//3) + num%3, breakSum(num//3) + 3)\n# Test cases\nassert breakSum(12) == 13\nassert breakSum(24) == 27\nassert breakSum(23) == 23"
    },
    {
        "original": "def group_tuples(Input): \r\n\tout = {} \r\n\tfor elem in Input: \r\n\t\ttry: \r\n\t\t\tout[elem[0]].extend(elem[1:]) \r\n\t\texcept KeyError: \r\n\t\t\tout[elem[0]] = list(elem) \r\n\treturn [tuple(values) for values in out.values()] ",
        "sampled": "def group_tuples(lst):\n    common_elements = []\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i][0] == lst[j][0]:\n                common_elements.append(lst[i])\n    return common_elements\n# Test cases\nassert group_tuples([('x', 'y'), ('x', 'z'), ('w', 't')]) == [('x', 'y', 'z'), ('w', 't')]\nassert group_tuples([('a', 'b'), ('a"
    },
    {
        "original": "def Find_Max(lst): \r\n    maxList = max((x) for x in lst) \r\n    return maxList",
        "sampled": "def Find_Max(lst):\n    max_len = 0\n    max_sublist = []\n    for sublist in lst:\n        if len(sublist) > max_len:\n            max_len = len(sublist)\n            max_sublist = sublist\n    return max_sublist\n# Test cases\nassert Find_Max([['A'],['A','B'],['A','B','C']]) == ['A','B','C']\nassert Find_Max([[1],[1,2],[1,2,3]]) == [1,2,3]\nassert Find"
    },
    {
        "original": "def round_and_sum(list1):\r\n  lenght=len(list1)\r\n  round_and_sum=sum(list(map(round,list1))* lenght)\r\n  return round_and_sum",
        "sampled": "def round_and_sum(numbers):\n    total_sum = sum(numbers)\n    rounded_numbers = [round(num, 2) for num in numbers]\n    return total_sum * len(rounded_numbers)\n# Test cases\nprint(round_and_sum([22.4, 4.0, -16.22, -9.10, 11.00, -12.22, 14.20, -5.20, 17.50])) # Expected output: 243"
    },
    {
        "original": "def cube_Sum(n): \r\n    sum = 0\r\n    for i in range(1,n + 1): \r\n        sum += (2*i)*(2*i)*(2*i) \r\n    return sum",
        "sampled": "def cube_Sum(n):\n    return sum(i**3 for i in range(2, n+1, 2))\n# Test cases\nassert cube_Sum(2) == 72\nassert cube_Sum(3) == 288\nassert cube_Sum(4) == 800"
    },
    {
        "original": "def concatenate_tuple(test_tup):\r\n    delim = \"-\"\r\n    res = ''.join([str(ele) + delim for ele in test_tup])\r\n    res = res[ : len(res) - len(delim)]\r\n    return (str(res)) ",
        "sampled": "def concatenate_tuple(tuple_elements, delimiter=\"-\"):\n    return delimiter.join(str(element) for element in tuple_elements)\n# Test cases\nassert concatenate_tuple((\"ID\", \"is\", 4, \"UTS\")) == 'ID-is-4-UTS'\nassert concatenate_tuple((\"QWE\", \"is\", 4, \"RTY\")) == 'QWE-is-4-RTY'\nassert concatenate_tuple((\"ZEN\", \"is\", 4, \"OP\")) == 'ZEN-is-4-OP'"
    },
    {
        "original": "def find_Average_Of_Cube(n):  \r\n    sum = 0\r\n    for i in range(1, n + 1): \r\n        sum += i * i * i  \r\n    return round(sum / n, 6) ",
        "sampled": "def find_Average_Of_Cube(n):\n    return sum(i**3 for i in range(1, n+1))/n**2"
    },
    {
        "original": "def get_maxgold(gold, m, n): \r\n    goldTable = [[0 for i in range(n)] \r\n                        for j in range(m)]   \r\n    for col in range(n-1, -1, -1): \r\n        for row in range(m):  \r\n            if (col == n-1): \r\n                right = 0\r\n            else: \r\n                right = goldTable[row][col+1] \r\n            if (row == 0 or col == n-1): \r\n                right_up = 0\r\n            else: \r\n                right_up = goldTable[row-1][col+1] \r\n            if (row == m-1 or col == n-1): \r\n                right_down = 0\r\n            else: \r\n                right_down = goldTable[row+1][col+1] \r\n            goldTable[row][col] = gold[row][col] + max(right, right_up, right_down) \r\n    res = goldTable[0][0] \r\n    for i in range(1, m): \r\n        res = max(res, goldTable[i][0])  \r\n    return res ",
        "sampled": "def get_maxgold(mine_map, rows, cols):\n    def dfs(i, j, gold):\n        if i < 0 or i >= rows or j < 0 or j >= cols:\n            return gold\n        if mine_map[i][j] == 0:\n            gold += mine_map[i][j]\n            mine_map[i][j] = 0\n            gold = dfs(i-1, j, gold)\n            gold = dfs(i+1, j, gold)\n            gold = dfs(i, j-1, gold)\n            gold = dfs"
    },
    {
        "original": "def extract_rear(test_tuple):\r\n  res = list(sub[len(sub) - 1] for sub in test_tuple)\r\n  return (res) ",
        "sampled": "The function should take a tuple of strings as input and return a list of the rear index elements for each string. The rear index element is the last character of the string. For example, if the input is ('Mers', 'for', 'Vers'), the output should be ['s', 'r','s']. If the input is ('Avenge', 'for', 'People'), the output should be ['e', 'r', 'e']. If the input is ('Gotta', 'get', 'go'), the output should be ['a', 't', 'o']."
    },
    {
        "original": "def count_element_in_list(list1, x): \r\n    ctr = 0\r\n    for i in range(len(list1)): \r\n        if x in list1[i]: \r\n            ctr+= 1          \r\n    return ctr",
        "sampled": "def count_element_in_list(lst, element):\n    count = 0\n    for sublist in lst:\n        if element in sublist:\n            count += 1\n    return count\n# Test cases\nassert count_element_in_list([[1, 3], [5, 7], [1, 11], [1, 15, 7]],1)==3\nassert count_element_in_list([['A', 'B'], ['A', 'C'], ['A', 'D', 'E'], ['B', 'C', 'D']],'"
    },
    {
        "original": "def filter_oddnumbers(nums):\r\n odd_nums = list(filter(lambda x: x%2 != 0, nums))\r\n return odd_nums",
        "sampled": "def filter_oddnumbers(numbers):\n    return list(filter(lambda x: x%2!=0, numbers))\n# Test cases\nassert filter_oddnumbers([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])==[1,3,5,7,9]\nassert filter_oddnumbers([10,20,45,67,84,93])==[45,67,93]\nassert filter_oddnumbers([5,7,9"
    },
    {
        "original": "import re\r\ndef change_date_format(dt):\r\n        return re.sub(r'(\\d{4})-(\\d{1,2})-(\\d{1,2})', '\\\\3-\\\\2-\\\\1', dt)",
        "sampled": "def change_date_format(date_str):\n    # Your code here\n    import re\n    pattern = r'(\\d{4})-(\\d{2})-(\\d{2})'\n    match = re.match(pattern, date_str)\n    if match:\n        year, month, day = match.groups()\n        return f'{day}-{month}-{year}'\n    else:\n        return None\n# Test cases\nassert change_date_format(\"2026-01-02\") == '02-01-2026'\nassert change_"
    },
    {
        "original": "def shell_sort(my_list):\r\n    gap = len(my_list) // 2\r\n    while gap > 0:\r\n        for i in range(gap, len(my_list)):\r\n            current_item = my_list[i]\r\n            j = i\r\n            while j >= gap and my_list[j - gap] > current_item:\r\n                my_list[j] = my_list[j - gap]\r\n                j -= gap\r\n            my_list[j] = current_item\r\n        gap //= 2\r\n\r\n    return my_list",
        "sampled": "def shell_sort(arr):\n    n = len(arr)\n    gap = n // 2\n    while gap > 0:\n        for i in range(gap, n):\n            temp = arr[i]\n            j = i\n            while j >= gap and arr[j - gap] > temp:\n                arr[j] = arr[j - gap]\n                j -= gap\n            arr[j] = temp\n        gap //= 2\n    return arr\n# Test cases\nassert shell_sort([12, 23, 4, 5, 3, 2, "
    },
    {
        "original": "def and_tuples(test_tup1, test_tup2):\r\n  res = tuple(ele1 & ele2 for ele1, ele2 in zip(test_tup1, test_tup2))\r\n  return (res) ",
        "sampled": "def and_tuples(t1, t2):\n    \"\"\"\n    Given two tuples, return a tuple containing the elementwise and of the corresponding elements.\n    If the corresponding elements are not of the same type, return a tuple containing 0 for that element.\n    \"\"\"\n    result = []\n    for i in range(len(t1)):\n        if type(t1[i]) == type(t2[i]):\n            result.append(t1[i] & t2[i])\n        else:\n            result.append(0)\n    return tuple(result)\n# Test cases\nassert and"
    },
    {
        "original": "def parabola_directrix(a, b, c): \r\n  directrix=((int)(c - ((b * b) + 1) * 4 * a ))\r\n  return directrix",
        "sampled": "The function should take three parameters: the coefficients of the parabola, i.e., a, b, and c. The function should return the directrix of the parabola, which is the point where the parabola crosses the y-axis. If the parabola is not a parabola, the function should return None.\nHere's the function:\ndef parabola_directrix(a, b, c):\n    # Check if the parabola is a parabola\n    if a**2 + b**2!= c**2:\n        return None"
    },
    {
        "original": "def common_element(list1, list2):\r\n     result = False\r\n     for x in list1:\r\n         for y in list2:\r\n             if x == y:\r\n                 result = True\r\n                 return result",
        "sampled": "def common_element(list1, list2):\n    \"\"\"\n    Returns True if there is a common element in the two lists, False otherwise.\n    \"\"\"\n    # Convert the lists to sets to remove duplicates\n    set1 = set(list1)\n    set2 = set(list2)\n    # Check if there is at least one common element\n    if set1.intersection(set2):\n        return True\n    else:\n        return False"
    },
    {
        "original": "def median_trapezium(base1,base2,height):\r\n median = 0.5 * (base1+ base2)\r\n return median",
        "sampled": "def median_trapezium(a,b,c):\n    = (a+b+c)/2\n   1 = (a+b)/2\n   2 = (a+c)/2\n   3 = (b+c)/2\n   4 = (a+b+c)/4\n   5 = (a+b)/4\n   6 = (a+c)/4\n   7 = (b+c)/4\n   8 = (a+b+c)/8\n   9 = (a+b)/8\n   10 = (a+"
    },
    {
        "original": "def check_greater(arr, number):\r\n  arr.sort()\r\n  if number > arr[-1]:\r\n    return ('Yes, the entered number is greater than those in the array')\r\n  else:\r\n    return ('No, entered number is less than those in the array')",
        "sampled": ""
    },
    {
        "original": "import re\r\ndef text_match_one(text):\r\n        patterns = 'ab+?'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')\r\n",
        "sampled": "assert text_match_one(\"ababa\")==('Found a match!')\nassert text_match_one(\"abbaa\")==('Found a match!')\nassert text_match_one(\"abbab\")==('Found a match!')\nassert text_match_one(\"abbac\")==('Found a match!')\nassert text_match_one(\"abbad\")==('Found a match!')\nassert text_match_one(\"abbae\")==('Found a match!')\nassert text_match_one(\"abbaf\")==('Found a match!')\nassert text_match_one(\"abbag\")==('Found a match"
    },
    {
        "original": "def last_Digit(n) :\r\n    return (n % 10) ",
        "sampled": "def last_Digit(num):\n    return num % 10"
    },
    {
        "original": "def neg_nos(list1):\r\n  for num in list1: \r\n    if num < 0: \r\n       return num ",
        "sampled": "def neg_nos(lst):\n    \"\"\"\n    This function takes a list of numbers as input and returns a list of negative numbers.\n    \"\"\"\n    return [num for num in lst if num < 0]\n# Test cases\nassert neg_nos([-1,4,5,-6]) == -1,-6\nassert neg_nos([-1,-2,3,4]) == -1,-2\nassert neg_nos([-7,-6,8,9]) == -7,-6"
    },
    {
        "original": "def remove_odd(str1):\r\n str2 = ''\r\n for i in range(1, len(str1) + 1):\r\n    if(i % 2 == 0):\r\n        str2 = str2 + str1[i - 1]\r\n return str2",
        "sampled": "def remove_odd(s):\n    return ''.join(c for c in s if c.isalpha())"
    },
    {
        "original": "def count_bidirectional(test_list):\r\n  res = 0\r\n  for idx in range(0, len(test_list)):\r\n    for iidx in range(idx + 1, len(test_list)):\r\n      if test_list[iidx][0] == test_list[idx][1] and test_list[idx][1] == test_list[iidx][0]:\r\n        res += 1\r\n  return (str(res)) ",
        "sampled": "def count_bidirectional(lst):\n    count = 0\n    for i in range(len(lst)):\n        for j in range(i+1, len(lst)):\n            if lst[i][0] == lst[j][1] and lst[j][0] == lst[i][1]:\n                count += 1\n    return str(count)\n# Test cases\nassert count_bidirectional([(5, 6), (1, 2), (6, 5), (9, 1), (6, 5), (2, 1)]) == '3"
    },
    {
        "original": "def multiple_to_single(L):\r\n  x = int(\"\".join(map(str, L)))\r\n  return x",
        "sampled": "Here's the function you need to write:\ndef multiple_to_single(numbers):\n    # Convert the list of numbers to a single integer\n    single_number = 0\n    for num in numbers:\n        single_number = single_number * 10 + num\n    return single_number\n# Test cases\nassert multiple_to_single([11, 33, 50])==113350\nassert multiple_to_single([-1,2,3,4,5,6])==-123456\nassert multiple_to"
    },
    {
        "original": "import re\r\ndef find_adverb_position(text):\r\n for m in re.finditer(r\"\\w+ly\", text):\r\n    return (m.start(), m.end(), m.group(0))",
        "sampled": " {output}The function should take a string as input and return a tuple containing the index of the first occurrence of an adverb and its length, and the adverb itself. If there is no adverb, the function should return None.\nHere's a possible implementation:\n```python\ndef find_adverb_position(sentence):\n    adverbs = ['clearly','seriously', 'unfortunately']\n    for i, adv in enumerate(adverbs):\n        if sentence.startswith(adv):\n            return i, len(adv), adv\n    return None\n```\nThis"
    },
    {
        "original": "def surfacearea_cube(l):\r\n  surfacearea= 6*l*l\r\n  return surfacearea",
        "sampled": "The function should take a single argument, which is the length of the cube. It should return the surface area of the cube, which is the product of the six faces of the cube. \nTo calculate the surface area of a cube, we need to consider the six faces of the cube. Each face has six sides, and the surface area of a cube is the sum of the surface areas of all six faces. \nTo calculate the surface area of a face, we need to consider the six sides of the face. The area of a side is the area of a triangle with the base equal to the side length"
    },
    {
        "original": "from array import array\r\ndef positive_count(nums):\r\n    n = len(nums)\r\n    n1 = 0\r\n    for x in nums:\r\n        if x > 0:\r\n            n1 += 1\r\n        else:\r\n          None\r\n    return round(n1/n,2)",
        "sampled": "The function should take an array of integers as input and return the ration of positive numbers in the array. The ration should be a float value between 0 and 1.0. If there are no positive numbers in the array, the function should return 0.0.\nHere's the code for the function:\ndef positive_count(arr):\n    count = 0\n    for num in arr:\n        if num > 0:\n            count += 1\n    if count == 0:\n        return 0.0\n    else:\n        return count / len(arr)\nYou"
    },
    {
        "original": "def largest_neg(list1): \r\n    max = list1[0] \r\n    for x in list1: \r\n        if x < max : \r\n             max = x  \r\n    return max",
        "sampled": "def largest_neg(lst):\n    \"\"\"\n    This function takes a list as input and returns the largest negative number in the list.\n    \"\"\"\n    largest = lst[0]\n    for num in lst:\n        if num < 0 and num > largest:\n            largest = num\n    return largest\n# Test cases\nassert largest_neg([1,2,3,-4,-6]) == -6\nassert largest_neg([1,2,3,-8,-9]) == -9\nassert largest_neg([1,2,3,4,-1]) == -1"
    },
    {
        "original": "def trim_tuple(test_list, K):\r\n  res = []\r\n  for ele in test_list:\r\n    N = len(ele)\r\n    res.append(tuple(list(ele)[K: N - K]))\r\n  return (str(res)) ",
        "sampled": ", 3), (1, 2, 3, 4), (5, 6, 7, 8)], 2) == '[(4, 9), (1, 3), (2, 4), (7, 8)]'\nassert trim_tuple([(7, 8, 4, 9), (11, 8, 1, 3), (1, 2, 3, 4), (5, 6, 7, 8)], 3) == '[(7, 8, 4), (1"
    },
    {
        "original": "def index_multiplication(test_tup1, test_tup2):\r\n  res = tuple(tuple(a * b for a, b in zip(tup1, tup2))\r\n   for tup1, tup2 in zip(test_tup1, test_tup2))\r\n  return (res) ",
        "sampled": "5, 11), (3, 3), (9, 5)) ) == ((24, 45), (30, 75), (12, 30), (24, 56))\nassert index_multiplication(((4, 6), (7, 8), (5, 12), (4, 13)),((9, 10), (6, 12), (4, 4), (10, 6)) ) == ((36, 64), (48, 96"
    },
    {
        "original": "from collections import Counter \r\ndef count_Occurrence(tup, lst): \r\n    count = 0\r\n    for item in tup: \r\n        if item in lst: \r\n            count+= 1 \r\n    return count  ",
        "sampled": "def count_Occurrence(lst, tup):\n    count = 0\n    for i in lst:\n        if i in tup:\n            count += 1\n    return count\n# Test cases\nassert count_Occurrence(('a', 'a', 'c', 'b', 'd'),['a', 'b'] ) == 3\nassert count_Occurrence((1, 2, 3, 1, 4, 6, 7, 1, 4),[1, 4, 7]) == 6\nassert count_Occurrence((1,2,3,4,"
    },
    {
        "original": "def cube_nums(nums):\r\n cube_nums = list(map(lambda x: x ** 3, nums))\r\n return cube_nums",
        "sampled": "Here's the code to find cubes of individual elements in a list using lambda function:\n```python\ndef cube_nums(lst):\n    return list(map(lambda x: x**3, lst))\n```\nThis function takes a list as input and returns a new list with cubes of individual elements in the input list. The `map()` function applies the lambda function to each element in the input list and returns a new list with cubes of individual elements. The `list()` function is used to convert the new list to a Python list.\nThe lambda function `lambda x: x"
    },
    {
        "original": "def cal_sum(n): \r\n\ta = 3\r\n\tb = 0\r\n\tc = 2\r\n\tif (n == 0): \r\n\t\treturn 3\r\n\tif (n == 1): \r\n\t\treturn 3\r\n\tif (n == 2): \r\n\t\treturn 5\r\n\tsum = 5\r\n\twhile (n > 2): \r\n\t\td = a + b \r\n\t\tsum = sum + d \r\n\t\ta = b \r\n\t\tb = c \r\n\t\tc = d \r\n\t\tn = n-1\r\n\treturn sum",
        "sampled": "def cal_sum(n):\n    \"\"\"\n    This function calculates the sum of perrin numbers.\n    \"\"\"\n    sum = 0\n    for i in range(1, n+1):\n        sum += i * (i + 1)\n    return sum\n# Test cases\nassert cal_sum(9) == 49\nassert cal_sum(10) == 66\nassert cal_sum(11) == 88"
    },
    {
        "original": "def check_Triangle(x1,y1,x2,y2,x3,y3): \r\n    a = (x1*(y2-y3)+x2*(y3-y1)+x3*(y1-y2))   \r\n    if a == 0: \r\n        return ('No') \r\n    else: \r\n        return ('Yes') ",
        "sampled": "def check_Triangle(a, b, c, d, e, f):\n    # Check if the given points form a triangle\n    if a + b > c and a + c > b and b + c > a:\n        if a + b > d and a + d > b and b + d > a:\n            if a + b > e and a + e > b and b + e > a:\n                if a + b > f and a + f > b and b + f > a:\n                    # Check if the given points form a validion of the triangle\n                    if a + b"
    },
    {
        "original": "def extract_string(str, l):\r\n    result = [e for e in str if len(e) == l] \r\n    return result",
        "sampled": "The function should take two arguments: a list of string values and an integer representing the size of the strings to extract. The function should return a list of the extracted strings. If the size of the strings to extract is greater than the length of the list, the function should return an empty list."
    },
    {
        "original": "import re\r\ndef remove_whitespaces(text1):\r\n  return (re.sub(r'\\s+', '',text1))",
        "sampled": "def remove_whitespaces(string):\n    # Remove all whitespaces using regex\n    return re.sub(r'\\s+', '', string)\n# Test cases\nassert remove_whitespaces(' Google    Flutter ') == 'GoogleFlutter'\nassert remove_whitespaces(' Google    Dart ') == 'GoogleDart'\nassert remove_whitespaces(' iOS    Swift ') == 'iOSSwift'"
    },
    {
        "original": "def loss_amount(actual_cost,sale_amount): \r\n  if(sale_amount > actual_cost):\r\n    amount = sale_amount - actual_cost\r\n    return amount\r\n  else:\r\n    return None",
        "sampled": ""
    },
    {
        "original": "import math \r\ndef sumofFactors(n) : \r\n    if (n % 2 != 0) : \r\n        return 0\r\n    res = 1\r\n    for i in range(2, (int)(math.sqrt(n)) + 1) :    \r\n        count = 0\r\n        curr_sum = 1\r\n        curr_term = 1\r\n        while (n % i == 0) : \r\n            count= count + 1\r\n            n = n // i \r\n            if (i == 2 and count == 1) : \r\n                curr_sum = 0\r\n            curr_term = curr_term * i \r\n            curr_sum = curr_sum + curr_term \r\n        res = res * curr_sum  \r\n    if (n >= 2) : \r\n        res = res * (1 + n) \r\n    return res ",
        "sampled": "def sumofFactors(num):\n    sum = 0\n    for i in range(2, num+1):\n        if num % i == 0 and i % 2 == 0:\n            sum += i\n    return sum\n# Test cases\nassert sumofFactors(18) == 26\nassert sumofFactors(30) == 48\nassert sumofFactors(6) == 8"
    },
    {
        "original": "import re\r\ndef text_match_wordz(text):\r\n        patterns = '\\w*z.\\w*'\r\n        if re.search(patterns,  text):\r\n                return 'Found a match!'\r\n        else:\r\n                return('Not matched!')",
        "sampled": "def text_match_wordz(text):\n    if 'z' in text:\n        return 'Found a match!'\n    else:\n        return 'Not matched!'\n# Test cases\nassert text_match_wordz(\"pythonz.\")==('Found a match!')\nassert text_match_wordz(\"xyz.\")==('Found a match!')\nassert text_match_wordz(\"  lang .\")==('Not matched!')"
    },
    {
        "original": "def check_monthnumb_number(monthnum2):\r\n  if(monthnum2==1 or monthnum2==3 or monthnum2==5 or monthnum2==7 or monthnum2==8 or monthnum2==10 or monthnum2==12):\r\n    return True\r\n  else:\r\n    return False",
        "sampled": ""
    },
    {
        "original": "def reverse_string_list(stringlist):\r\n    result = [x[::-1] for x in stringlist]\r\n    return result",
        "sampled": "def reverse_string_list(lst):\n    return [s[::-1] for s in lst]\n# Test cases\nassert reverse_string_list(['Red', 'Green', 'Blue', 'White', 'Black'])==['deR', 'neerG', 'eulB', 'etihW', 'kcalB']\nassert reverse_string_list(['john','amal','joel','george'])==['nhoj','lama','leoj','egroeg']\nassert reverse_string_list(['jack','john','mary'])==['kcaj','n"
    },
    {
        "original": "def Find_Min(lst): \r\n    minList = min((x) for x in lst) \r\n    return minList",
        "sampled": "def Find_Min(lst):\n    min_len = float('inf')\n    min_sublist = []\n    for sublist in lst:\n        if len(sublist) < min_len:\n            min_len = len(sublist)\n            min_sublist = sublist\n    return min_sublist\n# Test cases\nassert Find_Min([[1],[1,2],[1,2,3]]) == [1]\nassert Find_Min([[1,1],[1,1,1],[1,2,7,8]]) == [1,1]\nassert Find_"
    },
    {
        "original": "def rectangle_area(l,b):\r\n  area=l*b\r\n  return area",
        "sampled": "def rectangle_area(width, height):\n    return width * height"
    },
    {
        "original": "import re\r\ndef remove_uppercase(str1):\r\n  remove_upper = lambda text: re.sub('[A-Z]', '', text)\r\n  result =  remove_upper(str1)\r\n  return (result)",
        "sampled": "def remove_uppercase(string):\n    # Use regex to find all uppercase substrings\n    uppercase_substrings = re.findall(r'[A-Z]+', string)\n    # Remove uppercase substrings from the string\n    for substring in uppercase_substrings:\n        string = string.replace(substring, '')\n    return string\n# Test the function with the given test cases\nassert remove_uppercase('cAstyoUrFavoRitETVshoWs') == 'cstyoravoitshos'\nassert remove_uppercase('wAtchTheinTernEtrAdIo') =="
    },
    {
        "original": "def Extract(lst): \r\n    return [item[0] for item in lst] ",
        "sampled": "def Extract(lst):\n    return [sublist[0] for sublist in lst]\n# Test cases\nassert Extract([[1, 2], [3, 4, 5], [6, 7, 8, 9]]) == [1, 3, 6]\nassert Extract([[1,2,3],[4, 5]]) == [1,4]\nassert Extract([[9,8,1],[1,2]]) == [9,1]"
    },
    {
        "original": "def upper_ctr(str):\r\n    upper_ctr = 0\r\n    for i in range(len(str)):\r\n          if str[i] >= 'A' and str[i] <= 'Z': upper_ctr += 1\r\n          return upper_ctr",
        "sampled": "def upper_ctr(s):\n    count = 0\n    for char in s:\n        if char.isupper():\n            count += 1\n    return count\n# Test cases\nassert upper_ctr('PYthon') == 1\nassert upper_ctr('BigData') == 1\nassert upper_ctr('program') == 0"
    },
    {
        "original": "def combinations_list(list1):\r\n    if len(list1) == 0:\r\n        return [[]]\r\n    result = []\r\n    for el in combinations_list(list1[1:]):\r\n        result += [el, el+[list1[0]]]\r\n    return result",
        "sampled": "red'], ['white', 'blue', 'green'], ['white', 'blue', 'green','red'], ['black'], ['black','red'], ['black', 'green'], ['black', 'green','red'], ['black', 'blue'], ['black', 'blue','red'], ['black', 'blue', 'green'], ['black', 'blue', 'green','red'], ['black', 'white'], ['black', 'white','red'], ['black', 'white', 'green'], ['black', 'white', 'green','red'], ['black', 'white', 'blue'],"
    },
    {
        "original": "def max_subarray_product(arr):\r\n\tn = len(arr)\r\n\tmax_ending_here = 1\r\n\tmin_ending_here = 1\r\n\tmax_so_far = 0\r\n\tflag = 0\r\n\tfor i in range(0, n):\r\n\t\tif arr[i] > 0:\r\n\t\t\tmax_ending_here = max_ending_here * arr[i]\r\n\t\t\tmin_ending_here = min (min_ending_here * arr[i], 1)\r\n\t\t\tflag = 1\r\n\t\telif arr[i] == 0:\r\n\t\t\tmax_ending_here = 1\r\n\t\t\tmin_ending_here = 1\r\n\t\telse:\r\n\t\t\ttemp = max_ending_here\r\n\t\t\tmax_ending_here = max (min_ending_here * arr[i], 1)\r\n\t\t\tmin_ending_here = temp * arr[i]\r\n\t\tif (max_so_far < max_ending_here):\r\n\t\t\tmax_so_far = max_ending_here\r\n\tif flag == 0 and max_so_far == 0:\r\n\t\treturn 0\r\n\treturn max_so_far",
        "sampled": "def max_subarray_product(arr):\n    max_so_far = arr[0]\n    max_ending_here = arr[0]\n    min_ending_here = arr[0]\n    for i in range(1, len(arr)):\n        max_ending_here = max(arr[i], max_ending_here * arr[i])\n        min_ending_here = min(arr[i], min_ending_here * arr[i])\n        max_so_far = max(max_so_far, max_ending_here)\n    return max_so"
    },
    {
        "original": "def check_value(dict, n):\r\n    result = all(x == n for x in dict.values()) \r\n    return result",
        "sampled": ""
    },
    {
        "original": "def drop_empty(dict1):\r\n  dict1 = {key:value for (key, value) in dict1.items() if value is not None}\r\n  return dict1",
        "sampled": "def drop_empty(d):\n    return {k: v for k, v in d.items() if v is not None}\n# Test cases\nassert drop_empty({'c1': 'Red', 'c2': 'Green', 'c3':None})=={'c1': 'Red', 'c2': 'Green'}\nassert drop_empty({'c1': 'Red', 'c2': None, 'c3':None})=={'c1': 'Red'}\nassert drop_empty({'c1': None, 'c2': 'Green', 'c3':"
    },
    {
        "original": "def find_peak_util(arr, low, high, n): \r\n\tmid = low + (high - low)/2\r\n\tmid = int(mid) \r\n\tif ((mid == 0 or arr[mid - 1] <= arr[mid]) and\r\n\t\t(mid == n - 1 or arr[mid + 1] <= arr[mid])): \r\n\t\treturn mid \r\n\telif (mid > 0 and arr[mid - 1] > arr[mid]): \r\n\t\treturn find_peak_util(arr, low, (mid - 1), n) \r\n\telse: \r\n\t\treturn find_peak_util(arr, (mid + 1), high, n) \r\ndef find_peak(arr, n): \r\n\treturn find_peak_util(arr, 0, n - 1, n) ",
        "sampled": "def find_peak(arr, n):\n    # Initialize the peak index to -1\n    peak_index = -1\n    # Iterate through the array\n    for i in range(n):\n        # If the current element is greater than the previous element,\n        # then it is the peak\n        if arr[i] > arr[i - 1]:\n            peak_index = i\n            break\n    return peak_index\n# Test cases\nassert find_peak([1, 3, 20, 4, 1, 0], 6) == 2\nassert find_peak(["
    },
    {
        "original": "def decimal_to_Octal(deciNum):\r\n    octalNum = 0\r\n    countval = 1;\r\n    dNo = deciNum;\r\n    while (deciNum!= 0):\r\n        remainder= deciNum % 8;\r\n        octalNum+= remainder*countval;\r\n        countval= countval*10;\r\n        deciNum //= 8; \r\n    return (octalNum)",
        "sampled": "def decimal_to_Octal(num):\n    octal_num = \"\"\n    while num > 0:\n        octal_num = str(num % 8) + octal_num\n        num //= 8\n    return octal_num\n# Test cases\nassert decimal_to_Octal(10) == 12\nassert decimal_to_Octal(2) == 2\nassert decimal_to_Octal(33) == 41"
    },
    {
        "original": "def max_product(arr, n ): \r\n\tmpis =[0] * (n) \r\n\tfor i in range(n): \r\n\t\tmpis[i] = arr[i] \r\n\tfor i in range(1, n): \r\n\t\tfor j in range(i): \r\n\t\t\tif (arr[i] > arr[j] and\r\n\t\t\t\t\tmpis[i] < (mpis[j] * arr[i])): \r\n\t\t\t\t\t\tmpis[i] = mpis[j] * arr[i] \r\n\treturn max(mpis)",
        "sampled": "            Note: The input array can have duplicates and negative numbers. The length of the array is at most 10^5. The value of each element in the array is at most 10^9."
    },
    {
        "original": "def max_profit(price, k):\r\n    n = len(price)\r\n    final_profit = [[None for x in range(n)] for y in range(k + 1)]\r\n    for i in range(k + 1):\r\n        for j in range(n):\r\n            if i == 0 or j == 0:\r\n                final_profit[i][j] = 0\r\n            else:\r\n                max_so_far = 0\r\n                for x in range(j):\r\n                    curr_price = price[j] - price[x] + final_profit[i-1][x]\r\n                    if max_so_far < curr_price:\r\n                        max_so_far = curr_price\r\n                final_profit[i][j] = max(final_profit[i][j-1], max_so_far)\r\n    return final_profit[k][n-1]",
        "sampled": "def max_profit(prices, k):\n    if k == 0:\n        return 0\n    min_price = float('inf')\n    max_profit = 0\n    for i in range(len(prices)):\n        if i >= k:\n            min_price = min(min_price, prices[i - k])\n        max_profit = max(max_profit, prices[i] - min_price)\n    return max_profit\n# Test cases\nassert max_profit([1, 5, 2, 3, 7, 6, 4, 5"
    },
    {
        "original": "def add_pairwise(test_tup):\r\n  res = tuple(i + j for i, j in zip(test_tup, test_tup[1:]))\r\n  return (res) ",
        "sampled": "def add_pairwise(tuples):\n    \"\"\"\n    Given a list of tuples, return a tuple of the pairwise sums of the elements in the tuples.\n    \"\"\"\n    # Initialize the result tuple\n    result = ()\n    # Iterate over the tuples\n    for i in range(len(tuples)):\n        # Iterate over the remaining tuples\n        for j in range(i+1, len(tuples)):\n            # Add the pairwise elements and append to the result tuple\n            result += (tuples[i][j] + tuples[j][i],)\n    # Return the result tuple\n    return result\n# Test the function"
    },
    {
        "original": "def find_remainder(arr, lens, n): \r\n    mul = 1\r\n    for i in range(lens):  \r\n        mul = (mul * (arr[i] % n)) % n \r\n    return mul % n ",
        "sampled": "def find_remainder(arr, n, d):\n    # Calculate the product of the array elements\n    product = 1\n    for num in arr:\n        product *= num\n    # Calculate the remainder of the product divided by n\n    remainder = product % n\n    # Calculate the quotient of the product divided by n\n    quotient = product // n\n    # Calculate the remainder of the quotient divided by d\n    remainder_of_quotient = quotient % d\n    # Return the remainder of the quotient divided by d\n    return remainder_of_quotient\n# Test cases\nassert find_remainder([ "
    },
    {
        "original": "def check_Consecutive(l): \r\n    return sorted(l) == list(range(min(l),max(l)+1)) ",
        "sampled": "def check_Consecutive(lst):\n    if len(lst) < 2:\n        return False\n    for i in range(len(lst)-1):\n        if lst[i] + 1 == lst[i+1]:\n            return True\n    return False\n# Test cases\nassert check_Consecutive([1,2,3,4,5]) == True\nassert check_Consecutive([1,2,3,5,6]) == False\nassert check_Consecutive([1,2,1]) == False"
    },
    {
        "original": "def tuple_intersection(test_list1, test_list2):\r\n  res = set([tuple(sorted(ele)) for ele in test_list1]) & set([tuple(sorted(ele)) for ele in test_list2])\r\n  return (res)",
        "sampled": " 3)}\nassert tuple_intersection([(1, 2), (3, 4), (5, 6), (7, 8)], [(1, 2), (3, 4), (5, 6), (7, 8)]) == set()\nThe function should take two arguments: a tuple list and another tuple list. The function should return a set of tuples that are common to both tuple lists.\nFor example, if we have two tuple lists:\n[(3, 4), (5, 6), (9, 10), (4"
    },
    {
        "original": "def replace_char(str1,ch,newch):\r\n str2 = str1.replace(ch, newch)\r\n return str2",
        "sampled": "def replace_char(string, old_char, new_char):\n    \"\"\"\n    Replace all occurrences of old_char in string with new_char.\n    \"\"\"\n    return string.replace(old_char, new_char)\n# Test cases\nassert replace_char(\"polygon\",'y','l')==(\"pollgon\")\nassert replace_char(\"character\",'c','a')==(\"aharaater\")\nassert replace_char(\"python\",'l','a')==(\"python\")"
    },
    {
        "original": "from collections import Counter\r\ndef sort_counter(dict1):\r\n x = Counter(dict1)\r\n sort_counter=x.most_common()\r\n return sort_counter",
        "sampled": "def sort_counter(counter):\n    sorted_counter = sorted(counter.items(), key=lambda x: x[1], reverse=True)\n    return sorted_counter\n# Test cases\nassert sort_counter({'Math':81, 'Physics':83, 'Chemistry':87})==[('Chemistry', 87), ('Physics', 83), ('Math', 81)]\nassert sort_counter({'Math':400, 'Physics':300, 'Chemistry':250})==[('Math', 400), ('"
    },
    {
        "original": "def big_sum(nums):\r\n      sum= max(nums)+min(nums)\r\n      return sum",
        "sampled": "def big_sum(arr):\n    \"\"\"\n    This function takes an array as input and returns the sum of the largest and smallest values in the array.\n    \"\"\"\n    if len(arr) == 0:\n        return 0\n    elif len(arr) == 1:\n        return arr[0]\n    else:\n        max_val = max(arr)\n        min_val = min(arr)\n        return max_val + min_val\n# Test cases\nassert big_sum([1,2,3]) == 4\nassert big_sum([-1,2,3,4])"
    },
    {
        "original": "def is_lower(string):\r\n  return (string.lower())",
        "sampled": "def is_lower(s):\n    return s.lower()"
    },
    {
        "original": "import re\r\ndef remove_lowercase(str1):\r\n remove_lower = lambda text: re.sub('[a-z]', '', text)\r\n result =  remove_lower(str1)\r\n return result",
        "sampled": "def remove_lowercase(s):\n    # Convert the string to lowercase\n    s = s.lower()\n    # Initialize an empty list to store the non-lowercase substrings\n    result = []\n    # Loop through each character in the string\n    for c in s:\n        # If the character is uppercase, add it to the result list\n        if c.isupper():\n            result.append(c)\n    # Return the result list\n    return ''.join(result)\n# Test the function with the provided test cases\nassert remove_lowercase(\"PYTHon\")==('PYTH')\nassert remove_lowercase(\"F"
    },
    {
        "original": "def first_Digit(n) :  \r\n    while n >= 10:  \r\n        n = n / 10; \r\n    return int(n) ",
        "sampled": "def first_Digit(num):\n    return num // 10"
    },
    {
        "original": "def get_max_occuring_char(str1):\r\n  ASCII_SIZE = 256\r\n  ctr = [0] * ASCII_SIZE\r\n  max = -1\r\n  ch = ''\r\n  for i in str1:\r\n    ctr[ord(i)]+=1;\r\n  for i in str1:\r\n    if max < ctr[ord(i)]:\r\n      max = ctr[ord(i)]\r\n      ch = i\r\n  return ch",
        "sampled": "def get_max_occuring_char(string):\n    \"\"\"\n    This function takes a string as input and returns the character that occurs the most in the string.\n    If there are multiple characters that occur the most, it returns the first one it encounters.\n    \"\"\"\n    # Initialize a dictionary to store the count of each character in the string\n    char_count = {}\n    # Loop through each character in the string\n    for char in string:\n        # If the character is already in the dictionary, increment its count\n        if char in char_count:\n            char_count[char] += 1\n        #"
    },
    {
        "original": "def is_subset_sum(set, n, sum):\r\n\tif (sum == 0):\r\n\t\treturn True\r\n\tif (n == 0):\r\n\t\treturn False\r\n\tif (set[n - 1] > sum):\r\n\t\treturn is_subset_sum(set, n - 1, sum)\r\n\treturn is_subset_sum(set, n-1, sum) or is_subset_sum(set, n-1, sum-set[n-1])",
        "sampled": " */\n        def is_subset_sum(arr, target_sum, current_sum):\n            if current_sum == target_sum:\n                return True\n            if current_sum > target_sum:\n                return False\n            for num in arr:\n                if num <= current_sum:\n                    if is_subset_sum(arr, target_sum, current_sum + num):\n                        return True\n            return False\n        # Test cases\n        assert is_subset_sum([3, 34, 4, 12, 5, 2], 6, 9) == True\n        assert is_"
    },
    {
        "original": "import re \r\ndef match(text): \r\n\t\tpattern = '[A-Z]+[a-z]+$'\r\n\t\tif re.search(pattern, text): \r\n\t\t\t\treturn('Yes') \r\n\t\telse: \r\n\t\t\t\treturn('No') ",
        "sampled": "def match(s):\n    pattern = r'[A-Z][a-z]*'\n    match = re.findall(pattern, s)\n    if match:\n        return 'Yes'\n    else:\n        return 'No'\n# Test cases\nassert match(\"Geeks\") == 'Yes'\nassert match(\"geeksforGeeks\") == 'Yes'\nassert match(\"geeks\") == 'No'"
    },
    {
        "original": "def first_Factorial_Divisible_Number(x): \r\n    i = 1;\r\n    fact = 1; \r\n    for i in range(1,x): \r\n        fact = fact * i \r\n        if (fact % x == 0): \r\n            break\r\n    return i ",
        "sampled": "def first_Factorial_Divisible_Number(x):\n    \"\"\"\n    This function takes an integer x as input and returns the first natural number whose factorial is divisible by x.\n    \"\"\"\n    for i in range(1, x+1):\n        if i*i % x == 0:\n            return i\n    return None\n# Test cases\nassert first_Factorial_Divisible_Number(10) == 5\nassert first_Factorial_Divisible_Number(15) == 5\nassert first_Factorial_Divisible_Number(5) == "
    },
    {
        "original": "def remove_matching_tuple(test_list1, test_list2):\r\n  res = [sub for sub in test_list1 if sub not in test_list2]\r\n  return (res) ",
        "sampled": "def remove_matching_tuple(tuples, matching_tuples):\n    \"\"\"\n    Removes the matching tuples from the given two tuples.\n    \"\"\"\n    return [t for t in tuples if t not in matching_tuples]\n# Test cases\nassert remove_matching_tuple([('Hello', 'dude'), ('How', 'are'), ('you', '?')], [('Hello', 'dude'), ('How', 'are')]) == [('you', '?')]\nassert remove_matching_tuple([('Part', 'of'), ('the', 'journey'), ('is ', 'end')], [('Journey', 'the"
    },
    {
        "original": "def is_palindrome(n) : \r\n\tdivisor = 1\r\n\twhile (n / divisor >= 10) : \r\n\t\tdivisor *= 10\r\n\twhile (n != 0) : \r\n\t\tleading = n // divisor \r\n\t\ttrailing = n % 10\r\n\t\tif (leading != trailing) : \r\n\t\t\treturn False\r\n\t\tn = (n % divisor) // 10\r\n\t\tdivisor = divisor // 100\r\n\treturn True\r\ndef largest_palindrome(A, n) : \r\n\tA.sort() \r\n\tfor i in range(n - 1, -1, -1) : \r\n\t\tif (is_palindrome(A[i])) : \r\n\t\t\treturn A[i] \r\n\treturn -1",
        "sampled": "def largest_palindrome(arr, n):\n    \"\"\"\n    Given an array of integers, find the largest palindromic number in the array.\n    \"\"\"\n    max_palindrome = 0\n    for i in range(n):\n        for j in range(i, n):\n            palindrome = 0\n            for k in range(i, j+1):\n                palindrome = palindrome * 10 + arr[k]\n            if palindrome > max_palindrome:\n                max_palindrome = palindrome\n    return max_palindrome\n# Test cases\nassert largest_palindrome"
    },
    {
        "original": "def nCr(n, r): \r\n\tif (r > n / 2): \r\n\t\tr = n - r \r\n\tanswer = 1 \r\n\tfor i in range(1, r + 1): \r\n\t\tanswer *= (n - r + i) \r\n\t\tanswer /= i \r\n\treturn answer \r\ndef binomial_probability(n, k, p): \r\n\treturn (nCr(n, k) * pow(p, k) *\tpow(1 - p, n - k)) ",
        "sampled": "Note: Thedict function is provided for you to use. It is a dictionary that maps_i to_i-1.\n\"\"\"\nfrom collections import defaultdict\ndef binomial_probability(n, k, p):\n   _dict = defaultdict(int)\n    for i in range(1, n+1):\n        for j in range(1, i+1):\n            if i-j >= 0:\n               _i = i-j\n                if i-j == 0:\n                   _i_1 = 0\n                else:\n                   _i_"
    },
    {
        "original": "def sort_tuple(tup): \r\n\tlst = len(tup) \r\n\tfor i in range(0, lst): \r\n\t\tfor j in range(0, lst-i-1): \r\n\t\t\tif (tup[j][-1] > tup[j + 1][-1]): \r\n\t\t\t\ttemp = tup[j] \r\n\t\t\t\ttup[j]= tup[j + 1] \r\n\t\t\t\ttup[j + 1]= temp \r\n\treturn tup",
        "sampled": "Here's a possible implementation:\ndef sort_tuple(tuples):\n    return sorted(tuples, key=lambda x: x[-1])\n# Test cases\nassert sort_tuple([(1, 3), (3, 2), (2, 1)]) == [(2, 1), (3, 2), (1, 3)]\nassert sort_tuple([(2, 4), (3, 3), (1, 1)]) == [(1, 1), (3, 3), (2, 4)]\nassert sort_tuple([(3,"
    },
    {
        "original": "import math\r\ndef area_pentagon(a):\r\n  area=(math.sqrt(5*(5+2*math.sqrt(5)))*pow(a,2))/4.0\r\n  return area",
        "sampled": "The function should take a positive integer as input and return the area of a pentagon with that number of sides. Theinatorined the formula for the area of a pentagon using Heron's formula, which states that the area of a pentagon is given by:\nA = (1/5) * s^2\nwhere A is the area, s is the semi-perimeter, and s = 5 * (n-2) / n.\nThe is to implement the function `area_pentagon` that takes a positive integer `n` as input and returns the"
    },
    {
        "original": "def frequency_Of_Largest(n,arr): \r\n    mn = arr[0] \r\n    freq = 1\r\n    for i in range(1,n): \r\n        if (arr[i] >mn): \r\n            mn = arr[i] \r\n            freq = 1\r\n        elif (arr[i] == mn): \r\n            freq += 1\r\n    return freq ",
        "sampled": "def frequency_Of_Largest(n, arr):\n    largest = max(arr)\n    count = 0\n    for i in arr:\n        if i == largest:\n            count += 1\n    return count\n# Test cases\nassert frequency_Of_Largest(5,[1,2,3,4,4]) == 2\nassert frequency_Of_Largest(3,[5,6,5]) == 1\nassert frequency_Of_Largest(4,[2,7,7,7]) == 3"
    },
    {
        "original": "def extract_symmetric(test_list):\r\n  temp = set(test_list) & {(b, a) for a, b in test_list}\r\n  res = {(a, b) for a, b in temp if a < b}\r\n  return (res) ",
        "sampled": "The function should take a tuple list as input and return a set of symmetric pairs. The pairs should be sorted in ascending order. If there are multiple pairs with the same value, they should be sorted in ascending order of their first element.\nHere's a possible implementation:\ndef extract_symmetric(lst):\n    pairs = set()\n    for pair in lst:\n        if pair[::-1] in lst:\n            pairs.add(pair)\n    return sorted(pairs)\n# Test cases\nassert extract_symmetric([(6, 7), (2, 3), (7, 6),"
    },
    {
        "original": "import math\r\ndef sum_gp(a,n,r):\r\n total = (a * (1 - math.pow(r, n ))) / (1- r)\r\n return total",
        "sampled": "def sum_gp(a, b, n):\n    \"\"\"\n    Returns the sum of the geometric progression series a+nb+nb^2+...+nb^n.\n    \"\"\"\n    return a + b * (n - 1) + b ** 2 * (n - 2) +... + b ** n * (n - 1)\n# Test cases\nassert sum_gp(1, 5, 2) == 31\nassert sum_gp(1, 5, 4) == 341\nassert sum_gp(2,"
    },
    {
        "original": "def binary_search(item_list,item):\r\n\tfirst = 0\r\n\tlast = len(item_list)-1\r\n\tfound = False\r\n\twhile( first<=last and not found):\r\n\t\tmid = (first + last)//2\r\n\t\tif item_list[mid] == item :\r\n\t\t\tfound = True\r\n\t\telse:\r\n\t\t\tif item < item_list[mid]:\r\n\t\t\t\tlast = mid - 1\r\n\t\t\telse:\r\n\t\t\t\tfirst = mid + 1\t\r\n\treturn found",
        "sampled": "def binary_search(arr, x):\n    \"\"\"\n    This function takes an array and an element x as input and returns True if x is present in the array,\n    else it returns False.\n    \"\"\"\n    # Base case: if the array is empty, return False\n    if len(arr) == 0:\n        return False\n    # Find the middle index of the array\n    mid = len(arr) // 2\n    # If the middle element is equal to x, return True\n    if arr[mid] == x:\n        return True\n    # If the middle element is greater than x, search in the left"
    },
    {
        "original": "import math\r\ndef calculate_polygons(startx, starty, endx, endy, radius):\r\n    sl = (2 * radius) * math.tan(math.pi / 6)\r\n    p = sl * 0.5\r\n    b = sl * math.cos(math.radians(30))\r\n    w = b * 2\r\n    h = 2 * sl   \r\n    startx = startx - w\r\n    starty = starty - h\r\n    endx = endx + w\r\n    endy = endy + h\r\n    origx = startx\r\n    origy = starty\r\n    xoffset = b\r\n    yoffset = 3 * p\r\n    polygons = []\r\n    row = 1\r\n    counter = 0\r\n    while starty < endy:\r\n        if row % 2 == 0:\r\n            startx = origx + xoffset\r\n        else:\r\n            startx = origx\r\n        while startx < endx:\r\n            p1x = startx\r\n            p1y = starty + p\r\n            p2x = startx\r\n            p2y = starty + (3 * p)\r\n            p3x = startx + b\r\n            p3y = starty + h\r\n            p4x = startx + w\r\n            p4y = starty + (3 * p)\r\n            p5x = startx + w\r\n            p5y = starty + p\r\n            p6x = startx + b\r\n            p6y = starty\r\n            poly = [\r\n                (p1x, p1y),\r\n                (p2x, p2y),\r\n                (p3x, p3y),\r\n                (p4x, p4y),\r\n                (p5x, p5y),\r\n                (p6x, p6y),\r\n                (p1x, p1y)]\r\n            polygons.append(poly)\r\n            counter += 1\r\n            startx += w\r\n        starty += yoffset\r\n        row += 1\r\n    return polygons",
        "sampled": "1.0, -0.7320508075688767), (4.0, 1.0), (3.0, -0.7320508075688767), (3.0, -4.196152422706632), (4.0, -5.928203230275509), (1.0, -4.1961524227066"
    },
    {
        "original": "def binary_to_integer(test_tup):\r\n  res = int(\"\".join(str(ele) for ele in test_tup), 2)\r\n  return (str(res)) ",
        "sampled": "def binary_to_integer(binary_tuple):\n    # Convert the binary tuple to a string\n    binary_str = ''.join(str(bit) for bit in binary_tuple)\n    # Convert the string to an integer\n    return int(binary_str, 2)\n# Test cases\nassert binary_to_integer((1, 1, 0, 1, 0, 0, 1)) == '105'\nassert binary_to_integer((0, 1, 1, 0, 0, 1, 0, 1"
    },
    {
        "original": "import re\r\ndef remove_lowercase(str1):\r\n  remove_lower = lambda text: re.sub('[a-z]', '', text)\r\n  result =  remove_lower(str1)\r\n  return (result)",
        "sampled": "def remove_lowercase(string):\n    # Use regex to find all lowercase substrings\n    lowercase_substrings = re.findall(r'[a-z]+', string)\n    # Remove lowercase substrings from the string\n    for substring in lowercase_substrings:\n        string = string.replace(substring, '')\n    return string\n# Test cases\nassert remove_lowercase('KDeoALOklOOHserfLoAJSIskdsf') == 'KDALOOOHLAJSI'\nassert remove_lowercase('ProducTnamEstreAmIngMediAplAYer')"
    },
    {
        "original": "import heapq as hq\r\ndef heap_queue_smallest(nums,n):\r\n  smallest_nums = hq.nsmallest(n, nums)\r\n  return smallest_nums",
        "sampled": "def heap_queue_smallest(numbers, k):\n    heap = []\n    for num in numbers:\n        heapq.heappush(heap, num)\n        if len(heap) > k:\n            heapq.heappop(heap)\n    return heap\n# Test cases\nprint(heap_queue_smallest([25, 35, 22, 85, 14, 65, 75, 25, 58],3)) # Output: [14, 22, 25]\nprint(heap"
    },
    {
        "original": "import math\r\ndef surfacearea_cone(r,h):\r\n  l = math.sqrt(r * r + h * h)\r\n  SA = math.pi * r * (r + l)\r\n  return SA",
        "sampled": "The function should take two arguments: and base. The function should return the surface area of a cone with the given height and base. The surface area of a cone is given by:\nsurface area = 1/2 * base * height\nThe function should be case-insensitive for the input values."
    },
    {
        "original": "def gcd(x, y):\r\n    gcd = 1\r\n    if x % y == 0:\r\n        return y\r\n    for k in range(int(y / 2), 0, -1):\r\n        if x % k == 0 and y % k == 0:\r\n            gcd = k\r\n            break  \r\n    return gcd",
        "sampled": "def gcd(a, b):\n    \"\"\"\n    This function finds the greatest common divisor of two positive integers a and b.\n    \"\"\"\n    # Base case: if a is 0, return b\n    if a == 0:\n        return b\n    # Base case: if b is 0, return a\n    if b == 0:\n        return a\n    # Recursive case: find the greatest common divisor of a and b\n    if a > b:\n        return gcd(a-b, b)\n    else:\n        return gcd(a, b-a)\n# Test cases\nassert gcd(12"
    },
    {
        "original": "def diameter_circle(r):\r\n  diameter=2*r\r\n  return diameter",
        "sampled": "Here's the function to find the diameter of a circle:\ndef diameter_circle(radius):\n    return 2 * radius\nYou can test the function with the provided test cases:\nassert diameter_circle(10)==20\nassert diameter_circle(40)==80\nassert diameter_circle(15)==30"
    },
    {
        "original": "def concatenate_elements(list):\r\n  ans = ' '\r\n  for i in list:\r\n    ans = ans+ ' '+i\r\n  return (ans) ",
        "sampled": "def concatenate_elements(lst):\n    return''.join(lst)"
    }
]