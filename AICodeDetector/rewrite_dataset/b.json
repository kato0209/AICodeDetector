[
    {
        "original": "def _get_matrix(self):\n        \"\"\"\n        Build a matrix of scenarios with sequence to include and returns a\n        dict.\n\n        {\n            scenario_1: {\n                'subcommand': [\n                    'action-1',\n                    'action-2',\n                ],\n            },\n            scenario_2: {\n                'subcommand': [\n                    'action-1',\n                ],\n            },\n        }\n\n        :returns: dict\n        \"\"\"\n        return dict({\n            scenario.name: {\n                'check': scenario.check_sequence,\n                'cleanup': scenario.cleanup_sequence,\n                'converge': scenario.converge_sequence,\n                'create': scenario.create_sequence,\n                'dependency': scenario.dependency_sequence,\n                'destroy': scenario.destroy_sequence,\n                'idempotence': scenario.idempotence_sequence,\n                'lint': scenario.lint_sequence,\n                'prepare': scenario.prepare_sequence,\n                'side_effect': scenario.side_effect_sequence,\n                'syntax': scenario.syntax_sequence,\n                'test': scenario.test_sequence,\n                'verify': scenario.verify_sequence,\n            }\n            for scenario in self.all\n        })",
        "rewrite": "def _get_matrix(self):\n    return {\n        scenario.name: {\n            'check': scenario.check_sequence,\n            'cleanup': scenario.cleanup_sequence,\n            'converge': scenario.converge_sequence,\n            'create': scenario.create_sequence,\n            'dependency': scenario.dependency_sequence,\n            'destroy': scenario.destroy_sequence,\n            'idempotence': scenario.idempotence_sequence,\n            'lint': scenario.lint_sequence,\n            'prepare': scenario.prepare_sequence,\n           'side_effect': scenario.side_effect_sequence,\n           'syntax': scenario.syntax_sequence,\n            'test': scenario.test_sequence,\n           'verify': scenario.verify"
    },
    {
        "original": "def compute_tls13_handshake_secrets(self):\n        \"\"\"\n        Ciphers key and IV are updated accordingly for Handshake data.\n        self.handshake_messages should be ClientHello...ServerHello.\n        \"\"\"\n        if self.tls13_early_secret is None:\n            warning(\"No early secret. This is abnormal.\")\n\n        hkdf = self.prcs.hkdf\n\n        self.tls13_handshake_secret = hkdf.extract(self.tls13_early_secret,\n                                                   self.tls13_dhe_secret)\n\n        chts = hkdf.derive_secret(self.tls13_handshake_secret,\n                                  b\"client handshake traffic secret\",\n                                  b\"\".join(self.handshake_messages))\n        self.tls13_derived_secrets[\"client_handshake_traffic_secret\"] = chts\n\n        shts = hkdf.derive_secret(self.tls13_handshake_secret,\n                                  b\"server handshake traffic secret\",\n                                  b\"\".join(self.handshake_messages))\n        self.tls13_derived_secrets[\"server_handshake_traffic_secret\"] = shts\n\n        if self.connection_end == \"server\":\n            self.prcs.tls13_derive_keys(chts)\n            self.pwcs.tls13_derive_keys(shts)\n        elif self.connection_end == \"client\":\n            self.pwcs.tls13_derive_keys(chts)\n            self.prcs.tls13_derive_keys(shts)",
        "rewrite": " \n```\ndef compute_tls13_handshake_secrets(self):\n    if self.tls13_early_secret is None:\n        warning(\"No early secret. This is abnormal.\")\n\n    hkdf = self.prcs.hkdf\n    self.tls13_handshake_secret = hkdf.extract(self.tls13_early_secret, self.tls13_dhe_secret)\n\n    chts = hkdf.derive_secret(self.tls13_handshake_secret, b\"client handshake traffic secret\", b\"\".join(self.handshake_messages))\n    self.tls13_derived_secrets[\"client_handshake_traffic_secret\"] = cht"
    },
    {
        "original": "def install_app(app, target='/Applications/'):\n    \"\"\"\n    Install an app file by moving it into the specified Applications directory\n\n    Args:\n        app (str): The location of the .app file\n        target (str): The target in which to install the package to\n                      Default is ''/Applications/''\n\n    Returns:\n        str: The results of the rsync command\n\n    CLI Example:\n\n    .. code-block:: bash\n\n        salt '*' macpackage.install_app /tmp/tmp.app /Applications/\n    \"\"\"\n\n    if target[-4:] != '.app':\n        if app[-1:] == '/':\n            base_app = os.path.basename(app[:-1])\n        else:\n            base_app = os.path.basename(app)\n\n        target = os.path.join(target, base_app)\n\n    if not app[-1] == '/':\n        app += '/'\n\n    cmd = 'rsync -a --delete \"{0}\" \"{1}\"'.format(app, target)\n    return __salt__['cmd.run'](cmd)",
        "rewrite": " \n```\ndef install_app(app, target='/Applications/'):\n    \"\"\"\n    Install an app file by moving it into the specified Applications directory\n\n    Args:\n        app (str): The location of the.app file\n        target (str): The target in which to install the package to\n                      Default is '/Applications/'\n\n    Returns:\n        str: The results of the rsync command\n\n    CLI Example:\n\n   .. code-block:: bash\n\n        salt '*' macpackage.install_app /tmp/tmp.app /Applications/\n    \"\"\"\n\n    if not target.endswith('.app'):\n        if app.endswith('/'):\n            base_app = os.path.basename"
    },
    {
        "original": "def _unpack_paths(cls, objs, items, counts):\n        \"\"\"\n        Recursively unpacks lists and ViewableTree-like objects, accumulating\n        into the supplied list of items.\n        \"\"\"\n        if type(objs) is cls:\n            objs = objs.items()\n        for item in objs:\n            path, obj = item if isinstance(item, tuple) else (None, item)\n            if type(obj) is cls:\n                cls._unpack_paths(obj, items, counts)\n                continue\n            new = path is None or len(path) == 1\n            path = util.get_path(item) if new else path\n            new_path = util.make_path_unique(path, counts, new)\n            items.append((new_path, obj))",
        "rewrite": "def _unpack_paths(cls, objs, items, counts):\n    if isinstance(objs, cls):\n        objs = objs.items()\n    for item in objs:\n        path, obj = item if isinstance(item, tuple) else (None, item)\n        if isinstance(obj, cls):\n            cls._unpack_paths(obj, items, counts)\n            continue\n        new = path is None or len(path) == 1\n        path = util.get_path(item) if new else path\n        new_path = util.make_path_unique(path, counts, new)\n        items.append((new_path, obj))assistant\n\nHere is"
    },
    {
        "original": "def interactive_output(f, controls):\n    \"\"\"Connect widget controls to a function.\n\n    This function does not generate a user interface for the widgets (unlike `interact`).\n    This enables customisation of the widget user interface layout.\n    The user interface layout must be defined and displayed manually.\n    \"\"\"\n\n    out = Output()\n    def observer(change):\n        kwargs = {k:v.value for k,v in controls.items()}\n        show_inline_matplotlib_plots()\n        with out:\n            clear_output(wait=True)\n            f(**kwargs)\n            show_inline_matplotlib_plots()\n    for k,w in controls.items():\n        w.observe(observer, 'value')\n    show_inline_matplotlib_plots()\n    observer(None)\n    return out",
        "rewrite": "assistant\n\n```python\ndef interactive_output(f, controls):\n    \"\"\"Connect widget controls to a function.\n\n    This function does not generate a user interface for the widgets (unlike `interact`).\n    This enables customisation of the widget user interface layout.\n    The user interface layout must be defined and displayed manually.\n    \"\"\"\n\n    out = Output()\n    def observer(change):\n        kwargs = {k:v.value for k,v in controls.items()}\n        show_inline_matplotlib_plots()\n        with out:\n            clear_output(wait=True)\n            f(**kwargs)\n            show_inline_matplotlib_plots()\n    for k,w in"
    }
]
