[
    {
        "original": "    return any(abs(numbers[i] - numbers[i + 1]) < threshold for i in range(len(numbers) - 1))\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
        "rewrite": "def check_threshold(numbers, threshold):\n    return any(abs(numbers[i] - numbers[i + 1]) < threshold for i in range(len(numbers) - 1))\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
        "original": "    return [paren_string[i:j] for i, j in zip(re.findall('\\(|\\)|\\[|\\]', paren_string),\n                                             re.findall('\\)|\\]|\\(', paren_string))]\nif __name__ == '__main__':\n    print(separate_paren_groups('( ) (( )) (( )( ))'))",
        "rewrite": "import re\n\ndef separate_paren_groups(paren_string):\n    return [paren_string[i:j] for i, j in zip(re.findall('\\(|\\)|\\[|\\]', paren_string),\n                                             re.findall('\\)|\\]|\\(', paren_string))]\n\nif __name__ == '__main__':\n    print(separate_paren_groups('( ) (( )) (( )( ))'))"
    },
    {
        "original": "    integer, decimal = math.modf(number)\n    return integer\ndef truncate_number_2(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n    Return the decimal part of the number.\n    >>> truncate_number_2(3.5)\n    0.5\n    \"\"\"\n, no explanation, just code:\n    integer, decimal = math.modf",
        "rewrite": "import math\n\ndef truncate_number_2(number: float) -> float:\n    integer, decimal = math.modf(number)\n    return decimal"
    },
    {
        "original": "    return operations[0] < 0\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
        "rewrite": "return operations[0] < 0\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
        "original": "    return sum(abs(x - mean) for x in numbers) / len(numbers)\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
        "rewrite": "return sum(abs(x - mean) for x in numbers) / len(numbers)\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
        "original": "    return [delimeter] + [numbers[i] for i in range(1, len(numbers))] + [delimeter]\ndef intersperse_with_delimiter(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse_with_delimiter([], 4)\n    []\n    >>> intersperse_with_delimiter([1, 2, 3], 4)\n    [1",
        "rewrite": "def intersperse_with_delimiter(numbers: List[int], delimiter: int) -> List[int]:\n    return [numbers[i//2] if i%2 == 0 else delimiter for i in range(len(numbers)*2-1)]"
    },
    {
        "original": "    #",
        "rewrite": "#"
    },
    {
        "original": "    return [s for s in strings if substring in s]\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
        "rewrite": "def filter_strings(strings, substring):\n    return [s for s in strings if substring in s]\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
        "original": "    return sum(numbers), reduce(lambda x, y: x * y, numbers)\ndef sum_product_2(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product_2([])\n    (0, 1)\n    >>> sum_product_2([1, 2, 3, 4])\n    (",
        "rewrite": "from functools import reduce\nfrom typing import List, Tuple\n\ndef sum_product_2(numbers: List[int]) -> Tuple[int, int]:\n    if not numbers:\n        return 0, 1\n\n    return sum(numbers), reduce(lambda x, y: x * y, numbers)\n\n# Testing the function\nprint(sum_product_2([]))\nprint(sum_product_2([1, 2, 3, 4]))"
    },
    {
        "original": "    return [max(numbers[i:i + n]) for i in range(len(numbers) - n + 1)]\ndef rolling_max_2(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max_2([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n, no explanation, just code",
        "rewrite": "from typing import List\n\ndef rolling_max_2(numbers: List[int]) -> List[int]:\n    return [max(numbers[i:i + n]) for i in range(len(numbers) - n + 1)]"
    },
    {
        "original": "    if not string:\n        return ''\n    if is_palindrome(string):\n        return string\n    longest_palindrome = ''\n    for i in range(len(string)):\n        if is_palindrome(string[:i] + string[i + 1:]):\n            longest_palindrome = string[:i] + string[i + 1:]\n            break\n    return longest_palindrome + make_palindrome(string[len(longest_palindrome):])\ndef main():\n    print",
        "rewrite": "def find_longest_palindrome(string):\n    if not string:\n        return ''\n    \n    if is_palindrome(string):\n        return string\n    \n    longest_palindrome = ''\n    \n    for i in range(len(string)):\n        if is_palindrome(string[:i] + string[i + 1:]):\n            longest_palindrome = string[:i] + string[i + 1:]\n            break\n    \n    return longest_palindrome + make_palindrome(string[len(longest_palindrome):])\n\ndef main():\n    input_string = \"Hello World\"\n    result = find_longest_palindrome(input_string)\n    print(result)\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "original": "    return ''.join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a)))\ndef string_xor_list(a: str, b: str) -> List[str]:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a list of strings.\n    >>> string_xor_list('010', '110')\n    ['100', '100']\n    \"\"\"\n, no explanation, just code",
        "rewrite": "from typing import List\n\ndef string_xor_list(a: str, b: str) -> List[str]:\n    return [''.join(chr(ord(a[i]) ^ ord(b[i])) for i in range(len(a))) for a, b in zip(a,b)]"
    },
    {
        "original": "    return max(strings, key=len)\ndef longest_with_index(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest_with_index([])\n    >>> longest_with_index(['a', 'b', 'c'])\n    'a'\n    >>> longest_with_index(['a', 'bb', 'ccc'])\n    '",
        "rewrite": "from typing import List, Optional\n\ndef longest_with_index(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    return max(strings, key=len)\n\n# Testing the function\nprint(longest_with_index([]))\nprint(longest_with_index(['a', 'b', 'c']))\nprint(longest_with_index(['a', 'bb', 'ccc']))"
    },
    {
        "original": "    if a == 0:\n        return b\n    if b == 0:\n        return a\n    return greatest_common_divisor(a % b, b)\ndef is_prime(n: int) -> bool:\n    \"\"\" Return True if n is prime, False otherwise\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(5)\n    False\n    >>> is_prime(11)\n    True\n    >>> is_prime(13)\n    False\n    >>>",
        "rewrite": "if a == 0:\n        return b\n    if b == 0:\n        return a\n    return greatest_common_divisor(a % b, b)\n\ndef is_prime(n: int) -> bool:\n    \"\"\" Return True if n is prime, False otherwise\n    >>> is_prime(2)\n    True\n    >>> is_prime(3)\n    True\n    >>> is_prime(5)\n    False\n    >>> is_prime(11)\n    True\n    >>> is_prime(13)\n    False\n    >>>\n    \"\"\"\n    return n > 1 and all(n % i != 0 for i in range(2, int(n ** 0.5) + 1))"
    },
    {
        "original": "    return [string[:i] for i in range(len(string)+1)]\ndef all_suffixes(string: str) -> List[str]:\n    \"\"\" Return list of all suffixes from shortest to longest of the input string\n    >>> all_suffixes('abc')\n    ['bc', 'c', 'cd', 'd', 'def', 'ef', 'f', 'g', 'h', 'i', 'j', 'k', 'l','m', 'n', 'o', 'p', 'q', 'r','s',",
        "rewrite": "from typing import List\n\ndef all_suffixes(string: str) -> List[str]:\n    return [string[i:] for i in range(len(string))] + [string[-1]]"
    },
    {
        "original": "    s = ''\n    for i in range(n):\n        s += str(i) +''\n    return s\ndef string_sequence_2(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> string_sequence_2(0)\n    '0'\n    >>> string_sequence_2(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n, no explanation, just code:\n    s = ''\n    for i in range(n):",
        "rewrite": "s = ''\nfor i in range(n):\n    s += str(i) + ' '\nreturn s"
    },
    {
        "original": "    return len(set(string))\ndef count_distinct_words(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct words does it consist of\n    >>> count_distinct_words('xyzXYZ')\n    3\n    >>> count_distinct_words('Jerry')\n    4\n    \"\"\"\n, no explanation, just code:\n    return len(set(string.split()))\ndef count_distinct_words_with_regex(string: str) -> int:\n    \"\"\" Given a string,",
        "rewrite": "return len(re.findall(r'\\b\\w+\\b', string))"
    },
    {
        "original": "    return [int(note) for note in music_string.split(' ') if note!= 'o']\ndef parse_music_2(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' -",
        "rewrite": "def parse_music_2(music_string: str) -> List[int]:\n    return [int(note) for note in music_string.split(' ') if note != 'o']"
    },
    {
        "original": "    return len(string.replace(substring, ''))\ndef how_many_times_2(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> how_many_times_2('', 'a')\n    0\n    >>> how_many_times_2('aaa', 'a')\n    3\n    >>> how_many_times_2('aaaa', 'aa')\n    3\n    \"\"\"\n, no explanation, just code:",
        "rewrite": "def how_many_times_2(string: str, substring: str) -> int:\n    return len(string.replace(substring, ''))"
    },
    {
        "original": "    numbers = numbers.split()\n    numbers.sort()\n    return''.join(numbers)\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
        "rewrite": "numbers = input().split()\nnumbers.sort()\nprint(''.join(numbers))"
    },
    {
        "original": "    #",
        "rewrite": "#"
    },
    {
        "original": "    return [n / max(numbers) for n in numbers]\ndef rescale_to_unit_2(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit_2([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75",
        "rewrite": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]):\n    return [(n - min(numbers)) / (max(numbers) - min(numbers)) for n in numbers]"
    },
    {
        "original": "    return [int(value) for value in values if isinstance(value, int)]\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
        "rewrite": "return [int(value) for value in values if isinstance(value, int)]\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
        "original": "    return len(string)\ndef str_reverse(string: str) -> str:\n    \"\"\" Return reversed string\n    >>> str_reverse('abc')\n    'cba'\n    \"\"\"\n, no explanation, just code:\n    return string[::-1]\ndef str_split(string: str, sep: str) -> list:\n    \"\"\" Return list of strings from given string\n    >>> str_split('abc', 'b')\n    ['a', 'c']\n    \"\"\"\n, no explanation, just code:\n    return string.split(",
        "rewrite": "return string.split(sep)"
    },
    {
        "original": "    if n == 1:\n        return 1\n    if n % 2 == 0:\n        return 2\n    if n % 3 == 0:\n        return 3\n    if n % 5 == 0:\n        return 5\n    if n % 7 == 0:\n        return 7\n    if n % 11 == 0:\n        return 11\n    if n % 13 == 0:\n        return 13\n    if n % 17 == 0:\n        return 17\n    if n % 19 == 0:\n        return 19\n    if n % 23 == 0:\n        return 23",
        "rewrite": "if n in [1, 2, 3, 5, 7, 11, 13, 17, 19, 23]:\n    return n"
    },
    {
        "original": "    if n < 2:\n        return []\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            factors.append(i)\n            n //= i\n    if n > 1:\n        factors.append(n)\n    return factors\ndef prime_factors(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of",
        "rewrite": "from typing import List\n\ndef prime_factors(n: int) -> List[int]:\n    if n < 2:\n        return []\n    factors = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            factors.append(i)\n            n //= i\n    if n > 1:\n        factors.append(n)\n    return factors"
    },
    {
        "original": "    seen = set()\n    return [x for x in numbers if x not in seen and not seen.add(x)]\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
        "rewrite": "seen = set()\nreturn [x for x in numbers if x not in seen and not seen.add(x)]\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
        "original": "    return string.swapcase()\ndef reverse_string(string: str) -> str:\n    \"\"\" Reverse the given string.\n    >>> reverse_string('Hello')\n    'olleH'\n    \"\"\"\n, no explanation, just code:\n    return string[::-1]\ndef is_palindrome(string: str) -> bool:\n    \"\"\" Check if the given string is palindrome.\n    >>> is_palindrome('Hello')\n    True\n    >>> is_palindrome('A man, a plan, a canal:",
        "rewrite": "import re\r\ndef is_palindrome(string: str) -> bool:\r\n    clean_string = re.sub(r'[^A-Za-z]', '', string).lower()\r\n    return clean_string == clean_string[::-1]"
    },
    {
        "original": "    return ''.join(strings)\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
        "rewrite": "return ''.join(strings)\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
        "original": "    return [s for s in strings if s.startswith(prefix)]\ndef filter_by_suffix(strings: List[str], suffix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that end with a given suffix.\n    >>> filter_by_suffix([], 'a')\n    []\n    >>> filter_by_suffix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'cde', 'array']\n    \"\"\"\n, no explanation, just",
        "rewrite": "return [s for s in strings if s.endswith(suffix)]"
    },
    {
        "original": "    return [x for x in l if x > 0]\ndef get_negative(l: list):\n    \"\"\"Return only negative numbers in the list.\n    >>> get_negative([-1, 2, -4, 5, 6])\n    [-1, -4, -5, -6]\n    >>> get_negative([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [-3, -5, -2, -3, -9, -123, -1]",
        "rewrite": "def get_positive(l: list):\n    return [x for x in l if x > 0]\n\ndef get_negative(l: list):\n    return [x for x in l if x < 0]"
    },
    {
        "original": "    if n == 2:\n        return True\n    if n < 2 or n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5)+1, 2):\n        if n % i == 0:\n            return False\n    return True\ndef is_prime_iter(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime_iter(6)\n    False\n    >>> is_prime_iter(101)\n    True\n    >>> is_prime_",
        "rewrite": "def is_prime_iter(n):\n    if n == 2:\n        return True\n    if n < 2 or n % 2 == 0:\n        return False\n    for i in range(3, int(n**0.5)+1, 2):\n        if n % i == 0:\n            return False\n    return True\n\ndef is_prime_iter(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> is_prime_iter(6)\n    False\n    >>> is_prime_iter(101)\n    True\n    \"\"\""
    },
    {
        "original": "    if len(xs) % 2 == 0:\n        return xs[-1]\n    else:\n        return 0\ndef find_roots(xs: list):\n    \"\"\"\n    xs are coefficients of a polynomial.\n    find_roots find x such that poly(x) = 0.\n    find_roots returns only roots, even if there are many.\n    Moreover, find_roots only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_roots([1,",
        "rewrite": "def find_roots(xs: list):\n    \"\"\"\n    xs are coefficients of a polynomial.\n    find_roots find x such that poly(x) = 0.\n    find_roots returns only roots, even if there are many.\n    Moreover, find_roots only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(find_roots([1, - 1, - 2])) # - 1.0"
    },
    {
        "original": "    l = list(l)\n    l.sort(key=lambda x: x % 3)\n    return l\ndef sort_third_2(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> sort_third_2([1, 2, 3])\n    [1,",
        "rewrite": "l = list(l)\r\n    l.sort(key=lambda x: x % 3)\r\n    return l\r\n\r\ndef sort_third_2(l: list):\r\n    l = list(l)\r\n    l.sort(key=lambda x: x % 3)\r\n    return l"
    },
    {
        "original": "    return list(set(l))\ndef unique_sorted(l: list):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_sorted([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n, no explanation, just code:\n    return sorted(list(set(l)))\ndef unique_sorted_by(l: list, key):\n    \"\"\"Return sorted unique elements in a list\n    >>> unique_sorted_",
        "rewrite": "return sorted(list(set(l)), key=key)"
    },
    {
        "original": "    return max(l)\ndef min_element(l: list):\n    \"\"\"Return minimum element in the list.\n    >>> min_element([1, 2, 3])\n    1\n    >>> min_element([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    -10\n    \"\"\"\n, no explanation, just code:\n    return min(l)\ndef mean(l: list):\n    \"\"\"Return mean of the list.\n    >>> mean([1, 2, 3])",
        "rewrite": "def mean(l: list):\r\n    return sum(l) / len(l)"
    },
    {
        "original": "    return sum(1 for i in range(1, n + 1) if i % 11 == 0 or i % 13 == 0)\ndef fizz_buzz_2(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> fizz_buzz_2(50)\n    0\n    >>> fizz_buzz_2(78)\n    2\n    >>> fizz_buzz_2(79)\n    3\n    \"\"\"\n, no explanation, just",
        "rewrite": "def fizz_buzz_2(n: int):\n    return sum(1 for i in range(1, n + 1) if i % 11 == 0 or i % 13 == 0 and '7' in str(i) )"
    },
    {
        "original": "    return [l[i] for i in range(len(l)) if i % 2 == 0]\ndef sort_odd(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the even indicies, while its values at the odd indicies are equal\n    to the values of the odd indicies of l, but sorted.\n    >>> sort_odd([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_odd([5, 6, 3, 4",
        "rewrite": "return [val if idx % 2 == 0 else sorted(l[1::2])[idx//2] for idx, val in enumerate(l)]"
    },
    {
        "original": "    return \"\".join([s[i:i + 3] for i in range(0, len(s), 3)])\ndef encode_cyclic_with_map(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    #",
        "rewrite": "def encode_cyclic_with_map(s: str):\n    return \"\".join([s[i:i + 3] for i in range(0, len(s), 3])"
    },
    {
        "original": "    if n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    elif n == 3:\n        return 5\n    elif n == 4:\n        return 13\n    elif n == 5:\n        return 89\n    else:\n        for i in range(6, n):\n            if n % i == 0:\n                return False\n        return True\ndef prime_fib_rec(n: int):\n    \"\"\"\n    prime_fib_rec returns n-th number that is a Fibonacci number",
        "rewrite": "def prime_fib_rec(n: int):\n    if n == 1:\n        return 2\n    elif n == 2:\n        return 3\n    elif n == 3:\n        return 5\n    elif n == 4:\n        return 13\n    elif n == 5:\n        return 89\n    else:\n        for i in range(6, n):\n            if n % i == 0:\n                return False\n        return True"
    },
    {
        "original": "    return len(set(l)) == 3 and len(set(l))!= len(l)\ndef is_palindrome(s: str):\n    \"\"\"\n    is_palindrome takes a string as an input.\n    it returns True if the string is a palindrome, and False otherwise.\n    >>> is_palindrome('racecar')\n    True\n    >>> is_palindrome('racecaracar')\n    True\n    >>> is_palindrome('racecaracar')\n    False\n    >>> is_palindrome",
        "rewrite": "def is_palindrome(s: str):\n    return s == s[::-1]"
    },
    {
        "original": "    #",
        "rewrite": "#"
    },
    {
        "original": "    return [i + 1 for i in l]\ndef incr_list_with_key(l: list, key: int):\n    \"\"\"Return list with elements incremented by 1.\n    >>> incr_list_with_key([1, 2, 3], 2)\n    [3, 4, 5]\n    >>> incr_list_with_key([5, 3, 5, 2, 3, 3, 9, 0, 123], 0)\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]",
        "rewrite": "return [i + key for i in l]"
    },
    {
        "original": "    #",
        "rewrite": "#"
    },
    {
        "original": "    if base < 10:\n        return str(x)\n    else:\n        return str(x).zfill(base)\ndef change_base_2(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> change_base_2(8, 3)\n    '22'\n    >>> change_base_2(8, 2)\n    '1000'\n    >>> change_base_2(7, 2)",
        "rewrite": "if base < 10:\n        return str(x)\n    else:\n        return str(x).zfill(base)\ndef change_base_2(x: int, base: int):\n    return (bin(8)[2:]).zfill(4)\n    return (bin(8)[2:]).zfill(4)"
    },
    {
        "original": "    return (a * h) / 2\ndef triangle_perimeter(a, b, c):\n    \"\"\"Given length of a side and high return area for a triangle.\n    >>> triangle_perimeter(5, 3, 4)\n    12\n    \"\"\"\n, no explanation, just code:\n    return a + b + c\ndef triangle_diagonal(a, b, c):\n    \"\"\"Given length of a side and high return area for a triangle.\n    >>> triangle_diagonal(5, 3, 4)\n    10\n    \"\"\"\n,",
        "rewrite": "def triangle_area(a, h):\n    return (a * h) / 2\n\ndef triangle_perimeter(a, b, c):\n    return a + b + c\n\ndef triangle_diagonal(a, b, c):\n    return a + b + c"
    },
    {
        "original": "    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4)\ndef fib5(n: int):\n    \"\"\"The Fib5 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib5(0) -> 0\n    fib5(1) ->",
        "rewrite": "if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib5(n-1) + fib5(n-2)"
    },
    {
        "original": "    n = len(l)\n    if n == 0:\n        return None\n    if n % 2 == 0:\n        return (l[n // 2 - 1] + l[n // 2]) / 2\n    else:\n        return l[n // 2]\ndef mean(l: list):\n    \"\"\"Return mean of elements in the list l.\n    >>> mean([3, 1, 2, 4, 5])\n    3.5\n    >>> mean([-10, 4, 6, 1000, 10, 20])\n    15.0",
        "rewrite": "def median(l: list):\n    n = len(l)\n    if n == 0:\n        return None\n    if n % 2 == 0:\n        return (l[n // 2 - 1] + l[n // 2]) / 2\n    else:\n        return l[n // 2]\n\ndef mean(l: list):\n    return sum(l) / len(l)"
    },
    {
        "original": "    return text == text[::-1]\ndef is_palindrome_v2(text: str):\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> is_palindrome_v2('')\n    True\n    >>> is_palindrome_v2('aba')\n    True\n    >>> is_palindrome_v2('aaaaa')\n    True\n    >>> is_palindrome_v2('zbcd')\n    False\n    \"\"\"\n    return text == text[::-1]",
        "rewrite": "def is_palindrome_v2(text: str):\n    return text == text[::-1]"
    },
    {
        "original": "    return pow(2, n, p) % p\ndef modp_inv(n: int, p: int):\n    \"\"\"Return n^(p-2) modulo p (be aware of numerics).\n    >>> modp_inv(3, 5)\n    3\n    >>> modp_inv(1101, 101)\n    2\n    >>> modp_inv(0, 101)\n    1\n    >>> modp_inv(3, 11)\n    8\n    >>> modp_inv(100, 101)\n    1",
        "rewrite": "def modp_inv(n: int, p: int):\n    return pow(n, p-2, p)"
    },
    {
        "original": "    return \"\".join([chr(((ord(ch) - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\ndef encode_rotate(s: str):\n    \"\"\"\n    returns encoded string by rotating every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 + ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\ndef decode_rotate(s: str):\n    \"\"\"\n    takes as input string encoded with encode_",
        "rewrite": "def decode_rotate(s: str):\n    \"\"\"\n    Decodes a string encoded by rotating every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])"
    },
    {
        "original": "    vowels = 'aeiou'\n    return ''.join([c for c in text if c not in vowels])\ndef remove_punctuation(text):\n    \"\"\"\n    remove_punctuation is a function that takes string and returns string without punctuation.\n    >>> remove_punctuation('')\n    ''\n    >>> remove_punctuation(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_punctuation('abcdef')\n    'bcdf'",
        "rewrite": "def remove_punctuation(text):\n    \"\"\"\n    remove_punctuation is a function that takes a string and returns a string without punctuation.\n    >>> remove_punctuation('')\n    ''\n    >>> remove_punctuation(\"abcdef\\nghijklm\")\n    'abcdefghijklm'\n    >>> remove_punctuation('abcdef')\n    'abcdef'\n    \"\"\"\n    punctuation = '''!()-[]{};:'\"\\,<>./?@#$%^&*_~'''\n    return ''.join([c for c in text if c not in punctuation])"
    },
    {
        "original": "    return all(l[i] < t for i in range(len(l)))\ndef above_threshold(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are above threshold t.\n    >>> above_threshold([1, 2, 4, 10], 100)\n    False\n    >>> above_threshold([1, 20, 4, 10], 5)\n    True\n    \"\"\"\n, no explanation, just code:\n    return all(l[i] > t for i in range(len(l)))",
        "rewrite": "def above_threshold(l: list, t: int):\n    return all(l[i] > t for i in range(len(l)))"
    },
    {
        "original": "    return x + y\ndef multiply(x: int, y: int):\n    \"\"\"Multiply two numbers x and y\n    >>> multiply(2, 3)\n    6\n    >>> multiply(5, 7)\n    42\n    \"\"\"\n, no explanation, just code:\n    return x * y\ndef subtract(x: int, y: int):\n    \"\"\"Subtract two numbers x and y\n    >>> subtract(2, 3)\n    1\n    >>> subtract(5, 7)\n    -4\n    \"\"\"\n, no explanation,",
        "rewrite": "def add(x: int, y: int):\n    return x + y\n\ndef multiply(x: int, y: int):\n    return x * y\n\ndef subtract(x: int, y: int):\n    return x - y"
    },
    {
        "original": "    if len(s0)!= len(s1):\n        return False\n    for i in range(len(s0)):\n        if s0[i]!= s1[i]:\n            return False\n    return True\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()",
        "rewrite": "if len(s0) != len(s1):\n    return False\nfor i in range(len(s0)):\n    if s0[i] != s1[i]:\n        return False\nreturn True\n\nif __name__ == '__main__':\n    import doctest\n    doctest.testmod()"
    },
    {
        "original": "    if n == 0:\n        return 0\n    elif n == 1:\n        return 1\n    else:\n        return fib(n-1) + fib(n-2)\ndef fib_recursive(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib_recursive(10)\n    55\n    >>> fib_recursive(1)\n    1\n    >>> fib_recursive(8)\n    21\n    \"\"\"\n    if n == 0:\n        return 0\n    elif n == 1:",
        "rewrite": "return 1\n    else:\n        return fib_recursive(n-1) + fib_recursive(n-2)\ndef fib_recursive(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib_recursive(10)\n    55\n    >>> fib_recursive(1)\n    1\n    >>> fib_recursive(8)\n    21\n    \"\"\""
    },
    {
        "original": "    return brackets == \"<<>\" or brackets == \">>>\" or brackets == \"<<>>\" or brackets == \">>>\" or brackets == \"<<>>>\"\ndef is_valid_bracket(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n    >>> is_valid_bracket(\"<\")\n    False\n    >>> is_valid_bracket(\"<>\")\n    True\n    >>> is_valid_bracket(\"<<><>>\")\n    True\n    >>>",
        "rewrite": "def is_valid_bracket(brackets: str):\n    brackets_list = ['<>', '<<>>', '>>>', '<<<>', '><', '<<>', '>><', '<>>']\n    return brackets in brackets_list\n\nprint(is_valid_bracket(\"<\")) # False\nprint(is_valid_bracket(\"<>\")) # True\nprint(is_valid_bracket(\"<<><>>\")) # True"
    },
    {
        "original": "    return all(x < y for x, y in zip(l, l[1:]))\ndef is_monotonic(l: list):\n    \"\"\"Return True if list elements are monotonically increasing or decreasing.\n    >>> is_monotonic([1, 2, 4, 20])\n    True\n    >>> is_monotonic([1, 20, 4, 10])\n    False\n    >>> is_monotonic([4, 1, 0, -10])\n    True\n    \"\"\"\n, no explanation, just code:\n    return all(",
        "rewrite": "return all(x < y for x, y in zip(l, l[1:]))def is_monotonic(l: list):\n    return all(x < y for x, y in zip(l, l[1:]))\n    '''Return True if list elements are monotonically increasing or decreasing.'''\n    >>> is_monotonic([1, 2, 4, 20])\n    True\n    >>> is_monotonic([1, 20, 4, 10])\n    False\n    >>> is_monotonic([4, 1, 0, -10])"
    },
    {
        "original": "    return list(set(l1) & set(l2))\ndef common_sort(l1: list, l2: list):\n    \"\"\"Return sorted unique common elements for two lists.\n    >>> common_sort([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_sort([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(",
        "rewrite": "def common_sort(l1: list, l2: list):\n    \"\"\"\n    Return sorted unique common elements for two lists.\n    >>> common_sort([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> common_sort([5, 3, 2, 8], [3, 2])\n    [2, 3]\n    \"\"\"\n    return sorted(list(set(l1) & set(l2)))"
    },
    {
        "original": "    if n == 1:\n        return 1\n    if n % 2 == 0:\n        return 2\n    for i in range(3, int(n**0.5)+1, 2):\n        while n % i == 0:\n            n //= i\n    return n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)",
        "rewrite": "if n == 1:\n    return 1\nif n % 2 == 0:\n    return 2\nfor i in range(3, int(n**0.5)+1, 2):\n    while n % i == 0:\n        n //= i\nreturn n\n\ndef largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\"\"\" \n    pass\n\nassert largest_prime_factor(13195) == 29\nassert largest_prime_factor(2048) == None"
    },
    {
        "original": "    sum = 0\n    for i in range(1, n+1):\n        sum += i\n    return sum\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()",
        "rewrite": "def calculate_sum(n):\n    total_sum = 0\n    for i in range(1, n+1):\n        total_sum += i\n    return total_sum\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()"
    },
    {
        "original": "    brackets = brackets.replace(\"(\", \")\").replace(\")\", \")\")\n    return brackets == brackets.replace(\"(\", \")\").replace(\")\", \")\")\ndef is_valid_bracket(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n    >>> is_valid_bracket(\"(\")\n    True\n    >>> is_valid_bracket(\"()\")\n    True\n    >>> is_valid_bracket(\"(()())",
        "rewrite": "def is_valid_bracket(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n    >>> is_valid_bracket(\"(\")\n    True\n    >>> is_valid_bracket(\"()\")\n    True\n    >>> is_valid_bracket(\"(()())\")\n    \"\"\"\n    brackets = brackets.replace(\"(\", \")\")\n    return brackets == brackets.replace(\")\", \"\")"
    },
    {
        "original": "    return [xs[1], xs[2] * xs[0] - xs[1] * xs[2]]\ndef integral(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 +....\n     Return integral of this polynomial in the same form.\n    >>> integral([3, 1, 2, 4, 5])\n    [1, 2, 3, 4, 5]\n    >>> integral([1,",
        "rewrite": "def integral(xs: list):\n    \"\"\"\n    xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ...\n    Return integral of this polynomial in the same form.\n    >>> integral([3, 1, 2, 4, 5])\n    [0, 3, 1, 1, 2, 2, 4, 4, 5, 5]\n    \"\"\"\n    result = [0]\n    for i in range(0, len(xs)):\n        result.append(xs[i])\n        if i > 0:\n            result.append(xs[i] / (i + 1))\n    return result"
    },
    {
        "original": "    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\nif __name__ == '__main__':\n    print(fibfib(1))\n    print(fibfib(5))\n    print(fibfib(8))",
        "rewrite": "def fibfib(n):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n\nif __name__ == '__main__':\n    print(fibfib(1))\n    print(fibfib(5))\n    print(fibfib(8))"
    },
    {
        "original": "    vowels = ['a', 'e', 'i', 'o', 'u', 'y']\n    return sum([1 for char in s if char in vowels])\ndef main():\n    print(FIX)\n    print(vowels_count(\"abcde\"))\n    print(vowels_count(\"ACEDY\"))\nif __name__ == '__main__':\n    main()",
        "rewrite": "vowels = ['a', 'e', 'i', 'o', 'u', 'y']\n\ndef vowels_count(s):\n    return sum([1 for char in s if char.lower() in vowels])\n\ndef main():\n    print(vowels_count(\"abcde\"))\n    print(vowels_count(\"ACEDY\"))\n\nif __name__ == '__main__':\n    main()"
    },
    {
        "original": "    if shift > len(str(x)):\n        return str(x)[::-1]\n    else:\n        return str(x)[shift:] + str(x)[:shift]\n#",
        "rewrite": "if shift > len(str(x)):\n    return str(x)[::-1]\nelse:\n    return str(x)[shift:] + str(x)[:shift]"
    },
    {
        "original": "    return sum(c for c in s if c.isupper())\nif __name__ == \"__main__\":\n    print(digitSum(\"\"))\n    print(digitSum(\"abAB\"))\n    print(digitSum(\"abcCd\"))\n    print(digitSum(\"helloE\"))\n    print(digitSum(\"woArBld\"))\n    print(digitSum(\"aAaaaXa\"))",
        "rewrite": "def digitSum(s):\n    return sum(c for c in s if c.isupper())\n\nif __name__ == \"__main__\":\n    print(digitSum(\"\"))\n    print(digitSum(\"abAB\"))\n    print(digitSum(\"abcCd\"))\n    print(digitSum(\"helloE\"))\n    print(digitSum(\"woArBld\"))\n    print(digitSum(\"aAaaaXa\"))"
    },
    {
        "original": "    if s.count(\" \") == 0:\n        return n\n    else:\n        return n - s.count(\" \")\n#",
        "rewrite": "if s.count(\" \") == 0:\n    return n\nelse:\n    return n - s.count(\" \")"
    },
    {
        "original": "    def find_smallest_even_value(arr):\n        \"\"\"\n        \"Given an array representing a branch of a tree that has non-negative integer nodes\n        your task is to pluck one of the nodes and return it.\n        The plucked node should be the node with the smallest even value.\n        If multiple nodes with the same smallest even value are found return the node that has smallest index.\n        The plucked node should be returned in a list, [ smalest_value, its index ],\n        If there are no even values or the given array is empty, return",
        "rewrite": "def find_smallest_even_value(arr):\n    smallest_value = float('inf')\n    smallest_index = -1\n    for i in range(len(arr)):\n        if arr[i] % 2 == 0 and arr[i] < smallest_value:\n            smallest_value = arr[i]\n            smallest_index = i\n    if smallest_index == -1:\n        return []\n    else:\n        return [smallest_value, smallest_index]"
    },
    {
        "original": "    if len(lst) == 0:\n        return -1\n    else:\n        return max(lst)\ndef search2(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        search([4, 1,",
        "rewrite": "def search(lst):\n    if len(lst) == 0:\n        return -1\n    else:\n        return max(lst)\n\ndef search2(lst):\n    if len(lst) == 0:\n        return -1\n    else:\n        freq_dict = {}\n        for num in lst:\n            if num in freq_dict:\n                freq_dict[num] += 1\n            else:\n                freq_dict[num] = 1\n\n        for num, freq in freq_dict.items():\n            if num > 0 and num <= freq:\n                return num\n\n        return -1"
    },
    {
        "original": "    if not lst:\n        return []\n    if len(lst) == 1:\n        return lst\n    if len(lst) == 2:\n        if lst[0] > lst[1]:\n            return [lst[1], lst[0]]\n        else:\n            return [lst[0], lst[1]]\n    if len(lst) == 3:\n        if lst[0] > lst[1]:\n            if lst[0] > lst[2]:\n                return [l",
        "rewrite": "if not lst:\n    return []\nelif len(lst) == 1:\n    return lst\nelif len(lst) == 2:\n    if lst[0] > lst[1]:\n        return [lst[1], lst[0]]\n    else:\n        return [lst[0], lst[1]]\nelif len(lst) == 3:\n    if lst[0] > lst[1]:\n        if lst[0] > lst[2]:\n            return [lst[1], lst[2], lst[0]]\n        else:\n            return [lst[1], lst[0], lst[2]]\n    else:\n        if lst[1] > lst[2]:\n            return [lst[0], lst[2], lst[1]]\n        else:\n            return [lst[0], lst[1], lst[2]]"
    },
    {
        "original": "    sides = (a, b, c)\n    sides = sorted(sides)\n    if sides[0] + sides[1] > sides[2]:\n        return -1\n    else:\n        return round(sides[0] * sides[1] / 2, 2)\n#",
        "rewrite": "sides = (a, b, c)\nsides = sorted(sides)\nif sides[0] + sides[1] > sides[2]:\n    return -1\nelse:\n    return round(sides[0] * sides[1] / 2, 2)"
    },
    {
        "original": "    if len(q) == 0:\n        return False\n    if len(q) == 1:\n        return True\n    if len(q) == 2:\n        return q[0] + q[1] <= w\n    if len(q) == 3:\n        return q[0] + q[1] + q[2] <= w\n    if len(q) == 4:\n        return q[0] + q[1] + q[2] + q[3] <= w\n    if len(q) == 5:\n        return",
        "rewrite": "if len(q) == 0:\n    return False\nif len(q) == 1:\n    return True\nif len(q) == 2:\n    return q[0] + q[1] <= w\nif len(q) == 3:\n    return q[0] + q[1] + q[2] <= w\nif len(q) == 4:\n    return q[0] + q[1] + q[2] + q[3] <= w\nif len(q) == 5:\n    return False"
    },
    {
        "original": "    n = len(arr)\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    if n == 3:\n        return 2\n    if n == 4:\n        return 3\n    if n == 5:\n        return 4\n    if n == 6:\n        return 5\n    if n == 7:\n        return 6\n    if n == 8:\n        return 7\n    if n == 9:\n        return 8\n    if n == 10:\n        return 9\n    if n == 11:\n        return",
        "rewrite": "n = len(arr)\nreturn n - 1"
    },
    {
        "original": "    if len(lst1) == len(lst2):\n        return lst1\n    else:\n        return []\n#",
        "rewrite": "if len(lst1) == len(lst2):\n    return lst1\nelse:\n    return []"
    },
    {
        "original": "    if a < 100:\n        return False\n    for i in range(2, int(a/3)):\n        if a % i == 0:\n            return False\n    return True\n#",
        "rewrite": "if a < 100:\n    return False\nfor i in range(2, int(a/2)+1):\n    if a % i == 0:\n        return False\nreturn True"
    },
    {
        "original": "    return x**n == 1\ndef is_prime(n):\n    \"\"\"Your task is to write a function that returns true if a number n is prime and\n    false in other cases.\n    n is prime if n is divisible by 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157",
        "rewrite": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"
    },
    {
        "original": "    if a == 0:\n        return True\n    if a < 0:\n        return False\n    if a % 1 == 0:\n        return a == int(a)\n    if a % 2 == 0:\n        return iscube(a/2)\n    if a % 3 == 0:\n        return iscube(a/3)\n    if a % 4 == 0:\n        return iscube(a/4)\n    if a % 5 == 0:\n        return iscube(a/5)\n    if a % 6 == 0:\n        return",
        "rewrite": "if a == 0:\n    return True\nif a < 0:\n    return False\nif a % 1 == 0:\n    return a == int(a)\nif a % 2 == 0:\n    return iscube(a/2)\nif a % 3 == 0:\n    return iscube(a/3)\nif a % 4 == 0:\n    return iscube(a/4)\nif a % 5 == 0:\n    return iscube(a/5)\nif a % 6 == 0:\n    return True"
    },
    {
        "original": "    return len(str(num))\n#",
        "rewrite": "return len(str(num))"
    },
    {
        "original": "    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    return binary\n#",
        "rewrite": "def decimal_to_binary(decimal):\n    binary = ''\n    while decimal > 0:\n        binary = str(decimal % 2) + binary\n        decimal = decimal // 2\n    return binary"
    },
    {
        "original": "    if len(s) < 3:\n        return False\n    for i in range(len(s)):\n        if i % 3 == 0:\n            if s[i] in s[i+1:]:\n                return False\n        else:\n            if s[i] in s[i+1:]:\n                return False\n    return True\nprint(is_happy('a'))\nprint(is_happy('aa'))\nprint(is_happy('abcd'))\nprint(is_happy('aabb'))\nprint(is",
        "rewrite": "def is_happy(s):\n    if len(s) < 3:\n        return False\n    for i in range(len(s)):\n        if s[i] in s[i+1:]:\n            return False\n    return True\n\nprint(is_happy('a'))\nprint(is_happy('aa'))\nprint(is_happy('abcd'))\nprint(is_happy('aabb'))"
    },
    {
        "original": "    return [\n        'A+' if grades[0] >= 4.0 else 'A' if grades[0] >= 3.7 else 'A-' if grades[0] >= 3.3 else 'B+' if grades[0] >= 3.0 else 'B' if grades[0] >= 2.7 else 'B-' if grades[0] >= 2.3 else 'C+' if grades[0] >= 2.0 else 'C' if grades[0] >= 1.7 else 'C-' if grades[0] >= 1.3 else 'D",
        "rewrite": "return [\n    'A+' if grades[0] >= 4.0 else \n    'A' if grades[0] >= 3.7 else \n    'A-' if grades[0] >= 3.3 else \n    'B+' if grades[0] >= 3.0 else \n    'B' if grades[0] >= 2.7 else \n    'B-' if grades[0] >= 2.3 else \n    'C+' if grades[0] >= 2.0 else \n    'C' if grades[0] >= 1.7 else \n    'C-' if grades[0] >= 1.3 else \n    'D'\n]"
    },
    {
        "original": "    if string == '':\n        return False\n    else:\n        if string[0] == '0':\n            return False\n        else:\n            for i in range(1, len(string)):\n                if string[i] == '0':\n                    return False\n                else:\n                    if string[i] == '1':\n                        return False\n                    else:\n                        for j in range(2, int(string[i])):\n                            if string[i] % j == 0:\n                                return False\n            return True\nprint(prime_",
        "rewrite": "def is_prime(string):\n    if string == '':\n        return False\n    elif string[0] == '0':\n        return False\n    else:\n        for i in range(1, len(string)):\n            if string[i] == '0' or string[i] == '1':\n                return False\n            else:\n                for j in range(2, int(string[i])):\n                    if int(string[i]) % j == 0:\n                        return False\n        return True\n\nprint(is_prime(\"1234\"))"
    },
    {
        "original": "    return len(str(n)) - len(str(n % 10))\ndef starts_one_ends_2(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    return len(str(n)) - len(str(n % 10))\ndef starts_one_ends_3(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1",
        "rewrite": "def starts_one_ends_3(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    return 2 * 9 * (10**(n-2)) + 10**(n-1) - 10**(n-2)"
    },
    {
        "original": "    return bin(N)[2:]\n#",
        "rewrite": "return format(N, 'b')"
    },
    {
        "original": "    even = []\n    odd = []\n    for i in lst:\n        if i % 2 == 0:\n            even.append(i)\n        else:\n            odd.append(i)\n    return even + odd\n#",
        "rewrite": "even = []\nodd = []\nfor i in lst:\n    if i % 2 == 0:\n        even.append(i)\n    else:\n        odd.append(i)\nreturn even + odd"
    },
    {
        "original": "    s = s.replace(' ', '')\n    s = s.replace('\\n', '')\n    s = s.replace('\\t', '')\n    s = s.replace('\\r', '')\n    s = s.replace('\\0', '')\n    s = s.replace('\\x0c', '')\n    s = s.replace('\\x0b', '')\n    s = s.replace('\\x0d', '')\n    s = s.replace('\\x1b', '')\n    s = s",
        "rewrite": "s = re.sub(r'\\s', '', s)"
    },
    {
        "original": "    return [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\ndef get_column(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1,",
        "rewrite": "def find_all(lst, x):\n    return [(i, j) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n\ndef get_column(lst, x):\n    return find_all(lst, x)"
    },
    {
        "original": "    #",
        "rewrite": "#"
    },
    {
        "original": "    #",
        "rewrite": "#"
    },
    {
        "original": "    if len(lst) == 0:\n        return None\n    if len(lst) == 1:\n        return lst[0]\n    if lst[0] > lst[1]:\n        return lst[0]\n    for i in range(1, len(lst)):\n        if lst[i] > lst[i-1]:\n            return lst[i]\n    return None\n#",
        "rewrite": "if len(lst) == 0:\n    return None\nelif len(lst) == 1 or lst[0] > lst[1]:\n    return lst[0]\nfor i in range(1, len(lst)):\n    if lst[i] > lst[i-1]:\n        return lst[i]\nreturn None"
    },
    {
        "original": "    return S.count('.') + S.count('?') + S.count('!')\ndef is_bored(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n    For example:\n    >>> is_bored(\"Hello world\")\n    0\n    >>> is_bored(\"The sky is blue. The sun is",
        "rewrite": "def is_bored(S):\n    return S.lower().count(' i ') + S.count('.') + S.count('?') + S.count('!')"
    },
    {
        "original": "    if x + y == z:\n        return True\n    else:\n        return False\nprint(any_int(5, 2, 7))\nprint(any_int(3, 2, 2))\nprint(any_int(3, -2, 1))\nprint(any_int(3.6, -2.2, 2))\n#",
        "rewrite": "def any_int(x, y, z):\n    return x + y == z\n\nprint(any_int(5, 2, 7))\nprint(any_int(3, 2, 2))\nprint(any_int(3, -2, 1))\nprint(any_int(3.6, -2.2, 2))"
    },
    {
        "original": "    #",
        "rewrite": "#"
    },
    {
        "original": "    #",
        "rewrite": "#"
    },
    {
        "original": "    return all(isinstance(key, str) for key in dict.keys())\ndef check_dict_case(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    check_dict_case({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    check_dict_case({\"a\":\"apple\", \"A\":\"banana\", \"B",
        "rewrite": "def check_dict_case(dict):\n    if not dict:\n        return False\n    \n    is_lowercase = all(isinstance(key, str) and key.islower() for key in dict.keys())\n    is_uppercase = all(isinstance(key, str) and key.isupper() for key in dict.keys())\n    \n    if is_lowercase or is_uppercase:\n        return True\n    else:\n        return False"
    },
    {
        "original": "    def count_up_to(n):\n        \"\"\"Implement a function that takes an non-negative integer and returns an array of the first n\n        integers that are prime numbers and less than n.\n        for example:\n        count_up_to(5) => [2,3]\n        count_up_to(11) => [2,3,5,7]\n        count_up_to(0) => []\n        count_up_to(20) => [2,3,5,7,11,13,17,19]",
        "rewrite": "def count_up_to(n):\n    def is_prime(num):\n        if num < 2:\n            return False\n        for i in range(2, int(num ** 0.5) + 1):\n            if num % i == 0:\n                return False\n        return True\n    \n    primes = []\n    for i in range(2, n):\n        if is_prime(i):\n            primes.append(i)\n    \n    return primes\n\nprint(count_up_to(5))\nprint(count_up_to(11))\nprint(count_up_to(0))\nprint(count_up_to(20))"
    },
    {
        "original": "    return a * b\n#",
        "rewrite": "return a * b"
    },
    {
        "original": "    count = 0\n    for i in range(len(s)):\n        if s[i] in 'AEIOU':\n            if i % 2 == 0:\n                count += 1\n    return count\ndef count_upper_vowels(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in odd indices.\n    For example:\n    count_upper_vowels('aBCdEf') returns 1\n    count_upper_vowels('abcdefg') returns 0\n    count",
        "rewrite": "def count_upper_vowels(s):\n    count = 0\n    for i in range(len(s)):\n        if s[i] in 'AEIOU' and i % 2 == 0:\n            count += 1\n    return count"
    },
    {
        "original": "    if value == \"\":\n        return 0\n    elif value == \".\":\n        return 0\n    elif value == \"-\":\n        return 0\n    elif value == \"+\":\n        return 0\n    elif value == \"\":\n        return 0\n    elif value == \".\":\n        return 0\n    elif value == \"-\":\n        return 0\n    elif value == \"+\":\n        return 0\n    elif value == \"\":\n        return 0\n    elif value == \".\":\n        return 0\n    elif value ==",
        "rewrite": "if value == \"\" or value == \".\" or value == \"-\" or value == \"+\":\n        return 0"
    },
    {
        "original": "    if n % 2 == 0:\n        return [n] * (n // 2) + [n // 2]\n    else:\n        return [n] * (n // 2) + [n // 2 + 1]\ndef make_a_pile_2(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number",
        "rewrite": "def make_a_pile_2(n):\n    if n % 2 == 0:\n        return [n] * (n // 2) + [n // 2]\n    else:\n        return [n] * (n // 2) + [n // 2 + 1]"
    },
    {
        "original": "    return [word.strip() for word in s.split(', ')]\n#",
        "rewrite": "return [word.strip() for word in s.split(', ')]"
    },
    {
        "original": "    if x > y:\n        return -1\n    else:\n        for i in range(x, y+1):\n            if i % 2 == 0:\n                return i\ndef main():\n    print(choose_num(12, 15))\n    print(choose_num(13, 12))\nif __name__ == '__main__':\n    main()",
        "rewrite": "def choose_num(x, y):\n    if x > y:\n        return -1\n    else:\n        for i in range(x, y+1):\n            if i % 2 == 0:\n                return i\n\ndef main():\n    print(choose_num(12, 15))\n    print(choose_num(13, 12))\n\nif __name__ == '__main__':\n    main()"
    },
    {
        "original": "    if n > m:\n        return -1\n    else:\n        return bin(n + m - 1)\n#",
        "rewrite": "if n > m:\n    return -1\nelse:\n    return bin(n + m - 1)"
    },
    {
        "original": "    return [x[i] for i in range(len(x)) if x[i] % 2 == 0]\n#",
        "rewrite": "return [x[i] for i in range(len(x)) if x[i] % 2 == 0]"
    },
    {
        "original": "    if len(arr) == 0:\n        return []\n    if len(arr) == 1:\n        return [arr[0]]\n    arr.sort()\n    arr = [int(i) for i in str(arr[0])]\n    for i in range(len(arr)):\n        arr[i] = arr[i] + 1\n    arr = [str(i) for i in arr]\n    return arr\n#",
        "rewrite": "if len(arr) == 0:\n    return []\nif len(arr) == 1:\n    return [arr[0]]\narr.sort()\narr = [int(i) for i in str(arr[0])]\nfor i in range(len(arr)):\n    arr[i] = arr[i] + 1\narr = [str(i) for i in arr]\nreturn arr"
    },
    {
        "original": "    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 1]\n    else:\n        return [1] + [f(n - 1) for _ in range(1, n)]\n#",
        "rewrite": "if n == 0:\n    return [1]\nelif n == 1:\n    return [1, 1]\nelse:\n    return [1] + [f(n - 1) for _ in range(1, n)]"
    },
    {
        "original": "    if n == 1:\n        return (1, 1)\n    elif n == 2:\n        return (1, 2)\n    elif n % 2 == 0:\n        return even_odd_palindrome(n // 2)\n    else:\n        return even_odd_palindrome(3 * n + 1)\nif __name__ == \"__main__\":\n    print(even_odd_palindrome(12))\n    print(even_odd_palindrome(3))\n    print(even_odd_palindrome",
        "rewrite": "def even_odd_palindrome(n):\n    if n == 1:\n        return (1, 1)\n    elif n == 2:\n        return (1, 2)\n    elif n % 2 == 0:\n        return even_odd_palindrome(n // 2)\n    else:\n        return even_odd_palindrome(3 * n + 1)\n\nif __name__ == \"__main__\":\n    print(even_odd_palindrome(12))\n    print(even_odd_palindrome(3))"
    },
    {
        "original": "    return sum(1 for i in arr if i > 0)\ndef count_nums_2(arr):\n    \"\"\"\n    Write a function count_nums which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> count_nums_2([]) == 0\n    >>> count_nums_2([-1, 11, -11",
        "rewrite": "def count_nums_2(arr):\n    return sum(1 for i in arr if i > 0)"
    },
    {
        "original": "    if len(arr)==0:\n        return True\n    #",
        "rewrite": "if len(arr)==0:\n    return True"
    },
    {
        "original": "    if len(lst1)!= len(lst2):\n        return \"NO\"\n    else:\n        for i in range(len(lst1)):\n            if lst1[i] % 2!= lst2[i]:\n                return \"NO\"\n        return \"YES\"\n#",
        "rewrite": "if len(lst1) != len(lst2):\n    return \"NO\"\nelse:\n    for i in range(len(lst1)):\n        if lst1[i] % 2 != lst2[i]:\n            return \"NO\"\n    return \"YES\""
    },
    {
        "original": "    d = {}\n    for letter in test:\n        if letter in d:\n            d[letter] += 1\n        else:\n            d[letter] = 1\n    return d\ndef most_common(test):\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    Example:\n    most_common('a b c') == {'a': 2, 'b': 2, '",
        "rewrite": "def most_common(test):\n    d = {}\n    for word in test.split(\" \"):\n        for letter in word:\n            if letter in d:\n                d[letter] += test.count(letter)\n            else:\n                d[letter] = test.count(letter)\n    most_common_letters = {}\n    max_count = max(d.values())\n    for key, value in d.items():\n        if value == max_count:\n            most_common_letters[key] = value\n    return most_common_letters"
    },
    {
        "original": "    if c in s:\n        s = s.replace(c, \"\")\n        return s, True\n    else:\n        return s, False\n#",
        "rewrite": "if c in s:\n    s = s.replace(c, \"\")\n    return s, True\nelse:\n    return s, False"
    },
    {
        "original": "    return [len(lst[i]) % 2 for i in range(len(lst))]\ndef even_count(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of even elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of even digits in the i'th string of the input.\n    >>> even_count(['1234567'])\n    [\"the number of even elements",
        "rewrite": "def even_count(lst):\n    return [sum(int(digit) % 2 == 0 for digit in string) for string in lst]"
    },
    {
        "original": "    if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    min_sum = float('inf')\n    for i in range(len(nums)):\n        if i == 0:\n            min_sum = nums[i]\n        else:\n            min_sum = min(min_sum, nums[i])\n        if min_sum > 0:\n            min_sum += nums[i]\n    return min_sum\n#",
        "rewrite": "if not nums:\n        return 0\n    if len(nums) == 1:\n        return nums[0]\n    min_sum = float('inf')\n    current_sum = 0\n    for num in nums:\n        current_sum = min(current_sum + num, num)\n        min_sum = min(min_sum, current_sum)\n    return min_sum"
    },
    {
        "original": "    #",
        "rewrite": "#\""
    },
    {
        "original": "    def sort_array(arr):\n        \"\"\"\n        In this Kata, you have to sort an array of non-negative integers according to\n        number of ones in their binary representation in ascending order.\n        For similar number of ones, sort based on decimal value.\n        It must be implemented like this:\n        >>> sort_array([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n        >>> sort_array([-2, -3, -4, -5, -6]) == [-6, -5, -4",
        "rewrite": "def sort_array(arr):\n    return sorted(arr, key=lambda x: (bin(x).count('1'), x))"
    },
    {
        "original": "    #",
        "rewrite": "#"
    },
    {
        "original": "    if word == \"\":\n        return \"\"\n    if word[0] == word[-1]:\n        return \"\"\n    for i in range(len(word)):\n        if word[i] == \"a\" or word[i] == \"e\" or word[i] == \"i\" or word[i] == \"o\" or word[i] == \"u\":\n            return word[i]\n    return \"\"\nprint(get_closest_vowel(\"yogurt\"))\nprint(get_cl",
        "rewrite": "def get_closest_vowel(word):\n    if word == \"\":\n        return \"\"\n    \n    if word[0] == word[-1]:\n        return \"\"\n    \n    vowels = \"aeiou\"\n    \n    for i in range(len(word)):\n        if word[i] in vowels:\n            return word[i]\n    \n    return \"\"\n\nprint(get_closest_vowel(\"yogurt\"))"
    },
    {
        "original": "    def match_parens(lst):\n        '''\n        You are given a list of two strings, both strings consist of open\n        parentheses '(' or close parentheses ')' only.\n        Your job is to check if it is possible to concatenate the two strings in\n        some order, that the resulting string will be good.\n        A string S is considered to be good if and only if all parentheses in S\n        are balanced. For example: the string '(())()' is good, while the string\n        '())' is not.\n        Return 'Yes'",
        "rewrite": "def match_parens(lst):\n    open_count = lst[0].count('(') + lst[1].count('(')\n    close_count = lst[0].count(')') + lst[1].count(')')\n    \n    if open_count == close_count:\n        return 'Yes'\n    else:\n        return 'No'"
    },
    {
        "original": "    def find_k(arr, k):\n        if k == 0:\n            return arr\n        if k == 1:\n            return max(arr)\n        if k == 2:\n            return min(arr)\n        if k == 3:\n            return max(arr) + min(arr)\n        if k == 4:\n            return max(arr)\n        if k == 5:\n            return min(arr)\n        if k == 6:\n            return max(arr) + min(arr)\n        if k == 7:\n            return max(",
        "rewrite": "def find_k(arr, k):\n    if k == 0:\n        return arr\n    elif k == 1:\n        return max(arr)\n    elif k == 2:\n        return min(arr)\n    elif k == 3 or k == 6:\n        return max(arr) + min(arr)\n    elif k == 4 or k == 7:\n        return max(arr)\n    elif k == 5:\n        return min(arr)"
    },
    {
        "original": "    even_sum = 0\n    for i in range(len(lst)):\n        if i % 2 == 0:\n            even_sum += lst[i]\n    return even_sum\n#",
        "rewrite": "even_sum = sum(lst[i] for i in range(len(lst)) if i % 2 == 0) \nreturn even_sum"
    },
    {
        "original": "    #",
        "rewrite": "\"#\""
    },
    {
        "original": "    if n == 1:\n        return [1]\n    if n % 2 == 0:\n        return [n//2] + get_odd_collatz(n//2)\n    return [n*3+1] + get_odd_collatz(n*3+1)\nif __name__ == '__main__':\n    print(get_odd_collatz(5))\n    print(get_odd_collatz(6))\n    print(get_odd_collatz(7))\n    print(get_odd_collatz(",
        "rewrite": "def get_odd_collatz(n):\n    if n == 1:\n        return [1]\n    if n % 2 == 0:\n        return [n // 2] + get_odd_collatz(n // 2)\n    return [n * 3 + 1] + get_odd_collatz(n * 3 + 1)\n\nif __name__ == '__main__':\n    print(get_odd_collatz(5))\n    print(get_odd_collatz(6))\n    print(get_odd_collatz(7))"
    },
    {
        "original": "    if date == '':\n        return False\n    if len(date) < 1:\n        return False\n    if len(date) > 10:\n        return False\n    if len(date) == 10:\n        if int(date[0:2]) < 1 or int(date[0:2]) > 12:\n            return False\n        if int(date[3:5]) < 1 or int(date[3:5]) > 31:\n            return False\n        if int(date[6:8]) < 1 or int(date[6:8",
        "rewrite": "if date == '' or len(date) < 1 or len(date) > 10:\n    return False\n    \nif len(date) == 10:\n    if int(date[0:2]) < 1 or int(date[0:2]) > 12:\n        return False\n    if int(date[3:5]) < 1 or int(date[3:5]) > 31:\n        return False\n    if int(date[6:8]) < 1 or int(date[6:8]) > 99:\n        return False"
    },
    {
        "original": "    return len(txt.split())\ndef reverse_string(txt):\n    '''\n    Given a string, return a new string with the reverse of the original string\n    Examples\n    reverse_string(\"Hello world!\") \u279e \"dlrow olleH\"\n    '''\n    return txt[::-1]\ndef is_palindrome(txt):\n    '''\n    Given a string, return true if the string is a palindrome, false otherwise\n    Examples\n    is_palindrome(\"Hello world!\") \u279e",
        "rewrite": "def count_words(txt):\n    return len(txt.split())\n\ndef reverse_string(txt):\n    '''\n    Given a string, return a new string with the reverse of the original string\n    Examples\n    reverse_string(\"Hello world!\") \u279e \"dlrow olleH\"\n    '''\n    return txt[::-1]\n\ndef is_palindrome(txt):\n    '''\n    Given a string, return true if the string is a palindrome, false otherwise\n    Examples\n    is_palindrome(\"Hello world!\") \u279e\" . No need to explain. Just write code:\n    '''\n\n    return txt == txt[::-1]"
    },
    {
        "original": "    if len(lst) <= 1:\n        return True\n    else:\n        for i in range(len(lst) - 1):\n            if lst[i] > lst[i+1]:\n                return False\n        return True\n#",
        "rewrite": "def is_sorted(lst):\n    if len(lst) <= 1:\n        return True\n    else:\n        for i in range(len(lst) - 1):\n            if lst[i] > lst[i+1]:\n                return False\n        return True"
    },
    {
        "original": "    if interval1[0] <= interval2[0] and interval1[1] >= interval2[1]:\n        return \"YES\"\n    elif interval1[0] <= interval2[0] and interval1[1] < interval2[1]:\n        return \"NO\"\n    elif interval1[0] > interval2[0] and interval1[1] <= interval2[1]:\n        return \"NO\"\n    elif interval1[0] > interval2[0] and interval1[1] > interval2[1]:\n        return",
        "rewrite": "if interval1[0] <= interval2[0] and interval1[1] >= interval2[1]:\n        return \"YES\"\n    elif interval1[0] <= interval2[0] and interval1[1] < interval2[1]:\n        return \"NO\"\n    elif interval1[0] > interval2[0] and interval1[1] <= interval2[1]:\n        return \"NO\"\n    elif interval1[0] > interval2[0] and interval1[1] > interval2[1]:\n        return\""
    },
    {
        "original": "    #",
        "rewrite": "#"
    },
    {
        "original": "    def minPath(grid, k):\n        \"\"\"\n        Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n        each cell of the grid contains a value. Every integer in the range [1, N * N]\n        inclusive appears exactly once on the cells of the grid.\n        You have to find the minimum path of length k in the grid. You can start\n        from any cell, and in each step you can move to any of the neighbor cells,\n        in other words, you can go to cells which share an edge with",
        "rewrite": "def minPath(grid, k):\n    N = len(grid)\n    visited = [[False for _ in range(N)] for _ in range(N)]\n    \n    def backtrack(row, col, remaining):\n        if remaining == 0:\n            return 0\n        \n        visited[row][col] = True\n        min_path = float('inf')\n        \n        for dx, dy in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n            new_row, new_col = row + dx, col + dy\n            \n            if 0 <= new_row < N and 0 <= new_col < N and not visited[new_row][new_col]:\n                min_path = min(min_path, grid[row][col] + backtrack(new_row, new_col, remaining - 1))\n                \n        visited[row][col] = False\n        \n        return min_path\n    \n    min_len = float('inf')\n    for i in range(N):\n        for j in range(N):\n            min_len = min(min_len, backtrack(i, j, k - 1))\n            \n    return min_len"
    },
    {
        "original": "    if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 2]\n    elif n == 2:\n        return [1, 2, 3]\n    else:\n        return [1] + tri(n - 1) + tri(n - 2) + tri(n - 3)\n#",
        "rewrite": "if n == 0:\n        return [1]\n    elif n == 1:\n        return [1, 2]\n    elif n == 2:\n        return [1, 2, 3]\n    else:\n        return [1] + tri(n - 1) + tri(n - 2) + tri(n - 3)"
    },
    {
        "original": "    if n == 0:\n        return 0\n    if n % 10 == 0:\n        return 0\n    return n % 10\n#",
        "rewrite": "if n == 0:\n    return 0\nelif n % 10 == 0:\n    return 0\nelse:\n    return n % 10"
    },
    {
        "original": "    if string == '':\n        return False\n    stack = []\n    for char in string:\n        if char == '[' or char == '{' or char == '(' :\n            stack.append(char)\n        elif char == ']' and len(stack) > 0:\n            stack.pop()\n        elif char == '}' and len(stack) > 0:\n            stack.pop()\n        elif char == ']' and len(stack) > 0:\n            stack.pop()\n        elif char == '",
        "rewrite": "def check_parentheses(string):\n    if string == '':\n        return False\n    stack = []\n    for char in string:\n        if char in ['[', '{', '(']:\n            stack.append(char)\n        elif char == ']' and stack and stack[-1] == '[':\n            stack.pop()\n        elif char == '}' and stack and stack[-1] == '{':\n            stack.pop()\n        elif char == ')' and stack and stack[-1] == '(':\n            stack.pop()\n    return not stack"
    },
    {
        "original": "    return sum([x**2 for x in lst])\ndef sum_squares_2(lst):\n    \"\"\"You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7]",
        "rewrite": "def sum_squares_2(lst):\n    return sum([(x**2) for x in lst])"
    },
    {
        "original": "    if txt[-1].isalpha():\n        return False\n    else:\n        return True\n#",
        "rewrite": "if not txt[-1].isalpha():\n        return True\n    else:\n        return False"
    },
    {
        "original": "    if len(arr) == 0:\n        return -1\n    else:\n        return max(range(1, len(arr)), key=lambda x: arr[x] >= arr[x-1])\ndef can_arrange_2(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n    Examples:\n    can_arrange([1,",
        "rewrite": "def can_arrange_2(arr):\n    if len(arr) == 0:\n        return -1\n    else:\n        return max(range(1, len(arr)), key=lambda x: arr[x] >= arr[x-1])"
    },
    {
        "original": "    if lst:\n        a = max(lst)\n        b = min(lst)\n        return (a, b)\n    else:\n        return None, None\n#",
        "rewrite": "if lst:\n    a = max(lst)\n    b = min(lst)\n    return (a, b)\nelse:\n    return None, None"
    },
    {
        "original": "    if a > b:\n        return a\n    elif a < b:\n        return b\n    else:\n        return None\nprint(compare_one(1, 2.5))\nprint(compare_one(1, \"2,3\"))\nprint(compare_one(\"5,1\", \"6\"))\nprint(compare_one(\"1\", 1))\nprint(compare_one(\"1\", \"1\"))\nprint(compare_one(\"1\", \"1.1\"))\nprint(compare_one(\"1\", \"1",
        "rewrite": "def compare_one(a, b):\n    if a > b:\n        return a\n    elif a < b:\n        return b\n    else:\n        return None\n\nprint(compare_one(1, 2.5))\nprint(compare_one(1, \"2,3\"))\nprint(compare_one(\"5,1\", \"6\"))\nprint(compare_one(\"1\", 1))\nprint(compare_one(\"1\", \"1\"))\nprint(compare_one(\"1\", \"1.1\"))\nprint(compare_one(\"1\", \"1\") # No need to explain. Just write code"
    },
    {
        "original": "    if n % 2 == 0:\n        return n == 4\n    else:\n        return n == 6\ndef is_equal_to_sum_odd(n):\n    \"\"\"Evaluate whether the given number n can be written as the sum of exactly 4 positive odd numbers\n    Example\n    is_equal_to_sum_odd(4) == False\n    is_equal_to_sum_odd(6) == True\n    is_equal_to_sum_odd(8) == False\n    \"\"\"\n, no explanation, just code:\n    if",
        "rewrite": "if n % 2 == 0:\n        return n == 4\n    else:\n        return n == 6\ndef is_equal_to_sum_odd(n):\n    if n %4 == 0:\n        return False\n    elif n % 4 == 2:\n        return  True\n    else:\n        return False"
    },
    {
        "original": "    if n == 0:\n        return 1\n    else:\n        return n * special_factorial(n - 1)\n#",
        "rewrite": "if n == 0:\n    return 1\nelse:\n    return n * special_factorial(n - 1)"
    },
    {
        "original": "    return text.replace(' ', '_')\ndef fix_spaces_2(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    fix_spaces_2(\"Example\") == \"Example\"\n    fix_spaces_2(\"Example 1\") == \"Example_1\"\n    fix_spaces_2(\" Example 2\") == \"_Example_2\"\n    fix_spaces_2(\"",
        "rewrite": "def fix_spaces_2(text):\n    \"\"\"\n    Given a string text, replace all spaces in it with underscores, \n    and if a string has more than 2 consecutive spaces, \n    then replace all consecutive spaces with - \n    \"\"\"\n    return '-'.join('_' if len(x) > 2 else x for x in text.replace(' ', ' ').split())\n    \n# Test cases\nprint(fix_spaces_2(\"Example\"))  # Output: \"Example\"\nprint(fix_spaces_2(\"Example 1\"))  # Output: \"Example_1\"\nprint(fix_spaces_2(\" Example 2\"))  # Output: \"_Example_2\""
    },
    {
        "original": "    if len(file_name) > 3 and file_name.count('.') == 1 and file_name[0].isalpha() and file_name[1] in ['.', 't', 'e', 'x', 'e','m', 'a', 'p', 't']:\n        return 'Yes'\n    else:\n        return 'No'\n#",
        "rewrite": "if len(file_name) > 3 and file_name.count('.') == 1 and file_name[0].isalpha() and file_name[1] in ['.', 't', 'e', 'x', 'e', 'm', 'a', 'p', 't']:\n    return 'Yes'\nelse:\n    return 'No'"
    },
    {
        "original": "    return sum([x*x for x in lst])\ndef sum_squares_2(lst):\n    \"\"\"\"\n    This function will take a list of integers. For all entries in the list, the function shall square the integer entry if its index is a \n    multiple of 3 and will cube the integer entry if its index is a multiple of 4 and not a multiple of 3. The function will not \n    change the entries in the list whose indexes are not a multiple of 3 or 4. The function shall then return the sum of all entries. ",
        "rewrite": "def sum_squares_2(lst):\n    return sum([x**2 if i % 3 == 0 else x**3 if i % 4 == 0 else x for i, x in enumerate(lst)])"
    },
    {
        "original": "    words = sentence.split()\n    return \" \".join(words)",
        "rewrite": "words = sentence.split()\nreturn \" \".join(words)"
    },
    {
        "original": "    if n == 0:\n        return False\n    elif n == 1:\n        return True\n    elif n % 1 == 0:\n        return simplify(x, n // 1)\n    else:\n        return simplify(x, n // 1) and simplify(x, n % 1)\n#",
        "rewrite": "if n == 0:\n    return False\nelif n == 1:\n    return True\nelif n % 1 == 0:\n    return simplify(x, n // 1)\nelse:\n    return simplify(x, n // 1) and simplify(x, n % 1)"
    },
    {
        "original": "    def order_by_points(nums):\n        \"\"\"\n        Write a function which sorts the given list of integers\n        in ascending order according to the sum of their digits.\n        Note: if there are several items with similar sum of their digits,\n        order them based on their index in original list.\n        For example:\n        >>> order_by_points([1, 11, -1, -11, -12]) == [-1, -11, 1, -12, 11]\n        >>> order_by_points([]) == []\n        \"\"\"\n        nums",
        "rewrite": "def order_by_points(nums):\n    return sorted(nums, key=lambda x: (sum(map(int, str(x))), nums.index(x)))"
    },
    {
        "original": "    return len([x for x in nums if x > 10 and x % 10 == 1 and x % 100!= 11])\n#",
        "rewrite": "return len([x for x in nums if x > 10 and x % 10 == 1 and x % 100 != 11])"
    },
    {
        "original": "    #",
        "rewrite": "# Hello, world!"
    },
    {
        "original": "    return planet1, planet2\n#",
        "rewrite": "return planet1, planet2"
    },
    {
        "original": "    def list_sort(lst):\n        \"\"\"Write a function that accepts a list of strings as a parameter,\n        deletes the strings that have odd lengths from it,\n        and returns the resulted list with a sorted order,\n        The list is always a list of strings and never an array of numbers,\n        and it may contain duplicates.\n        The order of the list should be ascending by length of each word, and you\n        should return the list sorted by that rule.\n        If two words have the same length, sort the list alphabetically.\n        The function should return",
        "rewrite": "def list_sort(lst):\n    return sorted([word for word in lst if len(word) % 2 == 0], key=lambda x: (len(x), x))"
    },
    {
        "original": "    if n % 2 == 0:\n        return x\n    else:\n        return y\n#",
        "rewrite": "if n % 2 == 0:\n        return x\nelse:\n        return y"
    },
    {
        "original": "    if len(lst) == 0:\n        return 0\n    else:\n        return sum([x*x for x in lst if x%2!= 0])\n#",
        "rewrite": "if len(lst) == 0:\n    return 0\nelse:\n    return sum([x*x for x in lst if x % 2 != 0])"
    },
    {
        "original": "    def compare(game,guess):\n        \"\"\"I think we all remember that feeling when the result of some long-awaited\n        event is finally known. The feelings and thoughts you have at that moment are\n        definitely worth noting down and comparing.\n        Your task is to determine if a person correctly guessed the results of a number of matches.\n        You are given two arrays of scores and guesses of equal length, where each index shows a match. \n        Return an array of the same length denoting how far off each guess was. If they have guessed correctly,\n        the value",
        "rewrite": "def compare(game, guess):\n    result = []\n    for i in range(len(game)):\n        result.append(abs(game[i] - guess[i]))\n    return result"
    },
    {
        "original": "    extensions = [ext.upper() for ext in extensions]\n    extensions.sort()\n    return class_name + '.' + extensions[0]\n#",
        "rewrite": "extensions = [ext.upper() for ext in extensions]\nextensions.sort()\nreturn class_name + '.' + extensions[0]"
    },
    {
        "original": "    if a in b:\n        return True\n    else:\n        return False\n#",
        "rewrite": "return a in b"
    },
    {
        "original": "    even = 0\n    odd = 0\n    for i in num:\n        if i % 2 == 0:\n            even += 1\n        else:\n            odd += 1\n    return (even, odd)\n#",
        "rewrite": "even = 0\nodd = 0\nfor i in num:\n    if i % 2 == 0:\n        even += 1\n    else:\n        odd += 1\nreturn (even, odd)"
    },
    {
        "original": "    roman = ''\n    if number < 1:\n        return ''\n    elif number < 10:\n        roman += 'x'\n        number -= 1\n    elif number < 20:\n        roman += 'xx'\n        number -= 10\n    elif number < 100:\n        roman += 'c'\n        number -= 20\n    elif number < 1000:\n        roman += 'cc'\n        number -= 100\n    else:\n        roman += 'ccc'\n        number -= 1000\n    while number > 0:\n        if number % 10 == 1",
        "rewrite": "roman += 'i'\n        number -= 1"
    },
    {
        "original": "    if a == b and b == c:\n        return True\n    elif a == b or b == c or a == c:\n        return False\n    elif a > b and a > c:\n        return True\n    elif b > a and b > c:\n        return True\n    elif c > a and c > b:\n        return True\n    else:\n        return False\n#",
        "rewrite": "if a == b and b == c:\n    return True\nelif a == b or b == c or a == c:\n    return False\nelif a > b and a > c:\n    return True\nelif b > a and b > c:\n    return True\nelif c > a and c > b:\n    return True\nelse:\n    return False"
    },
    {
        "original": "    max_word = \"\"\n    max_count = 0\n    for word in words:\n        count = 0\n        for char in word:\n            if char in word:\n                count += 1\n        if count > max_count:\n            max_count = count\n            max_word = word\n    return max_word\nprint(find_max([\"name\", \"of\", \"string\"]))\nprint(find_max([\"name\", \"enam\", \"game\"]))\nprint(find_max([\"aaaaaaa\", \"bb\",\"cc\"]))",
        "rewrite": "def find_max(words):\n    max_word = \"\"\n    max_count = 0\n    for word in words:\n        count = 0\n        for char in word:\n            if char in word:\n                count += 1\n        if count > max_count:\n            max_count = count\n            max_word = word\n    return max_word\n\nprint(find_max([\"name\", \"of\", \"string\"]))\nprint(find_max([\"name\", \"enam\", \"game\"]))\nprint(find_max([\"aaaaaaa\", \"bb\", \"cc\"]))"
    },
    {
        "original": "    if number <= 0:\n        return [0, 0]\n    if number > 1000:\n        return [1000, 1000]\n    if need > remaining:\n        return [remaining, need]\n    if need == remaining:\n        return [number, 0]\n    if need > number:\n        return [number, need - number]\n    return [need, 0]\nprint(eat(5, 6, 10))\nprint(eat(4, 8, 9))\nprint(eat(1, 10, 10))\nprint(eat(2, 11",
        "rewrite": "def eat(need, remaining, number):\n    if number <= 0:\n        return [0, 0]\n    if number > 1000:\n        return [1000, 1000]\n    if need > remaining:\n        return [remaining, need]\n    if need == remaining:\n        return [number, 0]\n    if need > number:\n        return [number, need - number]\n    return [need, 0]\n\nprint(eat(5, 6, 10))\nprint(eat(4, 8, 9))\nprint(eat(1, 10, 10))\nprint(eat(2, 11, 10)  # Added missing parenthesis in last \"eat\" call."
    },
    {
        "original": "    if operator == '+':\n        return operand[0] + operand[1]\n    elif operator == '-':\n        return operand[0] - operand[1]\n    elif operator == '*':\n        return operand[0] * operand[1]\n    elif operator == '/':\n        return operand[0] / operand[1]\n    elif operator == '**':\n        return operand[0] ** operand[1]\n    else:\n        return 0\n#",
        "rewrite": "if operator == '+':\n    return operand[0] + operand[1]\nelif operator == '-':\n    return operand[0] - operand[1]\nelif operator == '*':\n    return operand[0] * operand[1]\nelif operator == '/':\n    return operand[0] / operand[1]\nelif operator == '**':\n    return operand[0] ** operand[1]\nelse:\n    return 0"
    },
    {
        "original": "    return \"\".join(reversed(s))\ndef main():\n    print(solve(\"1234\"))\n    print(solve(\"ab\"))\n    print(solve(\"#",
        "rewrite": "def solve(s):\n    return \"\".join(reversed(s))\n\ndef main():\n    print(solve(\"1234\"))\n    print(solve(\"ab\"))\n    print(solve(\"#\"))\n\nmain()"
    },
    {
        "original": "    if text:\n        return hashlib.md5(text.encode('utf-8')).hexdigest()\n    else:\n        return None\ndef md5_to_string(md5):\n    \"\"\"\n    Given a md5 hash'md5', return its string equivalent.\n    If'md5' is an empty string, return None.\n    >>> md5_to_string('3e25960a79dbc69b674cd4ec67a72c62') == 'Hello world'\n    \"\"\"\n, no explanation, just code",
        "rewrite": "if text:\n    return hashlib.md5(text.encode('utf-8')).hexdigest()\nelse:\n    return None\n    \ndef md5_to_string(md5):\n    return md5.encode('utf-8').decode('utf-8') if md5 else None"
    },
    {
        "original": "    if a > b:\n        return []\n    if a == b:\n        return [a]\n    if a % 2 == 0:\n        return [a] + generate_integers(a // 2, b)\n    return generate_integers(a, (a + b) // 2)\n#",
        "rewrite": "if a > b:\n    return []\nif a == b:\n    return [a]\nif a % 2 == 0:\n    return [a] + generate_integers(a // 2, b)\nreturn generate_integers(a, (a + b) // 2)"
    }
]