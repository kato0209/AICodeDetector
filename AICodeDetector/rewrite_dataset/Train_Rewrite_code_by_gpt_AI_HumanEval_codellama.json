[
    {
        "original": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
        "rewrite": "from typing import List\n\ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for i in range(len(numbers)):\n        for j in range(i+1, len(numbers)):\n            if abs(numbers[i] - numbers[j]) < threshold:\n                return True\n    return False"
    },
    {
        "original": "def separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']",
        "rewrite": "from typing import List\n\ndef separate_paren_groups(paren_string: str) -> List[str]:\n    groups = []\n    stack = []\n    group = \"\"\n    \n    for char in paren_string:\n        if char == \"(\":\n            stack.append(\"(\")\n            group += \"(\"\n        elif char == \")\":\n            stack.pop()\n            group += \")\"\n            if not stack:\n                groups.append(group)\n                group = \"\"\n    return groups\n\nprint(separate_paren_groups(\"( ) (( )) (( )( ))\"))"
    },
    {
        "original": "def truncate_number(number: float) -> float:\n    return abs(number) - int(abs(number))",
        "rewrite": "def truncate_number(number: float) -> float:\n    return abs(number) - int(abs(number))"
    },
    {
        "original": "def below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
        "rewrite": "from typing import List\n\ndef below_zero(operations: List[int]) -> bool:\n    balance = 0\n    for operation in operations:\n        balance += operation\n        if balance < 0:\n            return True\n    return False\n\n# test cases\nprint(below_zero([1, 2, 3]))  # False\nprint(below_zero([1, 2, -4, 5]))  # True"
    },
    {
        "original": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\ndef mean",
        "rewrite": "from typing import List\n\ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    deviations = [abs(x - mean) for x in numbers]\n    return sum(deviations) / len(deviations)"
    },
    {
        "original": "def intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> intersperse([], 4)\n    []\n    >>> intersperse([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"",
        "rewrite": "from typing import List\n\ndef intersperse(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers' \"\"\"\n    \n    result = []\n    for num in numbers:\n        result.append(num)\n        if num != numbers[-1]:\n            result.append(delimeter)\n    \n    return result\n\n# Testing the function\nprint(intersperse([], 4))\nprint(intersperse([1, 2, 3], 4))  # Output should be [1, 4, 2, 4, 3]"
    },
    {
        "original": "def parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    return [max(",
        "rewrite": "from typing import List\n\ndef parse_nested_parens(paren_string: str) -> List[int]:\n    \"\"\"\n    Input to this function is a string representing multiple groups of nested parentheses separated by spaces.\n    For each of the groups, output the deepest level of nesting of parentheses.\n    E.g. (()()) has a maximum of two levels of nesting while ((())) has three.\n    >>> parse_nested_parens('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def count_nested_parens(group: str) -> int:\n        stack = 0\n        max_depth = 0\n\n        for char in group:\n            if char == '(':\n                stack += 1\n                max_depth = max(max_depth, stack)\n            elif char == ')':\n                stack -= 1\n\n        return max_depth\n\n    return [count_nested_parens(val) for val in paren_string.split()]\n\nparsed_parens = parse_nested_parens('(()()) ((())) () ((())()())')\nprint(parsed_parens)"
    },
    {
        "original": "def filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> filter_by_substring([], 'a')\n    []\n    >>> filter_by_substring(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter",
        "rewrite": "from typing import List\n\ndef filter_by_substring(strings: List[str], substring: str) -> List[str]:\n    return [s for s in strings if substring in s]"
    },
    {
        "original": "def sum_product(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> sum_product([])\n    (0, 1)\n    >>> sum_product([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"",
        "rewrite": "from typing import List, Tuple\n\ndef sum_product(numbers: List[int]) -> Tuple[int, int]:\n    sum_val = 0\n    product_val = 1\n    \n    if numbers:\n        sum_val = sum(numbers)\n        for num in numbers:\n            product_val *= num\n    \n    return sum_val, product_val"
    },
    {
        "original": "def rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"",
        "rewrite": "from typing import List\n\ndef rolling_max(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> rolling_max([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    if not numbers:\n        return []\n    max_nums = [numbers[0]]\n    for num in numbers[1:]:\n        max_nums.append(max(num, max_nums[-1]))\n    return max_nums"
    },
    {
        "original": "",
        "rewrite": "\"\"\noprning_hours = {\n    \"Monday\": \"9am - 5pm\",\n    \"Tuesday\": \"9am - 5pm\",\n    \"Wednesday\": \"9am - 5pm\",\n    \"Thursday\": \"9am - 5pm\",\n    \"Friday\": \"9am - 5pm\",\n    \"Saturday\": \"10am - 3pm\",\n    \"Sunday\": \"Closed\"\n}"
    },
    {
        "original": "def string_xor(a: str, b: str) -> str:\n    return ''.join(str(int(a[i] != b[i])) for i in range(len(a)))\ndef string_xor(a: str, b: str) -> str:\n    return ''.join(str(int(a[i] != b[i])) for i in range(len(a)))\ndef string_xor(a: str, b: str) -> str:\n    return ''.join(str(int",
        "rewrite": "def string_xor(a: str, b: str) -> str:\n    return ''.join(str(int(a[i] != b[i])) for i in range(len(a)))"
    },
    {
        "original": "def longest(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the longest one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> longest([])\n    >>> longest(['a', 'b', 'c'])\n    'a'\n    >>> longest(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"",
        "rewrite": "from typing import List, Optional\n\ndef longest(strings: List[str]) -> Optional[str]:\n    if not strings:\n        return None\n    longest_str = ''\n    max_length = 0\n    for string in strings:\n        if len(string) > max_length:\n            max_length = len(string)\n            longest_str = string\n    return longest_str\n\nprint(longest([]))\nprint(longest(['a', 'b', 'c']))\nprint(longest(['a', 'bb', 'ccc']))"
    },
    {
        "original": "def greatest_common_divisor(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return a",
        "rewrite": "def greatest_common_divisor(a: int, b: int) -> int:\n    while b:\n        a, b = b, a % b\n    return a"
    },
    {
        "original": "def all_prefixes(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> all_prefixes('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"",
        "rewrite": "from typing import List\n\ndef all_prefixes(string: str) -> List[str]:\n    return [string[:i + 1] for i in range(len(string))]\n\n# Test the function\nprint(all_prefixes('abc'))"
    },
    {
        "original": "def string_sequence(n: int) -> str:\n    return ' '.join(map(str, range(n+1)))",
        "rewrite": "def string_sequence(n: int) -> str:\n    return ' '.join(map(str, range(n + 1)))"
    },
    {
        "original": "```python\ndef count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))\n```",
        "rewrite": "```python\ndef count_distinct_characters(string: str) -> int:\n    return len(set(string.lower()))\n```"
    },
    {
        "original": "def parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n    >>> parse_music('o o| .",
        "rewrite": "from typing import List\n\ndef parse_music(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return a list of integers corresponding to how many beats each\n    note lasts.\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quarter note, lasts one beat\n    >>> parse_music('o o| .\" . No need to explain. Just write code:'\n    \"\"\"\n    duration_map = {\n        'o': 4,\n        'o|': 2,\n        '.|': 1\n    }\n    notes = music_string.split(' ')\n    result = []\n    for note in notes:\n        if note in duration_map:\n            result.append(duration_map[note])\n    return result"
    },
    {
        "original": "def how_many_times(string: str, substring: str) -> int:\n    return string.count(substring)",
        "rewrite": "def how_many_times(string: str, substring: str) -> int:\n    return string.count(substring)"
    },
    {
        "original": "def sort_numbers(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"",
        "rewrite": "def sort_numbers(numbers: str) -> str:\n    \"\"\"\n    Input is a space-delimited string of numerals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> sort_numbers('three one five')\n    'one three five'\n    \"\"\"\n    num_map = {'zero': '0', 'one': '1', 'two': '2', 'three': '3', 'four': '4', 'five': '5', 'six': '6', 'seven': '7', 'eight': '8', 'nine': '9'}\n    \n    nums = numbers.split()\n    nums.sort(key=lambda x: num_map[x])\n    \n    return ' '.join(nums)"
    },
    {
        "original": "def find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> find_closest_elements([",
        "rewrite": "from typing import List, Tuple\n\ndef find_closest_elements(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number). \"\"\"\n    \n    numbers.sort()  # Sort the numbers in ascending order.\n    min_diff = float('inf')\n    closest_pair = ()\n    \n    for i in range(1, len(numbers)):\n        diff = numbers[i] - numbers[i - 1]\n        if diff < min_diff:\n            min_diff = diff\n            closest_pair = (numbers[i - 1], numbers[i])\n    \n    return closest_pair\n\n# Test the function\nprint(find_closest_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.2]))  # Expected output: (2.0, 2.2)\nprint(find_closest_elements([2.0, 10.4, 4.5, 8.2,]))  # Expected output: (2.0, 4.5)"
    },
    {
        "original": "def rescale_to_unit(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]",
        "rewrite": "from typing import List\n\ndef rescale_to_unit(numbers: List[float]) -> List[float]:\n    min_num = min(numbers)\n    max_num = max(numbers)\n    rescaled = [(num - min_num) / (max_num - min_num) for num in numbers]\n    return rescaled\n\nprint(rescale_to_unit([1.0, 2.0, 3.0, 4.0, 5.0]))"
    },
    {
        "original": "def filter_integers(values: List[Any]) -> List[int]:\n    return [value for value in values if isinstance(value, int)]\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [value for value in values if type(value) == int]\ndef filter_integers(values: List[Any]) -> List[int]:\n    return [value for value in values if isinstance(value, int)]\ndef filter_integers(values: List[Any]) -> List",
        "rewrite": "Any]:\n    return [value for value in values if isinstance(value, int)]"
    },
    {
        "original": "```\ndef strlen(string: str) -> int:\n    return len(string)\n```",
        "rewrite": "def strlen(string: str) -> int:\n    return len(string)"
    },
    {
        "original": "def largest_divisor(n: int) -> int:\n    for i in range(1, n):\n        if n % i == 0:\n            return i\n    return 1",
        "rewrite": "def largest_divisor(n: int) -> int:\n    for i in range(n-1, 0, -1):\n        if n % i == 0:\n            return i\n    return 1"
    },
    {
        "original": "def factorize(n: int) -> List[int]:\n    factors = []\n    while n > 1:\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                factors.append(i)\n                n //= i\n                break\n        else:\n            factors.append(n)\n            break\n    return factors\ndef test_factorize():\n    assert factorize(8) == [2, 2, 2]\n    assert factor",
        "rewrite": "def factorize(n: int) -> List[int]:\n    factors = []\n    while n > 1:\n        for i in range(2, int(n ** 0.5) + 1):\n            if n % i == 0:\n                factors.append(i)\n                n //= i\n                break\n        else:\n            factors.append(n)\n            break\n    return factors\n\ndef test_factorize():\n    assert factorize(8) == [2, 2, 2]\n    assert factorize(12) == [2, 2, 3]"
    },
    {
        "original": "def remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"",
        "rewrite": "from typing import List\n\ndef remove_duplicates(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep the order of elements the same as in the input.\n    >>> remove_duplicates([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    return [num for num in numbers if numbers.count(num) == 1]"
    },
    {
        "original": "def flip_case(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"",
        "rewrite": "def flip_case(string: str) -> str:\n    \"\"\"\n    For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> flip_case('Hello')\n    'hELLO'\n    \"\"\"\n    return ''.join([char.lower() if char.isupper() else char.upper() for char in string])"
    },
    {
        "original": "def concatenate(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> concatenate([])\n    ''\n    >>> concatenate(['a', 'b', 'c'])\n    'abc'\n    \"\"\"",
        "rewrite": "from typing import List\n\ndef concatenate(strings: List[str]) -> str:\n    return ''.join(strings)"
    },
    {
        "original": "def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> filter_by_prefix([], 'a')\n    []\n    >>> filter_by_prefix(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"",
        "rewrite": "def filter_by_prefix(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix. \"\"\"\n    return [s for s in strings if s.startswith(prefix)]"
    },
    {
        "original": "def get_positive(l: list):\n    return [x for x in l if x > 0]",
        "rewrite": "def get_positive(l: list):\n    return [x for x in l if x > 0]"
    },
    {
        "original": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
        "rewrite": "def is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"
    },
    {
        "original": "def poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\ndef find_zero(xs: list):\n    \"\"\" xs are coefficients of a polynomial.\n    find_zero find x such that poly(x)",
        "rewrite": "import math\n\ndef poly(xs: list, x: float):\n    \"\"\"\n    Evaluates polynomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[2] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\ndef find_zero(xs: list):\n    \"\"\" Find x such that poly(x) == 0 \"\"\"\n    return [i for i in range(-100, 101) if poly(xs, i) == 0]"
    },
    {
        "original": "def sort_third(l: list):\n    l = l[::3]\n    l.sort()\n    return l",
        "rewrite": "def sort_third(l: list):\n    l = l[2::3]\n    l.sort()\n    return l"
    },
    {
        "original": "def unique(l: list):\n    return sorted(set(l))",
        "rewrite": "def unique(l: list):\n    return sorted(list(set(l)))"
    },
    {
        "original": "def max_element(l: list):\n    return max(l)",
        "rewrite": "def max_element(lst: list):\n    return max(lst)"
    },
    {
        "original": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if i % 11 == 0 or i % 13 == 0:\n            if '7' in str(i):\n                count += 1\n    return count",
        "rewrite": "def fizz_buzz(n: int):\n    count = 0\n    for i in range(1, n):\n        if (i % 11 == 0 or i % 13 == 0) and '7' in str(i):\n            count += 1\n    return count"
    },
    {
        "original": "def sort_even(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> sort_even([1, 2, 3])\n    [1, 2, 3]\n    >>> sort_even([5, 6, 3, 4])\n    [3, 6, 5, 4]",
        "rewrite": "def sort_even(l: list):\n    return [sorted(l[::2]) if i % 2 != 0 else l[i] for i in range(len(l))]"
    },
    {
        "original": "def decode_cyclic(s: str):\n    \"\"\"\n    takes as input string encoded with encode_cyclic function. Returns decoded string.\n    \"\"\"\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)",
        "rewrite": "def decode_cyclic(s: str):\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) // 3)]\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)"
    },
    {
        "original": "def prime_fib(n: int):\n    a, b = 1, 2\n    for _ in range(n):\n        a, b = b, a + b\n        if is_prime(a):\n            return a\n    return a\ndef is_prime(n: int):\n    if n == 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
        "rewrite": "def prime_fib(n: int):\n    a, b = 1, 2\n    for _ in range(n):\n        a, b = b, a + b\n        if is_prime(a):\n            return a\n    return a\n\ndef is_prime(n: int):\n    if n == 1:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"
    },
    {
        "original": "def triples_sum_to_zero(l: list):\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False",
        "rewrite": "def triples_sum_to_zero(l: list):\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            for k in range(j+1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False"
    },
    {
        "original": "def car_race_collision(n: int):\n    return n * (n - 1) // 2",
        "rewrite": "def car_race_collision(n: int):\n    return (n * (n - 1)) // 2"
    },
    {
        "original": "def incr_list(l: list):\n    return [x+1 for x in l]\ndef incr_list(l: list):\n    return [x+1 for x in l]\ndef incr_list(l: list):\n    return [x+1 for x in l]\ndef incr_list(l: list):\n    return [x+1 for x in l]\ndef incr_list(l: list):\n    return [x+1 for x in l]\ndef incr_list(",
        "rewrite": "def incr_list(l: list):\n    return [x+1 for x in l]"
    },
    {
        "original": "def pairs_sum_to_zero(l):\n    for i in range(len(l)):\n        for j in range(i+1, len(l)):\n            if l[i] + l[j] == 0:\n                return True\n    return False",
        "rewrite": "def pairs_sum_to_zero(l):\n    return any(l[i] + l[j] == 0 for i in range(len(l)) for j in range(i+1, len(l)) )"
    },
    {
        "original": "def change_base(x: int, base: int):\n    return bin(x)[2:].zfill(base)",
        "rewrite": "def change_base(x: int, base: int):\n    return format(x, '0'+str(base)+'b')"
    },
    {
        "original": "def triangle_area(a, h):\n    return a * h / 2",
        "rewrite": "def triangle_area(base, height):\n    return base * height / 2"
    },
    {
        "original": "def fib4(n: int):\n    \"\"\"The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    fib4(0) -> 0\n    fib4(1) -> 0\n    fib4(2) -> 2\n    fib4(3) -> 0\n    fib4(n) -> fib4(n-1) + fib4(n-2) + fib4(n-3) + fib4(n-4).\n    Please write a function to efficiently compute the",
        "rewrite": "def fib4(n: int):\n    a, b, c, d = 0, 0, 2, 0\n    if n == 0:\n        return a\n    elif n == 1:\n        return b\n    elif n == 2:\n        return c\n    elif n == 3:\n        return d\n    for i in range(4, n+1):\n        a, b, c, d = b, c, d, a + b + c + d\n    return d"
    },
    {
        "original": "def median(l: list):\n    l.sort()\n    if len(l) % 2 == 0:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2\n    else:\n        return l[len(l) // 2]",
        "rewrite": "def median(l: list):\n    l.sort()\n    if len(l) % 2 == 0:\n        return (l[len(l) // 2 - 1] + l[len(l) // 2]) / 2\n    else:\n        return l[len(l) // 2]"
    },
    {
        "original": "def is_palindrome(text: str):\n    return text == text[::-1]",
        "rewrite": "def is_palindrome(text: str):\n    return text == text[::-1]"
    },
    {
        "original": "def modp(n: int, p: int):\n    return pow(2, n, p)",
        "rewrite": "def modp(n: int, p: int):\n    return pow(2, n, p)"
    },
    {
        "original": "def decode_shift(s: str):\n    \"\"\"\n    takes as input string encoded with encode_shift function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\ndef main():\n    print(decode_shift(encode_shift(\"hello\")))\nif __name__ == \"__main__\":\n    main()",
        "rewrite": "def encode_shift(s: str):\n    return \"\".join([chr(((ord(ch) - ord(\"a\") + 5) % 26) + ord(\"a\")) for ch in s])\n\ndef decode_shift(s: str):\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(\"a\") for ch in s])\n\ndef main():\n    print(decode_shift(encode_shift(\"hello\")))\n\nif __name__ == \"__main__\":\n    main()"
    },
    {
        "original": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes string and returns string without vowels.\n    >>> remove_vowels('')\n    ''\n    >>> remove_vowels(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> remove_vowels('abcdef')\n    'bcdf'\n    >>> remove_vowels('aaaaa')\n    ''\n    >>> remove_vowels('aaBAA')\n    'B",
        "rewrite": "def remove_vowels(text):\n    \"\"\"\n    remove_vowels is a function that takes a string and returns a string without vowels.\n    \"\"\"\n    vowels = \"aeiouAEIOU\"\n    return ''.join([char for char in text if char not in vowels])"
    },
    {
        "original": "def below_threshold(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are below threshold t.\n    >>> below_threshold([1, 2, 4, 10], 100)\n    True\n    >>> below_threshold([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    return all(x < t for x in l)",
        "rewrite": "def below_threshold(l: list, t: int):\n    return all(x < t for x in l)"
    },
    {
        "original": "def add(x: int, y: int):\n    return x + y",
        "rewrite": "def add(x: int, y: int) -> int:\n    return x + y"
    },
    {
        "original": "",
        "rewrite": "Sure, here is the revised code:\n\n```python\nprint(\"Hello, World!\")\n```"
    },
    {
        "original": "def fib(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> fib(10)\n    55\n    >>> fib(1)\n    1\n    >>> fib(8)\n    21\n    \"\"\"\n    if n <= 1:\n        return n\n    else:\n        return fib(n-1) + fib(n-2)",
        "rewrite": "def fib(n: int):\n    if n <= 1:\n        return n\n    else:\n        return fib(n-1) + fib(n-2)"
    },
    {
        "original": "def correct_bracketing(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":",
        "rewrite": "def correct_bracketing(brackets: str):\n    \"\"\"\n    brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n    >>> correct_bracketing(\"<\")\n    False\n    >>> correct_bracketing(\"<>\")\n    True\n    >>> correct_bracketing(\"<<><>>\")\n    True\n    >>> correct_bracketing(\"><<>\")\n    False\n    \"\"\"\n    stack = []\n    for bracket in brackets:\n        if bracket == \"<\":\n            stack.append(bracket)\n        elif bracket == \">\" and stack:\n            stack.pop()\n        else:\n            return False\n    return not stack"
    },
    {
        "original": "def monotonic(l: list):\n    return all(l[i] <= l[i+1] for i in range(len(l)-1))",
        "rewrite": "def is_monotonic(l: list):\n    return all(l[i] <= l[i+1] for i in range(len(l)-1))"
    },
    {
        "original": "def common(l1: list, l2: list):\n    return sorted(set(l1).intersection(set(l2)))",
        "rewrite": "def common(l1: list, l2: list):\n    return sorted(list(set(l1) & set(l2)))"
    },
    {
        "original": "def largest_prime_factor(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> largest_prime_factor(13195)\n    29\n    >>> largest_prime_factor(2048)\n    2\n    \"\"\"\n    if n % 2 == 0:\n        if n % 3 == 0:\n            return 3\n        for i in range(5, int(n ** 0.5) + 1, 6):",
        "rewrite": "def largest_prime_factor(n: int):\n    if n % 2 == 0:\n        if n % 3 == 0:\n            return 3\n        for i in range(5, int(n ** 0.5) + 1, 6):"
    },
    {
        "original": "```python\ndef sum_to_n(n: int):\n    return sum(range(1, n+1))\n```\n### 1.1.2. Write a function that takes a list of numbers and returns the sum of the numbers.\n```python\ndef sum_list(numbers: list):\n    return sum(numbers)\n```\n### 1.1.3. Write a function that takes a list of numbers and returns the sum of the numbers.\n```python\ndef sum_list(numbers: list):\n    return sum",
        "rewrite": "```python\ndef sum_list(numbers: list):\n    return sum(numbers)\n```"
    },
    {
        "original": "    stack = []\n    for bracket in brackets:\n        if bracket == \"(\":\n            stack.append(bracket)\n        elif bracket == \")\":\n            if not stack:\n                return False\n            stack.pop()\n    return not stack",
        "rewrite": "stack = []\nfor bracket in brackets:\n    if bracket == \"(\":\n        stack.append(bracket)\n    elif bracket == \")\":\n        if not stack:\n            return False\n        stack.pop()\nreturn not stack"
    },
    {
        "original": "def derivative(xs: list):\n    return [xs[i+1] * (i+1) for i in range(len(xs)-1)]",
        "rewrite": "def derivative(xs: list):\n    return [xs[i+1] * (i+1) for i in range(len(xs) - 1)]"
    },
    {
        "original": "```\ndef fibfib(n: int):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)\n```",
        "rewrite": "def fibfib(n: int):\n    if n == 0:\n        return 0\n    elif n == 1:\n        return 0\n    elif n == 2:\n        return 1\n    else:\n        return fibfib(n-1) + fibfib(n-2) + fibfib(n-3)"
    },
    {
        "original": "    count = 0\n    for c in s:\n        if c in \"aeiouy\":\n            count += 1\n    return count\ndef vowels_count(s):\n    \"\"\"Write a function vowels_count which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word",
        "rewrite": "def vowels_count(s):\n    count = 0\n    for c in s:\n        if c in \"aeiouy\":\n            count += 1\n    return count"
    },
    {
        "original": "def circular_shift(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> circular_shift(12, 1)\n    \"21\"\n    >>> circular_shift(12, 2)\n    \"12\"\n    \"\"\"\n    return str(x)[shift:] + str(x)[:shift]",
        "rewrite": "def circular_shift(x, shift):\n    return str(x)[-shift:] + str(x)[:-shift]"
    },
    {
        "original": "    s = s.upper()\n    sum = 0\n    for c in s:\n        sum += ord(c)\n    return sum",
        "rewrite": "s = s.upper()\ntotal_sum = 0\nfor char in s:\n    total_sum += ord(char)\nreturn total_sum"
    },
    {
        "original": "def fruit_distribution(s,n):\n    apples = s.split()[0]\n    oranges = s.split()[2]\n    return n - int(apples) - int(oranges)",
        "rewrite": "def fruit_distribution(s, n):\n    apples, _, oranges = s.split()\n    return n - int(apples) - int(oranges)"
    },
    {
        "original": "def pluck(arr):\n    if not arr:\n        return []\n    smallest = min(arr, key=lambda x: x[1] if x[0] % 2 == 0 else x[0])\n    return [smallest[0], smallest[1]]",
        "rewrite": "def pluck(arr):\n    if not arr:\n        return []\n    smallest = min(arr, key=lambda x: x[1] if x[0] % 2 == 0 else x[0])\n    return [smallest[0], smallest[1]]"
    },
    {
        "original": "def search(lst):\n    # Write your code here\n    lst.sort()\n    for i in range(len(lst)-1, -1, -1):\n        if lst[i] > 0 and lst[i] >= lst.count(lst[i]):\n            return lst[i]\n    return -1",
        "rewrite": "def search(lst):\n    lst.sort()\n    for i in range(len(lst)-1, -1, -1):\n        if lst[i] > 0 and lst[i] >= lst.count(lst[i]):\n            return lst[i]\n    return -1"
    },
    {
        "original": "def strange_sort_list(lst):\n    return sorted(lst, key=lambda x: -x)",
        "rewrite": "def strange_sort_list(lst):\n    return sorted(lst, key=lambda x: -x)"
    },
    {
        "original": "def triangle_area(a, b, c):\n    if a+b>c and b+c>a and a+c>b:\n        s=(a+b+c)/2\n        return round(s*(s-a)*(s-b)*(s-c),2)\n    else:\n        return -1",
        "rewrite": "def triangle_area(a, b, c):\n    if a + b > c and b + c > a and a + c > b:\n        s = (a + b + c) / 2\n        return round(s * (s - a) * (s - b) * (s - c), 2)\n    else:\n        return -1"
    },
    {
        "original": "def will_it_fly(q,w):\n    if q == q[::-1] and sum(q) <= w:\n        return True\n    else:\n        return False",
        "rewrite": "def will_it_fly(q, w):\n    return q == q[::-1] and sum(q) <= w"
    },
    {
        "original": "def smallest_change(arr):\n    # Write your code here.\n    # O(n) time and O(n) space\n    # n is the length of the array\n    # O(n) time and O(1) space\n    # n is the length of the array\n    # O(n) time and O(1) space\n    # n is the length of the array\n    # O(n) time and O(1) space\n    # n is the length of the array\n    # O(n) time and O(1) space",
        "rewrite": "def smallest_change(arr):\n    min_diff = float('inf')\n    arr.sort()\n    \n    for i in range(len(arr) - 1):\n        diff = arr[i+1] - arr[i]\n        min_diff = min(min_diff, diff)\n        \n    return min_diff"
    },
    {
        "original": "",
        "rewrite": "I'm sorry, but you haven't provided any code to revise. If you can provide the code you would like me to work on, I would be happy to assist you in revising it."
    },
    {
        "original": "def is_multiply_prime(a):\n    if a < 100:\n        return False\n    for i in range(2, 10):\n        if a % i == 0:\n            return False\n    return True",
        "rewrite": "def is_multiply_prime(a):\n    if a < 100:\n        return False\n    for i in range(2, 10):\n        if a % i == 0:\n            return False\n    return True"
    },
    {
        "original": "def is_simple_power(x, n):\n    return x == n ** int(log(x, n))",
        "rewrite": "def is_simple_power(x, n):\n    from math import log\n    return x == n ** int(log(x, n))"
    },
    {
        "original": "def iscube(a):\n    return a**3 == a",
        "rewrite": "def iscube(a): \n    return a ** 3 == a"
    },
    {
        "original": "def hex_key(num):\n    count = 0\n    for i in num:\n        if i in \"2357ABED\":\n            count += 1\n    return count\ndef hex_key(num):\n    return sum(1 for i in num if i in \"2357ABED\")\ndef hex_key(num):\n    return sum(c in \"2357ABED\" for c in num)\ndef hex_key(num):\n    return sum(c in \"2357ABED\"",
        "rewrite": "def hex_key(num):\n    return sum(c in \"2357ABED\" for c in num)"
    },
    {
        "original": "def decimal_to_binary(decimal):\n    return \"db\" + bin(decimal)[2:] + \"db\"",
        "rewrite": "def decimal_to_binary(decimal):\n    return f\"db{bin(decimal)[2:]}db\""
    },
    {
        "original": "def is_happy(s):\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] == s[i+2]:\n            return False\n    return True",
        "rewrite": "def is_happy(s):\n    if len(s) < 3:\n        return False\n    for i in range(len(s) - 2):\n        if s[i] == s[i+1] == s[i+2]:\n            return False\n    return True"
    },
    {
        "original": "def numerical_letter_grade(grades):\n    return [grade_equation(g) for g in grades]\ndef grade_equation(gpa):\n    if gpa >= 4.0:\n        return 'A+'\n    elif gpa > 3.7:\n        return 'A'\n    elif gpa > 3.3:\n        return 'A-'\n    elif gpa > 3.0:\n        return 'B+'\n    elif gpa > 2.7:\n        return 'B'\n    elif g",
        "rewrite": "```python\ndef numerical_letter_grade(grades):\n    return [grade_equation(g) for g in grades]\n\ndef grade_equation(gpa):\n    if gpa >= 4.0:\n        return 'A+'\n    elif gpa > 3.7:\n        return 'A'\n    elif gpa > 3.3:\n        return 'A-'\n    elif gpa > 3.0:\n        return 'B+'\n    elif gpa > 2.7:\n        return 'B'\n    else:\n        return 'Below B'\n```"
    },
    {
        "original": "def prime_length(string):\n    if len(string) == 0:\n        return False\n    if len(string) == 1:\n        return True\n    if len(string) == 2:\n        return True\n    if len(string) == 3:\n        return True\n    if len(string) == 4:\n        return True\n    if len(string) == 5:\n        return True\n    if len(string) == 6:\n        return True\n    if len(string) == 7:\n        return",
        "rewrite": "def prime_length(string):\n    if len(string) >= 2 and len(string) <= 7:\n        return True\n    else:\n        return False"
    },
    {
        "original": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    count = 0\n    for i in range(10**(n-1), 10**n):\n        if str(i)[0] == '1' or str(i)[-1] == '1':\n            count += 1\n    return count",
        "rewrite": "def starts_one_ends(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    count = 0\n    for i in range(10**(n-1), 10**n):\n        if str(i)[0] == '1' or str(i)[-1] == '1':\n            count += 1\n    return count"
    },
    {
        "original": "def solve(N):\n    return bin(N)[2:]",
        "rewrite": "def solve(N):\n    return bin(N)[2:]"
    },
    {
        "original": "",
        "rewrite": "Sure, here is the revised code:\n\n\"\""
    },
    {
        "original": "def anti_shuffle(s):\n    return ''.join(sorted(s))",
        "rewrite": "def anti_shuffle(s):\n    return ''.join(sorted(s))"
    },
    {
        "original": "def get_row(lst, x):\n    return [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]",
        "rewrite": "def get_row(lst, x):\n    return [(i, j) for i, row in enumerate(lst) for j, val in enumerate(row) if val == x]"
    },
    {
        "original": "def sort_array(array):\n    if sum(array) % 2 == 0:\n        return sorted(array, reverse=True)\n    else:\n        return sorted(array)",
        "rewrite": "def sort_array(array):\n    return sorted(array, reverse=sum(array) % 2 == 0)"
    },
    {
        "original": "def encrypt(s):\n    \"\"\"Create a function encrypt that takes a string as an argument and\n    returns a string encrypted with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    encrypt('hi') returns 'lm'\n    encrypt('asdfghjkl') returns 'ewhjklnop'\n    encrypt('gf') returns 'kj'\n    encrypt('et') returns 'ix'\n    \"\"\"\n    encrypted = \"\"",
        "rewrite": "def encrypt(s):\n\"\"\"Create a function encrypt that takes a string as an argument and returns a string encrypted with the alphabet being rotated. The alphabet should be rotated in a manner such that the letters shift down by two places.\nFor example:\nencrypt('hi') returns 'lm'\nencrypt('asdfghjkl') returns 'ewhjklnop'\nencrypt('gf') returns 'kj'\nencrypt('et') returns 'ix'\n\"\"\"\nshift = 2\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nencrypted = ''\nfor char in s:\n    if char in alphabet:\n        encrypted += alphabet[(alphabet.index(char) + shift) % 26]\n    else:\n        encrypted += char\nreturn encrypted"
    },
    {
        "original": "def next_smallest(lst):\n    lst.sort()\n    if lst[1] == lst[0]:\n        return None\n    else:\n        return lst[1]",
        "rewrite": "def next_smallest(lst):\n    sorted_lst = sorted(lst)\n    if sorted_lst[1] == sorted_lst[0]:\n        return None\n    else:\n        return sorted_lst[1]"
    },
    {
        "original": "",
        "rewrite": "I'm sorry, but I need to know what code you want me to revise before I can provide you with a revised version. Can you please provide me with the code you would like me to revise?"
    },
    {
        "original": "",
        "rewrite": "Sure! Please provide the code that needs to be revised."
    },
    {
        "original": "",
        "rewrite": "I'm sorry, but you have not provided any code for me to revise. Please provide the code that you would like me to assist with."
    },
    {
        "original": "def skjkasdkd(lst):\n    largest_prime = 0\n    for i in lst:\n        if i > largest_prime:\n            largest_prime = i\n    return sum(str(largest_prime))",
        "rewrite": "def skjkasdkd(lst):\n    largest_prime = 0\n    for i in lst:\n        if i > largest_prime:\n            largest_prime = i\n    return sum(map(int, str(largest_prime)))"
    },
    {
        "original": "def check_dict_case(dict):\n    if not dict:\n        return False\n    if all(isinstance(k, str) and k.islower() for k in dict):\n        return True\n    if all(isinstance(k, str) and k.isupper() for k in dict):\n        return True\n    return False",
        "rewrite": "def check_dict_case(dict):\n    if not dict:\n        return False\n    if all(isinstance(k, str) and k.islower() for k in dict):\n        return True\n    if all(isinstance(k, str) and k.isupper() for k in dict):\n        return True\n    return False"
    },
    {
        "original": "def count_up_to(n):\n    return [x for x in range(2, n+1) if is_prime(x)]\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True",
        "rewrite": "def count_up_to(n):\n    return [x for x in range(2, n+1) if is_prime(x)]\n\ndef is_prime(n):\n    if n < 2:\n        return False\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            return False\n    return True"
    },
    {
        "original": "def multiply(a, b):\n    return a*b",
        "rewrite": "def multiply(a, b):\n    return a * b"
    },
    {
        "original": "def count_upper(s):\n    count = 0\n    for i, c in enumerate(s):\n        if c.isupper() and i % 2 == 0:\n            count += 1\n    return count",
        "rewrite": "def count_upper(s):\n    count = sum(1 for i, c in enumerate(s) if c.isupper() and i % 2 == 0)\n    return count"
    },
    {
        "original": "",
        "rewrite": "cout << \"Hello, World!\";"
    }
]
